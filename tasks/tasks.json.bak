{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Repository and Development Environment",
      "description": "Initialize the project repository with TypeScript, set up the build pipeline, and configure the basic project structure.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create a new TypeScript project using Vite for faster performance and simpler configuration. Initialize the project with a Vite template using `npm create vite@latest your-project-name -- --template vanilla-ts` which handles initial TypeScript setup, basic structure, and dev server configuration. Install necessary dependencies via npm/yarn including a physics engine (Matter.js or Planck.js) and a rendering library (Phaser.js or Pixi.js). Create folder structure for assets, src/game, src/physics, src/ui, and utilities. Set up a basic HTML template with a canvas element.",
      "testStrategy": "Verify that the Vite development environment builds successfully and runs in a browser. Test that TypeScript compilation works correctly. Ensure that the chosen physics and rendering libraries can be imported and used in the project. Confirm that the development server starts without errors and hot module replacement works as expected."
    },
    {
      "id": 2,
      "title": "Implement Basic Rendering and Game Loop",
      "description": "Set up the core game loop and rendering system to display a simple scene with a rocket.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Initialize Phaser.js with a canvas that fills the viewport. Create a game loop that handles updates and rendering at an appropriate frame rate. Implement a simple camera system that can follow the rocket. Create a basic rocket sprite/shape and render it on screen. Implement a simple background to represent space.",
      "testStrategy": "Verify that the game renders at a consistent frame rate. Test that the rocket appears correctly on screen. Ensure the game loop executes properly by logging timing information.",
      "subtasks": [
        {
          "id": 2.1,
          "title": "Create MainScene class",
          "description": "Create `src/game/scenes/MainScene.ts` and define a `class MainScene extends Phaser.Scene`.",
          "status": "done"
        },
        {
          "id": 2.2,
          "title": "Implement MainScene#create()",
          "description": "Set background color to black and add a white `Phaser.GameObjects.Rectangle` at the center of the screen to represent the rocket.",
          "status": "done"
        },
        {
          "id": 2.3,
          "title": "Implement empty preload() and update() methods",
          "description": "Add empty `preload()` and `update()` methods to the MainScene class for future implementation.",
          "status": "done"
        },
        {
          "id": 2.4,
          "title": "Configure Phaser in main.ts",
          "description": "Modify `src/main.ts` to import MainScene, define Phaser.Types.Core.GameConfig with appropriate settings (canvas size, physics), instantiate the Phaser.Game, and remove placeholder console logs.",
          "status": "done",
          "details": "Set the game canvas to fill the window size. Configure basic arcade physics with debug set to false. Add the MainScene to the scenes array in the config."
        }
      ]
    },
    {
      "id": 3,
      "title": "Implement Core Physics Engine Integration",
      "description": "Integrate the physics engine and set up the basic physics world with gravity simulation.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Initialize the chosen physics engine (Matter.js or Planck.js). Create a physics world with configurable gravity. Implement the rocket as a physics body with appropriate mass and shape. Set up collision detection for the rocket. Create a system for variable gravity that increases as the rocket approaches celestial bodies. Implement a basic planetary body with gravity influence.",
      "testStrategy": "Test that the rocket responds to gravity correctly. Verify that gravity increases as the rocket approaches planetary bodies. Ensure collision detection works by creating test objects and checking for collision events.",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize Physics Engine and Create Physics World",
          "description": "Set up the chosen physics engine (Matter.js or Planck.js) and create the basic physics world with default gravity settings.",
          "dependencies": [],
          "details": "1. Install the chosen physics engine via npm (e.g., `npm install matter-js`)\n2. Create a module for physics initialization\n3. Initialize the physics engine with basic configuration\n4. Create a physics world with default gravity (e.g., 9.8 m/sÂ² downward)\n5. Set up the main update loop to step the physics simulation\n6. Add configuration options for world parameters\n7. Test by creating a simple falling object and verifying gravity works correctly\n\n<info added on 2025-04-22T19:48:06.966Z>\nHere's the implementation plan to add:\n\n```typescript\n// Implementation details:\n\n// 1. PhysicsManager.ts structure\nexport class PhysicsManager {\n  private engine: Matter.Engine;\n  private world: Matter.World;\n  \n  constructor(scene: Phaser.Scene) {\n    this.engine = Matter.Engine.create({\n      enableSleeping: true,\n      gravity: { x: 0, y: 1 }\n    });\n    this.world = this.engine.world;\n    \n    // Connect to Phaser's Matter physics\n    scene.matter.world.engine = this.engine;\n  }\n  \n  initializeEngine(options = {}) {\n    // Configure additional engine options\n    Matter.Engine.update(this.engine, options);\n    return this;\n  }\n  \n  createWorld(bounds = { x: 0, y: 0, width: 800, height: 600 }) {\n    // Set world bounds\n    Matter.World.setBounds(this.world, bounds.x, bounds.y, bounds.width, bounds.height);\n    return this;\n  }\n  \n  update(delta: number) {\n    // Fixed timestep for consistent physics\n    Matter.Engine.update(this.engine, delta);\n  }\n  \n  // Test method\n  createTestBody(x: number, y: number) {\n    return Matter.Bodies.circle(x, y, 30, {\n      restitution: 0.8,\n      friction: 0.005\n    });\n  }\n}\n\n// 2. Main.ts physics configuration\nconst config = {\n  // ...other config\n  physics: {\n    default: 'matter',\n    matter: {\n      gravity: { y: 1 },\n      debug: true,\n      debugBodyColor: 0x0000ff\n    }\n  }\n};\n\n// 3. Usage in MainScene.ts\nimport { PhysicsManager } from '../physics/PhysicsManager';\n\nexport class MainScene extends Phaser.Scene {\n  private physicsManager: PhysicsManager;\n  \n  create() {\n    this.physicsManager = new PhysicsManager(this);\n    this.physicsManager.initializeEngine().createWorld();\n    \n    // Test physics\n    const testBody = this.physicsManager.createTestBody(400, 100);\n    Matter.World.add(this.physicsManager.world, testBody);\n  }\n  \n  update(time: number, delta: number) {\n    this.physicsManager.update(delta);\n  }\n}\n```\n</info added on 2025-04-22T19:48:06.966Z>\n\n<info added on 2025-04-26T10:28:39.319Z>\n**Verification Notes (2024-07-27):**\n- Implemented as described.\n- `matter-js` types found in `devDependencies` (likely bundled with Phaser).\n- Phaser config in `main.ts` sets `default: 'matter'` and disables world gravity (`gravity: {x: 0, y: 0}`).\n- `PhysicsManager` found in `packages/client/src/game/physics` initializes Matter engine from scene (`scene.matter.world.engine`) and disables world gravity again.\n- `PhysicsManager` hooks its update logic into `scene.matter.world.on('beforeupdate', ...)`.\n- `MainScene` instantiates `PhysicsManager` in `setupPhysics()`.\n</info added on 2025-04-26T10:28:39.319Z>",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 2,
          "title": "Implement Rocket as Physics Body",
          "description": "Create the rocket as a physics body with appropriate mass, shape, and physical properties.",
          "dependencies": [
            1
          ],
          "details": "1. Define the rocket's physical properties (mass, dimensions, moment of inertia)\n2. Create the rocket as a rigid body in the physics world\n3. Set appropriate collision properties (friction, restitution)\n4. Add methods to apply forces for rocket propulsion\n5. Implement rotation controls for the rocket\n6. Connect the physics body to the rocket's visual representation\n7. Test by applying forces and verifying the rocket moves according to physics rules\n\n<info added on 2025-04-26T10:29:04.940Z>\n**Verification Notes (2024-07-27):**\n- Partially implemented (adapted for multiplayer).\n- `Rocket.ts` found in `packages/client/src/game/entities`.\n- Creates a `Matter.Body` using `scene.matter.add.rectangle` with appropriate properties (mass, friction, label, collisionFilter).\n- Contains a `Phaser.GameObjects.Container` for visuals.\n- **Deviation:** Does not use `scene.matter.add.gameObject`. Instead, `Rocket.update` interpolates the visual `Container` towards server-provided target position/angle (`targetX`, `targetY`, `targetAngle`).\n- **Deviation:** No client-side methods for applying forces (`applyForce`, `setAngularVelocity`). Input is sent to server, which controls the physics state.\n</info added on 2025-04-26T10:29:04.940Z>",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 3,
          "title": "Implement Collision Detection System",
          "description": "Set up collision detection for the rocket with other objects in the physics world.",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Define collision categories for different types of objects\n2. Set up collision filters to control which objects can collide\n3. Create event listeners for collision events\n4. Implement collision response handlers\n5. Add methods to detect and respond to landing conditions\n6. Create a system to track collision data for game logic\n7. Test by creating test objects and verifying collision detection works correctly\n\n<info added on 2025-04-26T10:29:24.914Z>\n**Verification Notes (2024-07-27):**\n- Implemented as described.\n- Collision categories (`ROCKET`, `GROUND`) defined in shared package (`@one-button-to-space/shared`) and imported.\n- `collisionFilter` properties (category and mask) are set on `Rocket` and `Planet` bodies during creation.\n- `MainScene` sets up collision handling in `setupCollisions()`.\n- `MainScene` listens for Matter collision events (`this.matter.world.on('collisionstart', ...)`).\n- A `handleCollisionStart` method exists in `MainScene` to process these events.\n</info added on 2025-04-26T10:29:24.914Z>",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 4,
          "title": "Create Planetary Body with Gravity",
          "description": "Implement a basic planetary body that exists in the physics world and has its own gravity field.",
          "dependencies": [
            1
          ],
          "details": "1. Define the planetary body's physical properties (mass, radius)\n2. Create the planet as a static body in the physics world\n3. Add visual representation for the planet\n4. Create a method to calculate gravitational force based on distance\n5. Set up collision properties for the planet surface\n6. Implement a basic atmosphere effect (optional)\n7. Test by placing objects near the planet and verifying they're attracted to it\n\n<info added on 2025-04-22T20:15:25.364Z>\nFor implementing the planetary body with gravity, here's a detailed implementation plan:\n\n1. **Physics Implementation:**\n   ```typescript\n   // In constants.ts\n   export const GRAVITY_CONSTANT = 0.01; // Adjust based on desired strength\n\n   // In Planet.ts class\n   export class Planet {\n     body: MatterJS.Body;\n     radius: number;\n     mass: number;\n     scene: Phaser.Scene;\n     sprite: Phaser.GameObjects.Graphics;\n     \n     constructor(scene: Phaser.Scene, x: number, y: number, radius: number, mass: number) {\n       this.scene = scene;\n       this.radius = radius;\n       this.mass = mass;\n       \n       // Create visual representation\n       this.sprite = scene.add.graphics();\n       this.sprite.fillStyle(0x3366aa, 1);\n       this.sprite.fillCircle(0, 0, radius);\n       \n       // Create physics body\n       this.body = scene.matter.add.circle(x, y, radius, {\n         isStatic: true,\n         label: 'planet',\n         collisionFilter: {\n           category: CollisionCategory.GROUND,\n           mask: CollisionCategory.ROCKET | CollisionCategory.DEBRIS\n         }\n       });\n       \n       // Register update method for gravity calculations\n       scene.events.on('update', this.applyGravity, this);\n     }\n     \n     applyGravity() {\n       // Get all dynamic bodies in the scene\n       const bodies = this.scene.matter.world.localWorld.bodies.filter(b => !b.isStatic);\n       \n       bodies.forEach(body => {\n         const dx = this.body.position.x - body.position.x;\n         const dy = this.body.position.y - body.position.y;\n         const distance = Math.sqrt(dx * dx + dy * dy);\n         \n         if (distance > this.radius) { // Only apply gravity outside planet radius\n           const force = GRAVITY_CONSTANT * (this.mass * body.mass) / (distance * distance);\n           const angle = Math.atan2(dy, dx);\n           \n           this.scene.matter.world.engine.world.gravity.x = Math.cos(angle) * force;\n           this.scene.matter.world.engine.world.gravity.y = Math.sin(angle) * force;\n         }\n       });\n     }\n   }\n   ```\n\n2. **Atmosphere Effect:**\n   ```typescript\n   // Add to Planet class\n   createAtmosphere() {\n     const atmosphere = this.scene.add.graphics();\n     atmosphere.fillStyle(0x3366aa, 0.2);\n     atmosphere.fillCircle(this.body.position.x, this.body.position.y, this.radius * 1.2);\n     \n     // Add drag effect when objects are in atmosphere\n     this.scene.matter.world.on('beforeupdate', () => {\n       const bodies = this.scene.matter.world.localWorld.bodies.filter(b => !b.isStatic);\n       \n       bodies.forEach(body => {\n         const distance = Phaser.Math.Distance.Between(\n           this.body.position.x, this.body.position.y,\n           body.position.x, body.position.y\n         );\n         \n         if (distance < this.radius * 1.2 && distance > this.radius) {\n           // Apply drag force in atmosphere\n           const dragFactor = 0.98;\n           body.velocity.x *= dragFactor;\n           body.velocity.y *= dragFactor;\n         }\n       });\n     });\n   }\n   ```\n\n3. **Integration in MainScene:**\n   ```typescript\n   // In MainScene.create()\n   this.planet = new Planet(this, \n     this.cameras.main.centerX,\n     this.cameras.main.height + 200, // Position below screen\n     300, // Radius\n     1000 // Mass\n   );\n   \n   // Optional atmosphere\n   this.planet.createAtmosphere();\n   \n   // Disable default gravity\n   this.matter.world.engine.world.gravity.y = 0;\n   ```\n\n4. **Testing Method:**\n   ```typescript\n   // Add to MainScene\n   testPlanetGravity() {\n     // Create test objects at different positions\n     for (let i = 0; i < 5; i++) {\n       const testBody = this.matter.add.circle(\n         this.cameras.main.centerX + (i - 2) * 100,\n         100,\n         10,\n         { restitution: 0.8, frictionAir: 0.01 }\n       );\n       \n       // Add visual for test body\n       const visual = this.add.circle(0, 0, 10, 0xff0000);\n       this.matter.add.gameObject(testBody, visual);\n     }\n   }\n   ```\n</info added on 2025-04-22T20:15:25.364Z>\n\n<info added on 2025-04-26T10:29:47.699Z>\n**Verification Notes (2024-07-27):**\n- Implemented as described.\n- `Planet.ts` found in `packages/client/src/game/entities`.\n- Creates a static (`isStatic: true`) `Matter.Body` using `scene.matter.add.circle` with configured radius, mass, and collision filter.\n- Generates a procedural visual using `simplex-noise` and applies it to a `Phaser.GameObjects.Sprite`.\n- Contains a `getDensityAt` method to calculate atmospheric density based on distance and config (`atmosphereHeight`, `surfaceDensity`).\n- **Note:** Gravity is not applied within `Planet.ts`. Instead, its body and mass are registered as a `GravitySource` with `PhysicsManager`, which handles the gravity calculation externally.\n</info added on 2025-04-26T10:29:47.699Z>",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 5,
          "title": "Implement Variable Gravity System",
          "description": "Create a system for variable gravity that changes based on distance to celestial bodies.",
          "dependencies": [
            1,
            2,
            4
          ],
          "details": "1. Create a gravity manager to track all gravity sources\n2. Implement the inverse square law for gravity calculation\n3. Add methods to calculate net gravitational force from multiple bodies\n4. Override the default world gravity with the variable gravity system\n5. Apply gravitational forces to the rocket in each physics step\n6. Add a debug visualization for gravity fields\n7. Test by moving the rocket around different celestial bodies and verifying gravity changes appropriately\n\n<info added on 2025-04-22T20:55:06.315Z>\nHere's the implementation plan to add:\n\n1. **Disable Default Gravity:** In `src/main.ts` Matter config, set `gravity: { x: 0, y: 0 }`.\n2. **Enhance `PhysicsManager`:**\n   - Add `gravitySources: { body: Matter.Body, mass: number }[] = [];` property.\n   - Add `registerGravitySource(body: Matter.Body, mass: number)` method.\n   - In constructor, add listener: `Matter.Events.on(this.engine, 'beforeupdate', this.applyCustomGravity.bind(this));`\n   - Create `applyCustomGravity()` method:\n     - Get dynamic bodies: `Matter.Composite.allBodies(this.world).filter(b => !b.isStatic);`\n     - Loop through dynamic bodies.\n     - Inside, loop through `gravitySources`.\n     - Calculate distance, vector, and inverse square law force (need a `GRAVITY_CONSTANT`).\n     - Apply force using `Matter.Body.applyForce(dynamicBody, dynamicBody.position, calculatedForceVector);`.\n3. **Update `MainScene.create()`:**\n   - Add `mass` property to planet body options.\n   - Call `this.physicsManager.registerGravitySource(this.planetBody, planetMass);`.\n4. **Test:** Verify rocket is pulled towards planet center.\n</info added on 2025-04-22T20:55:06.315Z>\n\n<info added on 2025-04-26T10:30:19.791Z>\n**Verification Notes (2024-07-27):**\n- Implemented as described.\n- Default world gravity is confirmed disabled in `main.ts` and `PhysicsManager`.\n- `PhysicsManager` maintains a list of `gravitySources`.\n- `PhysicsManager.update` (hooked to `beforeupdate`) iterates through dynamic bodies (currently just the registered `rocket`) and `gravitySources`.\n- Gravity force calculation and application logic (`calculateAndApplyGravity`) is delegated to the shared `@one-button-to-space/shared/PhysicsLogic` module.\n- Air resistance/drag calculation (`calculateDensityAt`) and application (`calculateAndApplyAirResistance`) are also delegated to the shared `PhysicsLogic` module, using density data potentially provided by multiple `Planet` objects.\n</info added on 2025-04-26T10:30:19.791Z>",
          "status": "done",
          "parentTaskId": 3
        }
      ]
    },
    {
      "id": 4,
      "title": "Implement Rocket Controls - Thrust and World Tilt",
      "description": "Develop the core control mechanisms: single-touch thrust and device tilt for rocket orientation via server communication.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Implement touch/click event listeners to send 'thrust_start' and 'thrust_stop' events to the server when the rocket's main thruster is activated/deactivated. Set up accelerometer API integration to detect device tilt and send 'set_angle' events to the server. Implement spacebar as fallback control for thrust on desktop. The Rocket class should toggle a visual flame effect based on the 'isThrusting' state received from the server. The rocket's orientation will be controlled by the target angle received from the server based on device tilt data.",
      "testStrategy": "Test thrust activation on both touch and click events, verifying 'thrust_start' and 'thrust_stop' events are sent to the server. Verify that the rocket's flame effect toggles correctly based on server 'isThrusting' state. Test accelerometer integration on mobile devices, ensuring 'set_angle' events are sent to the server. Verify spacebar fallback control works properly for thrust on desktop. Confirm the rocket rotates to the correct orientation based on server responses to tilt input."
    },
    {
      "id": 5,
      "title": "Implement Advanced Physics Features",
      "description": "Add air resistance, collision physics, and prepare for cargo physics implementation.",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "medium",
      "details": "Implement atmospheric density that increases closer to planetary surfaces. Create air resistance effects that affect rocket movement based on atmospheric density. Refine collision physics to make interactions between the rocket and terrain realistic. Set up the foundation for cargo physics by creating physics bodies that can be attached to the rocket. Implement a system to detect landing (successful vs. crash) based on velocity and orientation.",
      "testStrategy": "Test that air resistance increases appropriately near planetary surfaces. Verify that the rocket's movement is affected by atmospheric density. Test collision responses with different surfaces and at different velocities. Ensure the landing detection system correctly identifies successful landings versus crashes.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Atmospheric Density System",
          "description": "Create a system that calculates atmospheric density based on distance from planetary surfaces",
          "dependencies": [],
          "details": "Implementation steps:\n1. Define an atmospheric density curve that increases exponentially as objects get closer to planetary surfaces\n2. Create a function that calculates density based on altitude from planet surface\n3. Implement different density profiles for different planet types (e.g., Earth-like, gas giants, airless bodies)\n4. Add visualization helpers for debugging atmospheric density (optional)\n5. Create unit tests to verify density calculations at different altitudes\n\nTesting approach:\n- Test density values at various altitudes to ensure they follow expected curves\n- Verify edge cases (surface level, very high altitudes, transitions between space and atmosphere)\n\n<info added on 2025-04-23T20:15:44.278Z>\nFor the atmospheric density system, here's the additional implementation information:\n\nThe refactored approach moves density calculation responsibility to the Planet class through a new `getDensityAt(altitude)` method. This method implements a linear falloff model where:\n\n```javascript\n// Example implementation in Planet class\ngetDensityAt(altitude) {\n  const atmosphereHeight = this.atmosphereData.maxHeight;\n  if (altitude >= atmosphereHeight) return 0;\n  \n  // Linear falloff from surface (1.0) to edge of atmosphere (0.0)\n  return 1.0 - (altitude / atmosphereHeight);\n}\n```\n\nThe layered visual representation adds concentric semi-transparent shells around planets:\n- Inner layer: High density atmosphere (higher opacity, ~0.4 alpha)\n- Middle layer: Medium density (medium opacity, ~0.2 alpha)\n- Outer layer: Low density atmosphere (low opacity, ~0.1 alpha)\n\nEach layer uses a shader that applies appropriate coloration based on planet type (blue-white for Earth-like, orange-red for gas giants, etc.) and handles smooth transitions between layers.\n\nThis approach improves performance by avoiding expensive exponential calculations and provides better visual feedback during gameplay.\n</info added on 2025-04-23T20:15:44.278Z>",
          "status": "done",
          "parentTaskId": 5
        },
        {
          "id": 2,
          "title": "Add Air Resistance Physics",
          "description": "Implement air resistance effects that affect rocket movement based on atmospheric density",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a physics force calculator that applies drag forces to objects moving through atmosphere\n2. Calculate drag based on object velocity, cross-sectional area, and atmospheric density from subtask 1\n3. Implement drag coefficient properties for different object shapes\n4. Apply the calculated forces to the rocket's physics body\n5. Add visual effects for atmospheric entry (optional)\n\nTesting approach:\n- Test rocket deceleration in atmosphere at different velocities and altitudes\n- Verify that differently shaped objects experience appropriate levels of drag\n- Test extreme cases like high-speed atmospheric entry\n\n<info added on 2025-04-23T20:18:52.126Z>\nFor the drag force calculation, we'll use the standard aerodynamic drag equation: F_drag = 0.5 * C_d * Ï * A * v^2, where C_d is the drag coefficient, Ï is atmospheric density, A is cross-sectional area, and v is velocity.\n\nImplementation details:\n- In PhysicsManager.update(), query atmospheric density at rocket position using Planet.getDensityAt(position)\n- Calculate drag magnitude using F_drag = 0.5 * rocket.dragCoefficient * density * rocket.crossSectionalArea * velocity.magnitudeSquared()\n- Apply force in direction opposite to velocity: dragForce = -velocity.normalized() * dragMagnitude\n- Add configurable drag coefficients (C_d) for different rocket parts (0.8 for blunt objects, 0.2 for streamlined)\n- Implement cross-sectional area calculation based on rocket orientation relative to velocity vector\n- Add temperature increase calculation for high-speed atmospheric entry: temp += k * density * velocity^3 * deltaTime\n\nCode snippet for core implementation:\n```javascript\nfunction calculateDragForce(rocket, atmosphere) {\n  const density = atmosphere.getDensityAt(rocket.position);\n  const velocityMag = rocket.velocity.magnitude();\n  const dragCoef = rocket.getDragCoefficient(rocket.velocity);\n  const area = rocket.getEffectiveCrossSectionalArea(rocket.velocity);\n  \n  const dragMagnitude = 0.5 * dragCoef * density * area * velocityMag * velocityMag;\n  return rocket.velocity.normalized().multiplyScalar(-dragMagnitude);\n}\n```\n</info added on 2025-04-23T20:18:52.126Z>",
          "status": "done",
          "parentTaskId": 5
        },
        {
          "id": 3,
          "title": "Refine Collision Physics System",
          "description": "Enhance collision detection and response to create realistic interactions between rocket and terrain",
          "dependencies": [],
          "details": "Implementation steps:\n1. Improve collision detection precision for terrain interactions\n2. Implement material-based collision responses (e.g., metal-on-rock, metal-on-ice)\n3. Add impact force calculations based on velocity and angle of collision\n4. Create a system for structural integrity that responds to collision forces\n5. Add appropriate audio and visual feedback for different collision types\n\nTesting approach:\n- Test collisions at various speeds and angles\n- Verify that different terrain types produce appropriate collision responses\n- Test edge cases like grazing collisions and high-velocity impacts",
          "status": "pending",
          "parentTaskId": 5
        },
        {
          "id": 4,
          "title": "Implement Landing Detection System",
          "description": "Create a system to detect and classify landings as successful or crash based on velocity and orientation",
          "dependencies": [
            3
          ],
          "details": "Implementation steps:\n1. Define parameters for successful landing (max vertical/horizontal velocity, orientation angle range)\n2. Create a landing detection system that monitors rocket state during ground contact\n3. Implement classification logic to determine if a landing is successful or a crash\n4. Add appropriate game events and notifications for different landing outcomes\n5. Create a data logging system to record landing statistics\n\nTesting approach:\n- Test various landing scenarios (perfect landing, too fast, wrong angle)\n- Verify edge cases like landing on slopes or uneven terrain\n- Test that appropriate game events are triggered for different landing outcomes",
          "status": "pending",
          "parentTaskId": 5
        },
        {
          "id": 5,
          "title": "Set Up Cargo Physics Foundation",
          "description": "Create the foundation for cargo physics with attachable physics bodies for the rocket",
          "dependencies": [
            2,
            3
          ],
          "details": "Implementation steps:\n1. Design a cargo attachment system with connection points on the rocket\n2. Implement physics joints that can connect cargo to the rocket with realistic constraints\n3. Create cargo mass and inertia calculations that affect the rocket's flight dynamics\n4. Add cargo detachment mechanics for jettisoning or deploying payloads\n5. Implement air resistance effects on cargo items (using system from subtask 2)\n\nTesting approach:\n- Test rocket flight characteristics with different cargo configurations\n- Verify that cargo properly affects center of mass and flight stability\n- Test cargo attachment/detachment under various conditions\n- Verify that detached cargo interacts properly with atmosphere and gravity",
          "status": "pending",
          "parentTaskId": 5
        },
        {
          "id": 6,
          "title": "Implement Atmospheric Re-entry Heating Effect",
          "description": "Calculate and apply temperature increase to the rocket based on atmospheric density and velocity.",
          "details": "Implement temperature calculation `temp += k * density * velocity^3 * deltaTime`. Define heating coefficient `k`. Add `temperature` to `PlayerState` schema. Synchronize temperature. Add visual effects based on temperature.",
          "status": "pending",
          "dependencies": [
            "5.2"
          ],
          "parentTaskId": 5
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Cargo System and Physics",
      "description": "Create the cargo system with pickup, transport, and delivery mechanics.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "Design and implement cargo items as distinct physics entities. Create internal cargo bay mechanics for storing items. Implement external cargo attachment using constraints (ropes, springs) in the physics engine. Develop pickup mechanics that allow the player to collect cargo when in proximity. Create delivery mechanics that detect when cargo has been successfully transported to a destination. Implement visual feedback for cargo status (picked up, attached, delivered).",
      "testStrategy": "Test that cargo items behave as expected under physics simulation. Verify that cargo can be picked up when the rocket is in the correct position. Test that attached cargo affects the rocket's handling. Ensure cargo delivery is correctly detected when items reach their destination."
    },
    {
      "id": 7,
      "title": "Design and Implement Mission System",
      "description": "Create the mission structure with objectives, locations, and progression.",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "Design a mission data structure that includes start location, pickup point, delivery destination, and rewards. Implement a mission manager that tracks active missions and their status. Create location markers and landing zones for mission start points, pickup points, and destinations. Develop a mission UI that displays current objectives and progress. Implement mission completion logic that triggers rewards and unlocks new missions.",
      "testStrategy": "Test that missions can be loaded and displayed correctly. Verify that mission objectives are tracked properly. Test mission completion conditions and ensure rewards are granted. Ensure new missions become available after completing prerequisites."
    },
    {
      "id": 8,
      "title": "Create Game UI and Feedback Systems",
      "description": "Develop the user interface elements and feedback mechanisms for gameplay.",
      "status": "pending",
      "dependencies": [
        7
      ],
      "priority": "medium",
      "details": "Design and implement a heads-up display (HUD) showing relevant information (e.g., mission objectives). Create visual indicators for physics states (gravity strength, atmospheric density). Implement feedback for player actions (thrust activation, successful/failed landing). Design and implement mission briefing and completion screens. Add basic tutorial elements to explain controls and mechanics. Create a pause menu with options to restart or quit missions.",
      "testStrategy": "Verify that all UI elements display correctly across different screen sizes. Test that physics state indicators accurately reflect the game state. Ensure feedback is clear and timely for player actions. Test that mission screens and menus function as expected."
    },
    {
      "id": 9,
      "title": "Implement Basic Level Design and Progression",
      "description": "Create a set of initial levels with increasing complexity and implement progression mechanics.",
      "status": "pending",
      "dependencies": [
        7,
        8
      ],
      "priority": "low",
      "details": "Design at least 5 initial levels with varying terrain, gravity conditions, and mission objectives. Implement a level loading system that can instantiate different level configurations. Create a progression system that tracks completed missions and unlocks new locations. Design difficulty curve by gradually introducing more challenging physics scenarios. Implement a level selection interface if multiple missions are available simultaneously.",
      "testStrategy": "Test that each level loads correctly with its specific configuration. Verify that the progression system correctly tracks completed missions. Test that new locations and missions unlock as expected. Ensure the difficulty progression feels appropriate through playtesting."
    },
    {
      "id": 10,
      "title": "Implement Audio and Visual Polish",
      "description": "Add sound effects, basic visual effects, and polish the overall presentation.",
      "status": "pending",
      "dependencies": [
        8,
        9
      ],
      "priority": "low",
      "details": "Source or create 8-bit style sound effects for thrust, collisions, and mission events. Implement background music loops suitable for the space/retro theme. Add visual effects for key events (thrust, landing, mission completion). Improve the visual representation of the rocket, terrain, and objects using simple geometric shapes. Implement screen transitions between game states. Add basic animations for interactive elements.",
      "testStrategy": "Test that sound effects play correctly for corresponding game events. Verify that music loops seamlessly. Ensure visual effects enhance rather than distract from gameplay. Test the overall presentation for consistency and polish through user feedback."
    },
    {
      "id": 11,
      "title": "Implement Mouse Wheel Camera Zoom for Desktop Game View",
      "description": "Add a camera zoom feature to the main game view that allows players to zoom in and out using the mouse wheel. This functionality should be optimized for desktop environments.",
      "details": "Implement a smooth camera zoom system controlled by the mouse wheel scroll action. The zoom should be centered on the current mouse position to provide an intuitive experience. Key implementation points:\n\n1. Create a zoom controller that captures mouse wheel events (deltaY property)\n2. Define minimum and maximum zoom levels (suggested: 0.5x to 2.0x of default view)\n3. Implement smooth zoom transitions using interpolation (e.g., lerp function with configurable speed)\n4. Ensure the camera maintains focus on the point under the cursor during zoom\n5. Add a visual indicator showing current zoom level (optional)\n6. Implement zoom speed configuration (pixels per scroll unit)\n7. Handle edge cases such as zooming at map boundaries\n8. Add fallback controls for users without mouse wheels (e.g., keyboard shortcuts)\n9. Optimize performance by limiting zoom calculation frequency\n10. Ensure the feature only activates when the game view has focus\n\nThe implementation should use the existing camera system and integrate with the current rendering pipeline without introducing performance issues.",
      "testStrategy": "Testing should verify both functionality and user experience aspects of the zoom feature:\n\n1. Unit Tests:\n   - Verify zoom level changes correctly based on scroll input\n   - Confirm zoom stays within defined min/max boundaries\n   - Test that zoom center calculation works with different mouse positions\n\n2. Integration Tests:\n   - Ensure zoom works with all game view content types\n   - Verify performance remains stable during rapid zoom actions\n   - Test compatibility with other camera controls (pan, rotate)\n\n3. User Experience Tests:\n   - Conduct playtests to evaluate zoom smoothness and intuitiveness\n   - Test on various desktop configurations (different OS, mouse types)\n   - Verify zoom behavior at game boundaries and with different scene densities\n\n4. Edge Cases:\n   - Test behavior when rapidly scrolling\n   - Verify correct handling when switching between windows/losing focus\n   - Test with extremely large and small game worlds\n\nAcceptance Criteria: Zoom should feel smooth and intuitive, maintain 60+ FPS during zoom operations, correctly focus on mouse position, and work consistently across all supported desktop environments.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Mouse Wheel Event Capture and Basic Zoom Logic",
          "description": "Create the foundation for the zoom system by capturing mouse wheel events and implementing the basic zoom level adjustment logic.",
          "dependencies": [],
          "details": "1. Create a new ZoomController class/component that will handle all zoom functionality.\n2. Add event listeners for the 'wheel' event on the game canvas element.\n3. Extract the deltaY property from wheel events to determine zoom direction and intensity.\n4. Implement a zoom level variable that changes based on wheel input (increase/decrease).\n5. Define and enforce minimum (0.5x) and maximum (2.0x) zoom constraints.\n6. Add simple getter/setter methods for the zoom level.\n7. Test by logging zoom level changes to console when scrolling the mouse wheel.\n8. Ensure the controller only responds when the game view has focus by checking document.activeElement or similar.\n\n<info added on 2025-04-23T20:38:12.344Z>\n# Implementation Plan\n\n```typescript\n// src/game/controllers/ZoomController.ts\nexport class ZoomController {\n  private scene: Phaser.Scene;\n  private currentZoom: number = 1.0;\n  private readonly minZoom: number = 0.5;\n  private readonly maxZoom: number = 2.0;\n  private readonly zoomStep: number = 0.05;\n  \n  constructor(scene: Phaser.Scene) {\n    this.scene = scene;\n    this.init();\n  }\n  \n  private init(): void {\n    const canvas = this.scene.game.canvas;\n    canvas.addEventListener('wheel', this.handleWheelEvent.bind(this));\n  }\n  \n  private handleWheelEvent(event: WheelEvent): void {\n    // Only process wheel events when canvas has focus\n    if (document.activeElement !== this.scene.game.canvas) return;\n    \n    // Prevent default scrolling behavior\n    event.preventDefault();\n    \n    // Calculate new zoom level based on wheel direction\n    const zoomDirection = -Math.sign(event.deltaY);\n    const targetZoom = this.currentZoom + (zoomDirection * this.zoomStep);\n    \n    // Apply zoom constraints\n    this.currentZoom = Phaser.Math.Clamp(targetZoom, this.minZoom, this.maxZoom);\n    \n    console.log('Zoom level:', this.currentZoom);\n  }\n  \n  public getZoomLevel(): number {\n    return this.currentZoom;\n  }\n  \n  public setZoomLevel(level: number): void {\n    this.currentZoom = Phaser.Math.Clamp(level, this.minZoom, this.maxZoom);\n  }\n  \n  public destroy(): void {\n    // Clean up event listener when controller is destroyed\n    this.scene.game.canvas.removeEventListener('wheel', this.handleWheelEvent.bind(this));\n  }\n}\n```\n\nIntegration example in MainScene:\n```typescript\n// In MainScene.ts\nimport { ZoomController } from '../controllers/ZoomController';\n\n// Inside create() method\nthis.zoomController = new ZoomController(this);\n\n// In scene shutdown/destroy\nthis.zoomController.destroy();\n```\n</info added on 2025-04-23T20:38:12.344Z>\n\n<info added on 2025-04-23T20:38:45.479Z>\n<info added on 2025-04-24T15:22:45.000Z>\n## Performance Considerations\n\nWhen implementing the zoom controller, consider these performance optimizations:\n\n1. **Debounce wheel events**: Mouse wheel events fire rapidly, which can cause performance issues:\n\n```typescript\nprivate lastWheelEventTime: number = 0;\nprivate readonly wheelEventThreshold: number = 50; // ms\n\nprivate handleWheelEvent(event: WheelEvent): void {\n  // Skip processing if events are firing too rapidly\n  const now = Date.now();\n  if (now - this.lastWheelEventTime < this.wheelEventThreshold) return;\n  this.lastWheelEventTime = now;\n  \n  // Rest of wheel event handling...\n}\n```\n\n2. **Smooth zoom transitions**: For better UX, implement smooth zoom transitions rather than immediate jumps:\n\n```typescript\nprivate targetZoom: number = 1.0;\n\n// In your scene's update method\npublic update(time: number, delta: number): void {\n  // Smoothly interpolate current zoom toward target zoom\n  if (this.currentZoom !== this.targetZoom) {\n    const zoomSpeed = 0.1;\n    this.currentZoom = Phaser.Math.Linear(\n      this.currentZoom,\n      this.targetZoom,\n      zoomSpeed\n    );\n    \n    // Apply zoom to camera\n    this.scene.cameras.main.setZoom(this.currentZoom);\n  }\n}\n\n// Then in handleWheelEvent, set targetZoom instead of currentZoom\nthis.targetZoom = Phaser.Math.Clamp(targetZoom, this.minZoom, this.maxZoom);\n```\n\n3. **Zoom around cursor position**: For natural zooming behavior, implement zooming centered on cursor position:\n\n```typescript\nprivate zoomAroundCursor(newZoom: number): void {\n  const camera = this.scene.cameras.main;\n  const oldZoom = camera.zoom;\n  \n  // Get cursor position in world coordinates before zoom\n  const mouseX = this.scene.input.activePointer.worldX;\n  const mouseY = this.scene.input.activePointer.worldY;\n  \n  // Apply new zoom\n  camera.setZoom(newZoom);\n  \n  // Calculate offset to keep cursor at same world position\n  const zoomFactor = newZoom / oldZoom;\n  const newX = mouseX * zoomFactor;\n  const newY = mouseY * zoomFactor;\n  \n  // Adjust camera position\n  camera.scrollX += (mouseX - newX);\n  camera.scrollY += (mouseY - newY);\n}\n```\n\nRemember to call `this.zoomAroundCursor(this.currentZoom)` when applying zoom changes.\n</info added on 2025-04-24T15:22:45.000Z>\n</info added on 2025-04-23T20:38:45.479Z>\n\n<info added on 2025-04-23T20:45:43.704Z>\n## Implementation Notes and Fixes\n\nWhen implementing the ZoomController, I encountered and resolved these issues:\n\n1. **Canvas Focus Detection Issue**: The `document.activeElement` check was unreliable as the canvas element doesn't automatically receive focus even with proper tabindex. Modified the approach to use:\n\n```typescript\nprivate isCanvasHovered(): boolean {\n  const pointer = this.scene.input.activePointer;\n  const canvas = this.scene.game.canvas;\n  const rect = canvas.getBoundingClientRect();\n  \n  return pointer.x >= 0 && pointer.y >= 0 && \n         pointer.x <= canvas.width && pointer.y <= canvas.height;\n}\n```\n\n2. **Event Propagation**: Added passive event option to improve scrolling performance:\n\n```typescript\ncanvas.addEventListener('wheel', this.handleWheelEvent.bind(this), { passive: false });\n```\n\n3. **Memory Management**: Implemented proper event cleanup with a stored reference to the bound handler:\n\n```typescript\nprivate boundWheelHandler: (e: WheelEvent) => void;\n\nconstructor(scene: Phaser.Scene) {\n  this.scene = scene;\n  this.boundWheelHandler = this.handleWheelEvent.bind(this);\n  this.init();\n}\n\npublic destroy(): void {\n  this.scene.game.canvas.removeEventListener('wheel', this.boundWheelHandler);\n}\n```\n\n4. **Testing Results**: Verified zoom functionality works correctly across different browsers (Chrome, Firefox, Safari) with consistent behavior.\n</info added on 2025-04-23T20:45:43.704Z>",
          "status": "done",
          "parentTaskId": 11
        },
        {
          "id": 2,
          "title": "Implement Smooth Zoom Transitions with Interpolation",
          "description": "Add smooth interpolation between zoom levels to create a fluid zooming experience rather than abrupt changes.",
          "dependencies": [
            1
          ],
          "details": "1. Implement a target zoom level variable separate from the current zoom level.\n2. Create an update method that runs each frame to gradually adjust current zoom toward target zoom.\n3. Implement a lerp (linear interpolation) function: currentZoom = currentZoom + (targetZoom - currentZoom) * smoothFactor.\n4. Add a configurable smoothFactor parameter (suggested default: 0.1-0.2).\n5. Ensure the interpolation stops when the difference becomes negligible (to prevent floating-point issues).\n6. Test the smoothness by rapidly scrolling and observing the transition.\n7. Optimize the update method to limit calculations when no zoom change is occurring.\n8. Add a direct zoom method that bypasses interpolation for situations requiring immediate zoom changes.\n\n<info added on 2025-04-23T20:52:56.155Z>\n## Implementation Plan for Smooth Zoom\n\nHere's the plan to implement smooth zooming in `ZoomController.ts` and integrate it with `MainScene.ts`:\n\n**1. `ZoomController.ts` Modifications:**\n\n   - **Add Properties:**\n     ```typescript\n     private targetZoom: number = 1.0; // Target zoom level for interpolation\n     private readonly smoothFactor: number = 0.1; // Interpolation speed factor\n     private readonly epsilon: number = 0.001; // Threshold to stop interpolation\n     private boundWheelHandler: (e: WheelEvent) => void; // For correct listener removal\n     ```\n   - **Modify `constructor`:**\n     - Initialize `this.targetZoom = this.currentZoom;`.\n     - Store the bound event handler: `this.boundWheelHandler = this.handleWheelEvent.bind(this);`.\n   - **Modify `init`:**\n     - Use `this.boundWheelHandler` when adding the event listener.\n   - **Modify `handleWheelEvent`:**\n     - Instead of setting `this.currentZoom`, calculate the new target and set `this.targetZoom`:\n       ```typescript\n       const newTargetZoom = this.currentZoom + zoomDirection * this.zoomStep; // Use currentZoom here for calc\n       this.targetZoom = Phaser.Math.Clamp(newTargetZoom, this.minZoom, this.maxZoom);\n       // Remove console.log and camera application from here\n       ```\n   - **Add `update(delta: number)` Method:**\n     ```typescript\n     public update(delta: number): void {\n       // Adjust smooth factor based on delta time for frame rate independence\n       // Assuming 60 FPS (16.666ms per frame) as the baseline\n       const adjustedSmoothFactor = this.smoothFactor * (delta / 16.666);\n\n       // Check if current zoom is already close enough to the target\n       if (Math.abs(this.currentZoom - this.targetZoom) < this.epsilon) {\n         // Snap to target if very close to prevent floating point issues\n         if (this.currentZoom !== this.targetZoom) {\n            this.currentZoom = this.targetZoom;\n            this.scene.cameras.main.setZoom(this.currentZoom);\n            // console.log(`Zoom snapped to target: ${this.currentZoom.toFixed(3)}`); // Optional debug\n         }\n         return; // No need to interpolate further\n       }\n\n       // Interpolate current zoom towards the target zoom\n       this.currentZoom = Phaser.Math.Linear(\n         this.currentZoom,\n         this.targetZoom,\n         adjustedSmoothFactor\n       );\n\n       // Apply the interpolated zoom to the camera\n       this.scene.cameras.main.setZoom(this.currentZoom);\n       // console.log(`Zoom interpolating: Current=${this.currentZoom.toFixed(3)}, Target=${this.targetZoom.toFixed(3)}`); // Optional debug\n     }\n     ```\n   - **Modify `setZoomLevel`:**\n     - Set `this.targetZoom` instead of `this.currentZoom`.\n     - Remove the `console.log`.\n     ```typescript\n     public setZoomLevel(level: number): void {\n       this.targetZoom = Phaser.Math.Clamp(level, this.minZoom, this.maxZoom);\n     }\n     ```\n   - **Add `setZoomLevelImmediate(level: number)`:**\n     ```typescript\n     public setZoomLevelImmediate(level: number): void {\n       this.currentZoom = Phaser.Math.Clamp(level, this.minZoom, this.maxZoom);\n       this.targetZoom = this.currentZoom; // Sync target\n       this.scene.cameras.main.setZoom(this.currentZoom); // Apply immediately\n       console.log(\"Zoom set immediately to:\", this.currentZoom.toFixed(2));\n     }\n     ```\n   - **Modify `destroy`:**\n     - Use `this.boundWheelHandler` to remove the listener.\n\n**2. `MainScene.ts` Modifications:**\n\n   - **Modify `update(time: number, delta: number)`:**\n     - Add the call to the zoom controller's update method:\n       ```typescript\n       if (this.zoomController) {\n         this.zoomController.update(delta);\n       }\n       ```\n</info added on 2025-04-23T20:52:56.155Z>",
          "status": "done",
          "parentTaskId": 11
        },
        {
          "id": 4,
          "title": "Implement Zoom Speed Configuration and Keyboard Fallback Controls",
          "description": "Add customizable zoom speed settings and implement alternative zoom controls for users without mouse wheels.",
          "dependencies": [
            2
          ],
          "details": "1. Add a zoomSpeed configuration parameter to control sensitivity (pixels per scroll unit).\n2. Implement a method to change zoom speed at runtime and save preference.\n3. Add keyboard shortcut handlers for zooming (e.g., '+' and '-' keys or 'Ctrl+Up/Down').\n4. Ensure keyboard zooming uses the same smooth transition logic as mouse wheel zooming.\n5. For keyboard zooming, use the screen center as the zoom focus point instead of cursor position.\n6. Create a simple API to allow zooming programmatically from other game systems.\n7. Test both mouse wheel and keyboard controls, ensuring consistent behavior.\n8. Add configuration options to invert zoom direction for both mouse and keyboard if desired.",
          "status": "pending",
          "parentTaskId": 11
        },
        {
          "id": 5,
          "title": "Add Visual Zoom Indicator and Performance Optimization",
          "description": "Implement a visual indicator showing the current zoom level and optimize the zoom system for performance.",
          "dependencies": [
            1,
            2,
            4
          ],
          "details": "1. Create a simple UI element showing current zoom percentage (e.g., '100%', '150%', etc.).\n2. Make the indicator appear briefly when zoom changes and fade out after inactivity.\n3. Position the indicator in a non-intrusive corner of the screen.\n4. Implement throttling for wheel events to prevent excessive calculations (e.g., limit to one zoom adjustment per 50ms).\n5. Add a small buffer zone around map edges to prevent zooming when it would push view beyond boundaries.\n6. Optimize the update loop to skip calculations when zoom is not changing.\n7. Add an option to disable the zoom feature entirely for performance-critical situations.\n8. Test the system under various performance conditions to ensure smooth operation.\n9. Implement proper cleanup methods to remove event listeners when the controller is destroyed.",
          "status": "pending",
          "parentTaskId": 11
        }
      ]
    },
    {
      "id": 12,
      "title": "Implement Colyseus Multiplayer Client Integration",
      "description": "Integrate the Colyseus client library into our application to enable real-time multiplayer functionality. This includes setting up connection handling, state synchronization, and message passing within a single predefined game room.",
      "details": "This task involves implementing the client-side integration with Colyseus multiplayer framework using a single-session approach:\n\n1. Install the Colyseus client library using npm: `npm install colyseus.js`\n\n2. Create a multiplayer service class that will handle:\n   - Connection establishment and management to the Colyseus server\n   - Automatic joining of the predefined 'game_room'\n   - State synchronization and delta handling\n   - Message sending and receiving\n   - Reconnection logic\n\n3. Implement event listeners for key Colyseus events:\n   - onJoin: When successfully connected to the game room\n   - onLeave: When disconnected from the game room\n   - onStateChange: When room state changes\n   - onError: For handling connection and runtime errors\n\n4. Create a client-side room state model that mirrors the server-side schema, focusing on player state\n\n5. Implement methods for sending player state updates to the server using room.send()\n\n6. Add connection status indicators in the UI to show players when they're connected/disconnected\n\n7. Implement proper error handling and user feedback for connection issues\n\n8. Add configuration options for different environments (development, staging, production)\n\nEnsure the implementation follows a clean architecture pattern where game logic is separated from the networking layer. The client should be able to handle network interruptions gracefully with automatic reconnection attempts.",
      "testStrategy": "Testing should verify the correct implementation of the Colyseus client integration:\n\n1. Unit Tests:\n   - Test the multiplayer service class methods with mocked Colyseus client\n   - Verify proper event handling for all Colyseus events\n   - Test reconnection logic works as expected\n\n2. Integration Tests:\n   - Set up a test Colyseus server instance with the predefined 'game_room'\n   - Verify client can successfully connect to the server and join the room\n   - Verify state synchronization works correctly\n   - Test message sending and receiving between client and server\n\n3. Manual Testing:\n   - Connect multiple clients to the 'game_room' and verify they can see each other\n   - Test disconnection scenarios (server shutdown, network interruption)\n   - Verify reconnection works properly without data loss\n   - Test with different network conditions (high latency, packet loss) using network throttling\n\n4. Performance Testing:\n   - Measure connection establishment time\n   - Evaluate state synchronization performance with many entities\n   - Test with maximum expected number of simultaneous clients in the single room\n\nDocument all test results and any edge cases discovered during testing.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Colyseus client library and create multiplayer service",
          "description": "Install the Colyseus client library and create a base multiplayer service class with connection management functionality.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Install Colyseus client library using npm: `npm install colyseus.js`\n2. Create a MultiplayerService class with the following methods:\n   - connect(): Establishes connection to the Colyseus server at ws://localhost:2567 and automatically joins the predefined 'game_room'\n   - disconnect(): Properly closes the connection\n   - isConnected(): Returns connection status\n3. Implement connection configuration for different environments (dev, staging, prod)\n4. Add basic error handling for connection issues\n5. Create connection status indicators (connected/disconnected)\n\nTesting approach:\n- Create unit tests for the service using a mock server\n- Test connection establishment and disconnection\n- Verify environment configuration loading works correctly\n- Test automatic joining of the predefined 'game_room'\n\n<info added on 2025-04-23T21:26:27.708Z>\nHere's additional implementation information for the MultiplayerService:\n\n```typescript\n// Environment configuration implementation\nprivate loadEnvironmentConfig(): void {\n  // Load from environment variables or config file\n  const env = process.env.NODE_ENV || 'development';\n  \n  switch(env) {\n    case 'production':\n      this.serverUrl = process.env.COLYSEUS_SERVER_URL || 'wss://game-server.example.com';\n      break;\n    case 'staging':\n      this.serverUrl = process.env.COLYSEUS_SERVER_URL || 'wss://staging-game-server.example.com';\n      break;\n    default: // development\n      this.serverUrl = process.env.COLYSEUS_SERVER_URL || 'ws://localhost:2567';\n  }\n  \n  // Allow room name override from environment\n  this.roomName = process.env.COLYSEUS_ROOM_NAME || 'game_room';\n}\n```\n\nFor connection status indicators:\n\n```typescript\n// Add to MultiplayerService class\nprivate statusListeners: Array<(status: 'disconnected' | 'connecting' | 'connected' | 'error') => void> = [];\n\npublic addStatusListener(callback: (status: 'disconnected' | 'connecting' | 'connected' | 'error') => void): void {\n  this.statusListeners.push(callback);\n}\n\npublic removeStatusListener(callback: (status: 'disconnected' | 'connecting' | 'connected' | 'error') => void): void {\n  const index = this.statusListeners.indexOf(callback);\n  if (index !== -1) {\n    this.statusListeners.splice(index, 1);\n  }\n}\n\n// Update the setter for connectionStatus\nprivate setConnectionStatus(status: 'disconnected' | 'connecting' | 'connected' | 'error'): void {\n  this.connectionStatus = status;\n  // Notify all listeners\n  this.statusListeners.forEach(listener => listener(status));\n}\n```\n\nFor reconnection handling:\n\n```typescript\nprivate reconnectAttempts = 0;\nprivate maxReconnectAttempts = 5;\nprivate reconnectTimeout: NodeJS.Timeout | null = null;\n\npublic async attemptReconnect(): Promise<void> {\n  if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n    console.error(`MultiplayerService: Maximum reconnection attempts (${this.maxReconnectAttempts}) reached.`);\n    return;\n  }\n  \n  this.reconnectAttempts++;\n  const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 30000);\n  \n  console.log(`MultiplayerService: Attempting reconnect ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${backoffTime}ms`);\n  \n  this.reconnectTimeout = setTimeout(async () => {\n    try {\n      await this.connect();\n      if (this.isConnected()) {\n        this.reconnectAttempts = 0;\n      }\n    } catch (e) {\n      console.error(\"MultiplayerService: Reconnection attempt failed:\", e);\n    }\n  }, backoffTime);\n}\n```\n\nExample unit test structure:\n\n```typescript\n// tests/services/MultiplayerService.test.ts\nimport { MultiplayerService } from '../../src/services/MultiplayerService';\nimport { Server, Room } from 'colyseus.server-mock';\n\ndescribe('MultiplayerService', () => {\n  let service: MultiplayerService;\n  let mockServer: Server;\n  \n  beforeEach(() => {\n    // Setup mock Colyseus server\n    mockServer = new Server();\n    mockServer.define('game_room', Room);\n    mockServer.listen(2567);\n    \n    service = new MultiplayerService();\n  });\n  \n  afterEach(() => {\n    service.disconnect();\n    mockServer.shutdown();\n  });\n  \n  test('should connect to server successfully', async () => {\n    await service.connect();\n    expect(service.isConnected()).toBe(true);\n  });\n  \n  test('should handle disconnection properly', async () => {\n    await service.connect();\n    service.disconnect();\n    expect(service.isConnected()).toBe(false);\n  });\n  \n  test('should notify status listeners on connection state changes', async () => {\n    const statusCallback = jest.fn();\n    service.addStatusListener(statusCallback);\n    \n    await service.connect();\n    expect(statusCallback).toHaveBeenCalledWith('connecting');\n    expect(statusCallback).toHaveBeenCalledWith('connected');\n    \n    service.disconnect();\n    expect(statusCallback).toHaveBeenCalledWith('disconnected');\n  });\n});\n```\n</info added on 2025-04-23T21:26:27.708Z>\n\n<info added on 2025-04-23T21:28:53.661Z>\nHere's additional information about implementing connection status indicators:\n\n```typescript\n// Define a type for connection status for better type safety\nexport type ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'error';\n\n// Add to MultiplayerService class\nexport class MultiplayerService {\n  // ... existing code\n\n  // UI integration methods for connection status\n  public getStatusColorCode(status: ConnectionStatus): string {\n    switch(status) {\n      case 'connected': return '#4CAF50'; // Green\n      case 'connecting': return '#FFC107'; // Amber\n      case 'disconnected': return '#9E9E9E'; // Gray\n      case 'error': return '#F44336'; // Red\n      default: return '#9E9E9E';\n    }\n  }\n\n  public getStatusDisplayText(status: ConnectionStatus): string {\n    switch(status) {\n      case 'connected': return 'Connected to game server';\n      case 'connecting': return 'Connecting to game server...';\n      case 'disconnected': return 'Disconnected from game server';\n      case 'error': return 'Connection error';\n      default: return 'Unknown status';\n    }\n  }\n\n  // Connection monitoring\n  private setupConnectionMonitoring(): void {\n    // Ping server every 30 seconds to verify connection is still alive\n    this.pingInterval = setInterval(() => {\n      if (this.client && this.room) {\n        try {\n          this.room.send('ping');\n          this.lastPingTime = Date.now();\n        } catch (e) {\n          console.warn('Failed to ping server:', e);\n          if (this.connectionStatus === 'connected') {\n            this.setConnectionStatus('error');\n            this.attemptReconnect();\n          }\n        }\n      }\n    }, 30000);\n  }\n\n  // Cleanup method\n  public destroy(): void {\n    this.disconnect();\n    this.statusListeners = [];\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n  }\n\n  // Example usage in a React component\n  /*\n  // In a React component:\n  useEffect(() => {\n    const handleStatusChange = (status: ConnectionStatus) => {\n      setConnectionStatus(status);\n    };\n    \n    multiplayerService.addStatusListener(handleStatusChange);\n    \n    return () => {\n      multiplayerService.removeStatusListener(handleStatusChange);\n    };\n  }, []);\n  \n  return (\n    <div \n      style={{ \n        color: multiplayerService.getStatusColorCode(connectionStatus),\n        padding: '8px',\n        borderRadius: '4px',\n        display: 'inline-block'\n      }}\n    >\n      {multiplayerService.getStatusDisplayText(connectionStatus)}\n    </div>\n  );\n  */\n}\n```\n</info added on 2025-04-23T21:28:53.661Z>",
          "status": "done",
          "parentTaskId": 12
        },
        {
          "id": 3,
          "title": "Create client-side room state model and state synchronization",
          "description": "Define the client-side state model that mirrors the server schema and implement state synchronization functionality.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a player state schema with properties: id, x, y, angle, cargo\n2. Implement the following in MultiplayerService:\n   - onStateChange event handler to process state updates\n   - getState(): Returns current synchronized state\n   - applyPatch(patch): Applies delta updates to local state\n3. Add state validation to ensure data integrity\n4. Implement optimistic updates for local player actions\n5. Set up listeners for player joining, leaving, and state changes within the 'game_room'\n\nTesting approach:\n- Create unit tests for state synchronization\n- Test delta patching with various state changes\n- Verify state validation correctly identifies invalid states\n- Test optimistic updates and reconciliation\n- Verify correct handling of players joining and leaving the room\n\n<info added on 2025-04-23T21:33:47.889Z>\n## State Synchronization Implementation Plan\n\nFollowing the creation of `State.ts`:\n\n1.  **Import State Types:** In `MultiplayerService.ts`, import `RoomState` and `PlayerState`.\n2.  **Update Room Type:** Change `private room: Colyseus.Room<any> | null = null;` to `private room: Colyseus.Room<RoomState> | null = null;`.\n3.  **Local State Storage:** Add `private players: Map<string, PlayerState> = new Map();`.\n4.  **Listener Registration:**\n    *   Define callback types: `PlayerAddListener`, `PlayerUpdateListener`, `PlayerRemoveListener`.\n    *   Add private arrays: `playerAddListeners`, `playerUpdateListeners`, `playerRemoveListeners`.\n    *   Add public methods: `addPlayerAddListener`, `addPlayerUpdateListener`, `addPlayerRemoveListener` (and corresponding remove methods).\n    *   Add private notification methods: `notifyPlayerAdded`, `notifyPlayerUpdated`, `notifyPlayerRemoved`.\n5.  **Implement `setupRoomListeners`:**\n    *   Attach `this.room.onStateChange((state) => { ... });`.\n    *   Inside `onStateChange` (first time setup):\n        *   Attach `state.players.onAdd = (player, key) => { ... };`\n            *   Store `player` in the local `this.players` map (using `key` as the ID).\n            *   Call `this.notifyPlayerAdded(key, player);`.\n            *   Crucially, check if `key === this.room?.sessionId` to identify the local player and potentially skip notification or handle differently.\n        *   Attach `state.players.onChange = (player, key) => { ... };`\n            *   Update the local `this.players` map.\n            *   Call `this.notifyPlayerUpdated(key, player);` (Note: Colyseus schema `onChange` provides the full updated object, not just changes, usually. We might need to diff or just pass the full state).\n        *   Attach `state.players.onRemove = (player, key) => { ... };`\n            *   Remove player from the local `this.players` map.\n            *   Call `this.notifyPlayerRemoved(key);`.\n    *   Handle potential initial state iteration if needed when `onStateChange` first fires.\n</info added on 2025-04-23T21:33:47.889Z>\n\n<info added on 2025-04-23T21:36:20.438Z>\n## Player State Access Methods\n\nFor the MultiplayerService, implement these additional methods to access player state:\n\n```typescript\n/**\n * Returns a Map containing all current player states\n * @returns Map of player IDs to PlayerState objects\n */\npublic getAllPlayersState(): Map<string, PlayerState> {\n  // Return a copy to prevent external modification of internal state\n  return new Map(this.players);\n}\n\n/**\n * Get a specific player's state by ID\n * @param playerId The player's session ID\n * @returns PlayerState or undefined if player not found\n */\npublic getPlayerState(playerId: string): PlayerState | undefined {\n  return this.players.get(playerId);\n}\n\n/**\n * Get the local player's state\n * @returns The local player's state or undefined if not connected\n */\npublic getLocalPlayerState(): PlayerState | undefined {\n  if (!this.room?.sessionId) return undefined;\n  return this.players.get(this.room.sessionId);\n}\n```\n\nThese methods provide controlled access to player state data while maintaining encapsulation of the internal players Map.\n</info added on 2025-04-23T21:36:20.438Z>",
          "status": "done",
          "parentTaskId": 12
        },
        {
          "id": 4,
          "title": "Implement message sending functionality",
          "description": "Add methods for sending the local player's state updates to the server periodically.",
          "dependencies": [
            3
          ],
          "details": "Implementation steps:\n1. Add the following methods to MultiplayerService:\n   - sendPlayerState(state): Sends the local player's state (x, y, angle, cargo) to the server using room.send('updateState', state)\n   - startStateSync(interval): Begins sending periodic state updates at the specified interval (default: 100ms)\n   - stopStateSync(): Stops the periodic state updates\n2. Implement message validation before sending\n3. Add error handling for message sending failures\n4. Optimize state updates to only send when changes occur\n\nTesting approach:\n- Test state sending with various player states\n- Verify periodic updates are sent at the correct interval\n- Test optimization to ensure updates are only sent when needed\n- Verify error handling works correctly for failed sends\n\n<info added on 2025-04-23T21:37:46.282Z>\n## Message Sending Implementation Details\n\nFor the state validation before sending:\n```typescript\nprivate validateState(state: Partial<PlayerState>): boolean {\n  // Check for required properties\n  if (state.x === undefined || state.y === undefined || state.angle === undefined) {\n    console.warn('Invalid player state: missing required properties');\n    return false;\n  }\n  \n  // Validate value ranges\n  if (isNaN(state.x) || isNaN(state.y) || isNaN(state.angle)) {\n    console.warn('Invalid player state: NaN values detected');\n    return false;\n  }\n  \n  return true;\n}\n```\n\nFor the optimization to only send when changes occur:\n```typescript\nprivate lastSentState: PlayerState = null;\n\npublic sendPlayerState(state: Partial<PlayerState>): boolean {\n  // Only send if state has changed significantly\n  if (this.lastSentState && this.isStateSimilar(state, this.lastSentState)) {\n    return false; // No need to send\n  }\n  \n  // Validation and sending logic...\n  \n  // Store last sent state for comparison\n  this.lastSentState = {...state};\n  return true;\n}\n\nprivate isStateSimilar(newState: Partial<PlayerState>, oldState: PlayerState): boolean {\n  // Define thresholds for significant changes\n  const positionThreshold = 0.5; // 0.5 pixels\n  const angleThreshold = 0.05; // ~3 degrees\n  \n  return (\n    Math.abs(newState.x - oldState.x) < positionThreshold &&\n    Math.abs(newState.y - oldState.y) < positionThreshold &&\n    Math.abs(newState.angle - oldState.angle) < angleThreshold &&\n    newState.cargo === oldState.cargo\n  );\n}\n```\n\nFor error handling implementation:\n```typescript\npublic sendPlayerState(state: Partial<PlayerState>): boolean {\n  if (!this.isConnected()) {\n    this.eventEmitter.emit('connection:error', 'Cannot send state: not connected');\n    return false;\n  }\n  \n  if (!this.validateState(state)) {\n    return false;\n  }\n  \n  try {\n    this.room.send(\"updateState\", state);\n    return true;\n  } catch (error) {\n    console.error('Failed to send player state:', error);\n    this.eventEmitter.emit('message:error', error);\n    return false;\n  }\n}\n```\n</info added on 2025-04-23T21:37:46.282Z>",
          "status": "done",
          "parentTaskId": 12
        },
        {
          "id": 5,
          "title": "Implement basic single-room Colyseus server & Phaser integration",
          "description": "Create a basic Colyseus server with a single game room and integrate the multiplayer service with the Phaser game engine.",
          "dependencies": [
            1,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Create a basic Colyseus server (Node.js/TypeScript):\n   - Define a GameRoom class extending Colyseus Room, registered as 'game_room'\n   - Create a schema for player state (id, x, y, angle, cargo)\n   - Implement onJoin to assign session ID and add player to state\n   - Implement onLeave to remove player from state\n   - Add message handler for 'updateState' to update player state\n   - Configure server to allow anonymous connections\n2. Integrate MultiplayerService with Phaser's MainScene:\n   - Initialize and connect the MultiplayerService\n   - Start periodic state sending for the local player\n   - Use state change listeners (onAdd, onChange, onRemove) to:\n     * Create sprites for new remote players\n     * Update positions of existing remote players\n     * Remove sprites for disconnected players\n3. Implement interpolation for smooth remote player movement\n4. Add visual indicators for connection status in the UI\n\nTesting approach:\n- Test end-to-end functionality with multiple clients\n- Verify player movements are correctly synchronized\n- Test disconnection and reconnection scenarios\n- Verify server correctly handles player joining and leaving\n- Test interpolation provides smooth movement for remote players\n\n<info added on 2025-04-23T21:44:06.078Z>\n## Phaser Integration Plan\n\nIntegrating `MultiplayerService` into `MainScene.ts`:\n\n1.  **Import:** `MultiplayerService` from `../../services/MultiplayerService` and `PlayerState` from `../../colyseus/schema/State`.\n2.  **Add Properties:**\n    *   `private multiplayerService!: MultiplayerService;`\n    *   `private remotePlayers: Map<string, Phaser.GameObjects.GameObject> = new Map();`\n    *   `private lastStateSendTime: number = 0;`\n    *   `private readonly stateSendInterval: number = 100; // ms`\n3.  **In `create()`:**\n    *   Instantiate `MultiplayerService`.\n    *   Call `connect()`.\n    *   Register `handlePlayerAdd`, `handlePlayerUpdate`, `handlePlayerRemove` using the service's listener methods.\n4.  **Implement Listener Callbacks:**\n    *   `handlePlayerAdd(playerId, state)`: Creates a `Phaser.GameObjects.Rectangle` at `state.x`, `state.y`, sets its angle, adds it to the scene, and stores it in `remotePlayers` map using `playerId`.\n    *   `handlePlayerUpdate(playerId, state)`: Finds the corresponding GameObject in `remotePlayers`, updates its `x`, `y`, and `angle`.\n    *   `handlePlayerRemove(playerId)`: Finds the GameObject, calls `destroy()`, and removes it from the `remotePlayers` map.\n5.  **In `update(time, delta)`:**\n    *   Check timer: `if (time > this.lastStateSendTime + this.stateSendInterval)`.\n    *   Inside check: Get local rocket state (`this.rocket.body.position.x`, `this.rocket.body.position.y`, `this.rocket.body.angle`), create state object `Partial<PlayerState>`. Call `this.multiplayerService.sendPlayerState(localState)`. Update `this.lastStateSendTime`.\n6.  **In `shutdown()`:**\n    *   Call `this.multiplayerService.disconnect();`.\n\n**Next steps (after this edit):** Implement interpolation and connection status UI.\n</info added on 2025-04-23T21:44:06.078Z>\n\n<info added on 2025-04-23T21:46:50.361Z>\n## Interpolation Implementation Plan\n\n1.  **Update `remotePlayers` Map:** Change type to `Map<string, { visual: Phaser.GameObjects.Rectangle; targetX: number; targetY: number; targetAngle: number; }>`.\n2.  **Modify `handlePlayerAdd`:** Store initial state in `targetX`, `targetY`, `targetAngle` when creating the map entry.\n3.  **Modify `handlePlayerUpdate`:** Update `targetX`, `targetY`, `targetAngle` in the map entry instead of setting visual properties directly.\n4.  **Add Interpolation Logic to `MainScene.update()`:**\n    *   Iterate `remotePlayers`.\n    *   Get `visual`, `targetX`, `targetY`, `targetAngle`.\n    *   Calculate `lerpFactor = 0.2 * (delta / 16.666)` (example).\n    *   `visual.x = Phaser.Math.Linear(visual.x, targetX, lerpFactor);`\n    *   `visual.y = Phaser.Math.Linear(visual.y, targetY, lerpFactor);`\n    *   `visual.angle = Phaser.Math.Angle.RotateTo(visual.angle, Phaser.Math.RadToDeg(targetAngle), lerpFactor);` // Use RotateTo for angle interpolation\n</info added on 2025-04-23T21:46:50.361Z>\n\n<info added on 2025-04-23T21:48:18.304Z>\n## Connection Status UI Plan\n\n1. **Define ConnectionStatus Enum:**\n   ```typescript\n   // In MultiplayerService.ts\n   export enum ConnectionStatus {\n     DISCONNECTED = 'disconnected',\n     CONNECTING = 'connecting',\n     CONNECTED = 'connected',\n     RECONNECTING = 'reconnecting',\n     ERROR = 'error'\n   }\n   ```\n\n2. **Add Status Management to MultiplayerService:**\n   ```typescript\n   private status: ConnectionStatus = ConnectionStatus.DISCONNECTED;\n   private statusListeners: ((status: ConnectionStatus) => void)[] = [];\n   \n   public addStatusListener(callback: (status: ConnectionStatus) => void): void {\n     this.statusListeners.push(callback);\n     // Immediately notify with current status\n     callback(this.status);\n   }\n   \n   private updateStatus(newStatus: ConnectionStatus): void {\n     this.status = newStatus;\n     this.statusListeners.forEach(listener => listener(newStatus));\n   }\n   ```\n\n3. **UI Implementation in MainScene:**\n   ```typescript\n   private connectionStatusText!: Phaser.GameObjects.Text;\n   \n   // In create():\n   this.connectionStatusText = this.add.text(10, 10, 'Status: Disconnected', {\n     fontSize: '16px',\n     color: '#ff0000',\n     backgroundColor: 'rgba(0,0,0,0.5)',\n     padding: { x: 5, y: 5 }\n   }).setScrollFactor(0).setDepth(100);\n   \n   handleConnectionStatusChange(status: ConnectionStatus): void {\n     let color = '#ff0000';\n     switch(status) {\n       case ConnectionStatus.CONNECTED:\n         color = '#00ff00';\n         break;\n       case ConnectionStatus.CONNECTING:\n       case ConnectionStatus.RECONNECTING:\n         color = '#ffff00';\n         break;\n     }\n     this.connectionStatusText.setText(`Status: ${status}`);\n     this.connectionStatusText.setColor(color);\n   }\n   ```\n\n4. **Add Status Updates in MultiplayerService Methods:**\n   ```typescript\n   async connect(): Promise<void> {\n     this.updateStatus(ConnectionStatus.CONNECTING);\n     try {\n       // existing connection code\n       this.updateStatus(ConnectionStatus.CONNECTED);\n     } catch (error) {\n       this.updateStatus(ConnectionStatus.ERROR);\n       throw error;\n     }\n   }\n   \n   disconnect(): void {\n     // existing disconnect code\n     this.updateStatus(ConnectionStatus.DISCONNECTED);\n   }\n   ```\n\n5. **Add Reconnection Logic:**\n   ```typescript\n   // In MultiplayerService\n   private setupReconnection(): void {\n     this.client.onClose.once(() => {\n       if (this.status !== ConnectionStatus.DISCONNECTED) {\n         this.updateStatus(ConnectionStatus.RECONNECTING);\n         this.attemptReconnect();\n       }\n     });\n   }\n   \n   private async attemptReconnect(attempts = 0): Promise<void> {\n     if (attempts >= 5) {\n       this.updateStatus(ConnectionStatus.ERROR);\n       return;\n     }\n     \n     try {\n       await this.connect();\n     } catch (error) {\n       setTimeout(() => this.attemptReconnect(attempts + 1), 2000);\n     }\n   }\n   ```\n</info added on 2025-04-23T21:48:18.304Z>\n\n<info added on 2025-04-23T22:08:11.803Z>\n## Server-Side Planet Management Implementation\n\n1. **Extend Room State Schema:**\n   ```typescript\n   // In schema/State.ts\n   export class PlanetState extends Schema {\n     @type(\"string\") id: string;\n     @type(\"number\") x: number;\n     @type(\"number\") y: number;\n     @type(\"number\") radius: number;\n     @type(\"string\") textureKey: string;\n     @type(\"number\") mass: number;\n   }\n\n   export class GameState extends Schema {\n     @type({ map: PlayerState }) players = new MapSchema<PlayerState>();\n     @type({ map: PlanetState }) planets = new MapSchema<PlanetState>();\n   }\n   ```\n\n2. **Initialize Planets in GameRoom:**\n   ```typescript\n   // In rooms/GameRoom.ts\n   import { planetConfigurations } from \"../config/PlanetConfig\";\n\n   // Inside onCreate method\n   onCreate() {\n     this.setState(new GameState());\n     \n     // Initialize planets from configuration\n     planetConfigurations.forEach(config => {\n       const planet = new PlanetState();\n       planet.id = config.id;\n       planet.x = config.position.x;\n       planet.y = config.position.y;\n       planet.radius = config.radius;\n       planet.textureKey = config.textureKey;\n       planet.mass = config.mass;\n       \n       this.state.planets.set(planet.id, planet);\n     });\n   }\n   ```\n\n3. **MultiplayerService Planet Handling:**\n   ```typescript\n   // In MultiplayerService.ts\n   import { PlanetState } from '../colyseus/schema/State';\n\n   // Add these properties\n   private planetAddListeners: Map<string, (id: string, data: PlanetState) => void> = new Map();\n   private planetRemoveListeners: Map<string, (id: string) => void> = new Map();\n   \n   // Add these methods\n   public onPlanetAdd(id: string, callback: (id: string, data: PlanetState) => void): void {\n     this.planetAddListeners.set(id, callback);\n     \n     // If already connected, notify about existing planets\n     if (this.room) {\n       this.room.state.planets.forEach((planet, planetId) => {\n         callback(planetId, planet);\n       });\n     }\n   }\n   \n   public onPlanetRemove(id: string, callback: (id: string) => void): void {\n     this.planetRemoveListeners.set(id, callback);\n   }\n   \n   // In connect method, add:\n   this.room.state.planets.onAdd = (planet, planetId) => {\n     this.planetAddListeners.forEach(listener => listener(planetId, planet));\n   };\n   \n   this.room.state.planets.onRemove = (_, planetId) => {\n     this.planetRemoveListeners.forEach(listener => listener(planetId));\n   };\n   ```\n\n4. **MainScene Planet Integration:**\n   ```typescript\n   // In MainScene.ts\n   private planets: Map<string, Phaser.GameObjects.Sprite> = new Map();\n   \n   // In create method:\n   this.multiplayerService.onPlanetAdd('mainScene', (planetId, planetData) => {\n     // Create planet sprite\n     const planetSprite = this.add.sprite(\n       planetData.x, \n       planetData.y, \n       planetData.textureKey\n     );\n     planetSprite.setDisplaySize(planetData.radius * 2, planetData.radius * 2);\n     \n     // Store reference\n     this.planets.set(planetId, planetSprite);\n     \n     // Note: Physics interactions would be added here in a future task\n   });\n   \n   this.multiplayerService.onPlanetRemove('mainScene', (planetId) => {\n     const planet = this.planets.get(planetId);\n     if (planet) {\n       planet.destroy();\n       this.planets.delete(planetId);\n     }\n   });\n   \n   // In shutdown method:\n   this.multiplayerService.onPlanetAdd('mainScene', null);\n   this.multiplayerService.onPlanetRemove('mainScene', null);\n   ```\n\nThis implementation ensures planets are managed by the server and synchronized across all clients, providing a consistent game world for all players.\n</info added on 2025-04-23T22:08:11.803Z>\n\n<info added on 2025-04-23T22:58:06.029Z>\n## Physics Manager Integration with Synchronized Planet Data\n\n```typescript\n// In PhysicsManager.ts\nprivate planetObjectsMap: Map<string, { sprite: Phaser.GameObjects.Sprite; body: Phaser.Physics.Arcade.Body; data: PlanetState }> = new Map();\n\n// Method to receive the planet objects map from MainScene\npublic setPlanetObjectsMap(map: Map<string, { sprite: Phaser.GameObjects.Sprite; body: Phaser.Physics.Arcade.Body; data: PlanetState }>): void {\n  this.planetObjectsMap = map;\n}\n\n// Updated addGravitySource to use PlanetState data\npublic addGravitySource(\n  id: string, \n  body: Phaser.Physics.Arcade.Body, \n  planetData: PlanetState\n): void {\n  this.gravitySources.set(id, {\n    body,\n    mass: planetData.mass,\n    atmosphereHeight: planetData.atmosphereHeight,\n    surfaceDensity: planetData.surfaceDensity\n  });\n}\n\n// Updated applyAirResistance method\nprivate applyAirResistance(rocket: Phaser.Physics.Arcade.Body): void {\n  for (const [_, source] of this.gravitySources) {\n    const dx = rocket.x - source.body.x;\n    const dy = rocket.y - source.body.y;\n    const distanceSquared = dx * dx + dy * dy;\n    const distance = Math.sqrt(distanceSquared);\n    \n    // Get radius from the body\n    const planetRadius = source.body.width / 2;\n    \n    // Check if rocket is within atmosphere\n    if (distance < planetRadius + source.atmosphereHeight) {\n      // Calculate atmospheric density based on height\n      const height = distance - planetRadius;\n      const densityFactor = Math.max(0, 1 - (height / source.atmosphereHeight));\n      const density = source.surfaceDensity * densityFactor;\n      \n      // Apply drag proportional to density and velocity squared\n      const speed = Math.sqrt(rocket.velocity.x * rocket.velocity.x + rocket.velocity.y * rocket.velocity.y);\n      const dragMagnitude = this.dragCoefficient * density * speed * speed;\n      \n      if (speed > 0.1) {\n        const dragX = (dragMagnitude * rocket.velocity.x) / speed;\n        const dragY = (dragMagnitude * rocket.velocity.y) / speed;\n        \n        rocket.velocity.x -= dragX;\n        rocket.velocity.y -= dragY;\n      }\n    }\n  }\n}\n```\n\n```typescript\n// In MainScene.ts\n// Updated planet objects map to include PlanetState data\nprivate planetObjects: Map<string, { \n  sprite: Phaser.GameObjects.Sprite; \n  body: Phaser.Physics.Arcade.Body; \n  data: PlanetState \n}> = new Map();\n\n// In the planet creation handler\nthis.multiplayerService.onPlanetAdd('mainScene', (planetId, planetData) => {\n  const planetSprite = this.add.sprite(planetData.x, planetData.y, planetData.textureKey);\n  planetSprite.setDisplaySize(planetData.radius * 2, planetData.radius * 2);\n  \n  this.physics.add.existing(planetSprite, true);\n  const body = planetSprite.body as Phaser.Physics.Arcade.Body;\n  \n  // Store all data together\n  this.planetObjects.set(planetId, {\n    sprite: planetSprite,\n    body: body,\n    data: planetData\n  });\n  \n  // Add to physics manager with synchronized data\n  this.physicsManager.addGravitySource(planetId, body, planetData);\n});\n\n// In create() method, after initializing physicsManager\nthis.physicsManager.setPlanetObjectsMap(this.planetObjects);\n```\n\n```typescript\n// In schema/State.ts (server and client)\nexport class PlanetState extends Schema {\n  @type(\"string\") id: string;\n  @type(\"number\") x: number;\n  @type(\"number\") y: number;\n  @type(\"number\") radius: number;\n  @type(\"string\") textureKey: string;\n  @type(\"number\") mass: number;\n  @type(\"number\") atmosphereHeight: number;\n  @type(\"number\") surfaceDensity: number;\n}\n```\n</info added on 2025-04-23T22:58:06.029Z>",
          "status": "done",
          "parentTaskId": 12
        }
      ]
    },
    {
      "id": 13,
      "title": "Implement Server-Side Physics with Matter.js",
      "description": "Refactor the architecture to move authoritative physics simulation to the server using Matter.js, while ensuring client-side synchronization and smooth gameplay experience.",
      "details": "This task involves a major architectural shift to move physics simulation from the client to the server for authoritative game state management. Key implementation steps include:\n\n1. Set up Matter.js on the server side with the same configuration as currently used on the client\n2. Modify the Colyseus GameRoom to initialize and maintain the physics world\n3. Implement a fixed timestep physics update loop on the server\n4. Update state schemas to include necessary physics properties (positions, velocities, rotations)\n5. Create a system to receive player inputs from clients and apply them to the physics simulation\n6. Implement state synchronization to send authoritative physics updates to clients\n7. Modify the client to:\n   - Send player inputs to the server instead of applying them locally\n   - Receive and apply server state updates\n   - Implement client-side prediction and reconciliation to minimize perceived latency\n   - Add interpolation for smooth rendering between state updates\n8. Ensure proper handling of object creation and destruction in the physics world\n9. Implement collision detection and resolution on the server\n10. Add performance optimizations to minimize network traffic (delta compression, etc.)\n\nConsiderations:\n- Network latency will impact player experience; implement appropriate prediction/reconciliation\n- Physics simulation must be deterministic across server restarts\n- Consider how to handle disconnections and reconnections\n- Ensure the server can handle the computational load of physics for multiple game rooms",
      "testStrategy": "Testing should verify both the correctness of the physics simulation and the quality of the networked experience:\n\n1. Unit Tests:\n   - Verify server-side physics calculations match expected outcomes\n   - Test state schema serialization/deserialization\n   - Validate input handling and application to physics bodies\n\n2. Integration Tests:\n   - Confirm proper synchronization between server and client states\n   - Test object creation/destruction across the network\n   - Verify collision detection and resolution works correctly on the server\n\n3. Performance Tests:\n   - Measure server CPU usage under various player loads\n   - Benchmark network bandwidth usage\n   - Test with artificial network latency and packet loss\n\n4. Gameplay Tests:\n   - Conduct A/B testing comparing client-side vs. server-side physics\n   - Verify gameplay feels responsive despite network latency\n   - Test edge cases like high-speed collisions and stacking objects\n\n5. Specific Test Cases:\n   - Connect multiple clients and verify consistent physics state across all\n   - Test reconnection scenario to ensure proper state recovery\n   - Verify that server authority properly overrides client prediction when conflicts occur\n   - Test with various network conditions (high latency, packet loss) to ensure graceful degradation",
      "status": "done",
      "dependencies": [
        12
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Matter.js on the server and initialize physics world in GameRoom",
          "description": "Configure Matter.js on the server with the same settings as the client and integrate it with the Colyseus GameRoom to initialize and maintain the physics world.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Install Matter.js as a server dependency\n2. Create a PhysicsManager class that will encapsulate the Matter.js functionality\n3. Import and configure Matter.js with identical settings to client (gravity, bounds, etc.)\n4. Modify the GameRoom class to instantiate the physics world during room creation\n5. Set up the basic world properties and configuration options\n6. Ensure the physics world is properly destroyed when the room is disposed\n\nTesting approach:\n- Create unit tests to verify physics world initialization with expected parameters\n- Test that the physics engine can be created and destroyed properly\n- Verify that basic physics operations (adding bodies, running simulation) work as expected\n\n<info added on 2025-04-24T16:29:30.760Z>\nHere's additional implementation information for subtask 13.1:\n\n```typescript\n// server/src/physics/ServerPhysicsManager.ts\nimport { Engine, World, Bodies, Composite } from 'matter-js';\nimport { Logger } from '../../../shared/utils/Logger';\n\nexport class ServerPhysicsManager {\n  private engine: Matter.Engine;\n  private logger: Logger;\n  \n  constructor() {\n    this.logger = new Logger('ServerPhysicsManager');\n    \n    // Initialize engine with gravity disabled (0, 0)\n    this.engine = Engine.create({\n      gravity: { x: 0, y: 0 },\n      enableSleeping: false,\n      positionIterations: 6,\n      velocityIterations: 4,\n      timing: { timeScale: 1 }\n    });\n    \n    this.logger.info('Physics engine initialized');\n  }\n  \n  public getEngine(): Matter.Engine {\n    return this.engine;\n  }\n  \n  public update(deltaTime: number): void {\n    Engine.update(this.engine, deltaTime);\n  }\n  \n  public addBody(body: Matter.Body): void {\n    Composite.add(this.engine.world, body);\n  }\n  \n  public removeBody(body: Matter.Body): void {\n    Composite.remove(this.engine.world, body);\n  }\n  \n  public destroy(): void {\n    World.clear(this.engine.world, false);\n    Engine.clear(this.engine);\n    this.logger.info('Physics engine destroyed');\n  }\n}\n\n// Integration in GameRoom.ts\nimport { ServerPhysicsManager } from '../physics/ServerPhysicsManager';\n\n// In GameRoom class:\nprivate physicsManager: ServerPhysicsManager;\nprivate physicsInterval: NodeJS.Timeout;\n\nonCreate() {\n  this.physicsManager = new ServerPhysicsManager();\n  \n  // Set up physics update loop at 60fps (16.67ms)\n  const physicsTimeStep = 1000 / 60;\n  this.physicsInterval = setInterval(() => {\n    this.physicsManager.update(physicsTimeStep);\n    // Broadcast updated physics state to clients\n    this.broadcast(\"physics-update\", this.getPhysicsState());\n  }, physicsTimeStep);\n}\n\nonDispose() {\n  if (this.physicsInterval) {\n    clearInterval(this.physicsInterval);\n  }\n  if (this.physicsManager) {\n    this.physicsManager.destroy();\n  }\n}\n\nprivate getPhysicsState() {\n  // Extract relevant physics state to broadcast to clients\n  // This will be expanded in future tasks\n  return {};\n}\n```\n</info added on 2025-04-24T16:29:30.760Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 2,
          "title": "Implement fixed timestep physics update loop on server",
          "description": "Create a deterministic physics update loop on the server that runs at a fixed timestep to ensure consistent simulation regardless of server performance.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Implement a fixed timestep loop in the GameRoom that calls Matter.js update at consistent intervals (e.g., 60 times per second)\n2. Use setInterval or a similar mechanism to ensure regular updates\n3. Track accumulated time to handle potential server lag without affecting simulation accuracy\n4. Add configurable physics timestep value to server configuration\n5. Implement proper time scaling to ensure physics behave consistently regardless of update frequency\n6. Add performance monitoring to log when physics updates take longer than expected\n\nTesting approach:\n- Create tests that verify physics objects move deterministically given the same inputs\n- Test that the simulation remains stable under various server loads\n- Verify that the physics state advances correctly with the fixed timestep\n\n<info added on 2025-04-24T16:34:52.217Z>\nI've reviewed your implementation of the fixed timestep physics loop. Here are additional technical details to enhance the subtask:\n\nFor the `ServerPhysicsManager.update(delta)` method:\n- Ensure you're passing the fixed timestep value to `Engine.update(engine, fixedDelta)` rather than the variable delta to maintain determinism\n- Consider adding a maximum delta cap (e.g., `Math.min(delta, 250)`) to prevent large time jumps during server hiccups\n\nFor the GameRoom implementation:\n- The accumulator pattern is correct, but ensure you're using a while loop (`while (accumulator >= fixedTimestep)`) rather than if statements to handle multiple physics updates when needed\n- Track and store the interpolation factor (`const alpha = accumulator / fixedTimestep`) which will be useful for client-side rendering between physics steps\n- Consider implementing a \"panic mode\" that resets the accumulator if too many consecutive updates are needed (e.g., after server freeze)\n\nConfiguration improvements:\n- Store the physics configuration in a central config object that includes:\n  ```typescript\n  {\n    fixedTimestep: 1000/60, // 16.67ms (60Hz)\n    maxAccumulatedTime: 200, // ms, prevents spiral of death\n    velocityIterations: 8,\n    positionIterations: 3\n  }\n  ```\n\nPerformance monitoring:\n- Use `performance.now()` instead of `Date.now()` for more precise timing\n- Implement a rolling average of physics update times to detect degradation trends\n</info added on 2025-04-24T16:34:52.217Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 3,
          "title": "Update state schemas to include physics properties",
          "description": "Extend the Colyseus state schemas to include all necessary physics properties such as positions, velocities, rotations, and other attributes needed for synchronization.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Identify all physics properties that need to be synchronized (position, velocity, angle, angular velocity, etc.)\n2. Update the entity schemas in the Colyseus state to include these properties\n3. Create mapping functions between Matter.js bodies and Colyseus schema objects\n4. Implement helper methods to update schema from physics bodies and vice versa\n5. Ensure proper type conversion between Matter.js and Colyseus schema types\n6. Add any necessary metadata for reconciliation (like physics step ID)\n\nTesting approach:\n- Test serialization and deserialization of physics properties\n- Verify that all necessary properties are included in the schema\n- Test the mapping functions between Matter.js bodies and schema objects\n\n<info added on 2025-04-24T16:38:08.933Z>\nFor the physics properties implementation, consider these additional details:\n\n1. Use `@filter()` decorator on physics properties that don't need to be sent every frame to reduce bandwidth:\n   ```typescript\n   @filter(function(this: PlayerState, client, value) {\n     // Only send sleeping state changes when they actually change\n     return this.previousIsSleeping !== value;\n   })\n   @type(\"boolean\")\n   isSleeping: boolean;\n   ```\n\n2. Add a `previousTransform` object to store last synchronized values for delta compression:\n   ```typescript\n   @type({ map: \"number\" })\n   previousTransform: MapSchema<number> = new MapSchema();\n   ```\n\n3. Implement threshold-based synchronization to reduce network traffic:\n   ```typescript\n   // In your mapping function\n   if (Math.abs(body.position.x - player.x) > MIN_POSITION_DELTA || \n       Math.abs(body.position.y - player.y) > MIN_POSITION_DELTA) {\n     player.x = body.position.x;\n     player.y = body.position.y;\n   }\n   ```\n\n4. Add a `physicsBodyId` field to maintain reference between schema and Matter.js bodies:\n   ```typescript\n   @type(\"string\")\n   physicsBodyId: string;\n   ```\n\n5. Consider adding interpolation metadata for client-side smoothing:\n   ```typescript\n   @type(\"number\")\n   lastUpdateTime: number;\n   ```\n</info added on 2025-04-24T16:38:08.933Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 4,
          "title": "Create input handling system for client-to-server physics commands",
          "description": "Develop a system to receive player inputs from clients and apply them correctly to the server-side physics simulation.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Define a message format for client input commands (movement, actions, etc.)\n2. Implement server-side handlers to receive these commands in the GameRoom\n3. Create a queue system to store and process inputs in the correct order\n4. Add timestamp and sequence numbering to inputs for reconciliation\n5. Implement the logic to apply these inputs to the appropriate physics bodies\n6. Add validation to prevent cheating (speed hacks, teleporting, etc.)\n7. Create a system to acknowledge processed inputs back to clients\n\nTesting approach:\n- Test input message handling with various input types\n- Verify that inputs are applied correctly to physics bodies\n- Test input validation and rejection of invalid commands\n- Verify sequence handling works correctly with out-of-order messages",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 5,
          "title": "Implement server-to-client state synchronization",
          "description": "Create a system to efficiently send authoritative physics updates from the server to clients, including delta compression to minimize network traffic.",
          "dependencies": [
            2,
            3
          ],
          "details": "Implementation steps:\n1. Implement a system to track changes in physics state between updates\n2. Create a mechanism to send full state snapshots at regular intervals\n3. Implement delta compression to only send changed properties between full snapshots\n4. Add configurable send rate that may differ from physics update rate\n5. Include physics step ID with each update for reconciliation purposes\n6. Implement bandwidth optimization techniques (property filtering, quantization, etc.)\n7. Add priority system to ensure important objects always get updated\n\nTesting approach:\n- Measure bandwidth usage with and without optimizations\n- Test that clients correctly receive and apply state updates\n- Verify that delta compression correctly identifies and transmits only changed properties\n- Test with various network conditions (packet loss, latency, etc.)\n\n<info added on 2025-04-24T17:29:19.818Z>\nImplementation details:\n\nWithin the GameRoom physics loop, after each physics step:\n```javascript\n// Inside the physics loop after updating physics state\nif (this.accumulator >= this.physicsTimeStep) {\n  // Physics step calculations...\n  \n  // Construct state update for broadcasting\n  const physicsUpdate = {};\n  this.players.forEach(player => {\n    if (player.body) {\n      physicsUpdate[player.sessionId] = {\n        x: player.body.position.x,\n        y: player.body.position.y,\n        angle: player.body.angle,\n        vx: player.body.velocity.x,\n        vy: player.body.velocity.y,\n        angularVelocity: player.body.angularVelocity,\n        isSleeping: player.body.isSleeping\n      };\n    }\n  });\n  \n  // Add physics step ID for reconciliation\n  const updatePacket = {\n    stepId: this.currentPhysicsStep,\n    timestamp: Date.now(),\n    delta: this.calculateDelta(this.lastBroadcastState, physicsUpdate),\n    fullState: this.shouldSendFullState() ? physicsUpdate : undefined\n  };\n  \n  // Store last broadcast state for delta calculation\n  this.lastBroadcastState = {...physicsUpdate};\n  \n  // Broadcast to all clients\n  this.broadcast(\"physics_update\", updatePacket);\n  \n  this.currentPhysicsStep++;\n}\n```\n\nThe `calculateDelta` function compares current and previous states to only send changed properties:\n```javascript\ncalculateDelta(previous, current) {\n  if (!previous) return current; // First update sends everything\n  \n  const delta = {};\n  Object.keys(current).forEach(sessionId => {\n    const prevPlayerState = previous[sessionId];\n    const currPlayerState = current[sessionId];\n    \n    if (!prevPlayerState) {\n      // New player, include all properties\n      delta[sessionId] = currPlayerState;\n      return;\n    }\n    \n    // Check which properties changed\n    const playerDelta = {};\n    let hasChanges = false;\n    \n    Object.keys(currPlayerState).forEach(prop => {\n      // Apply threshold for floating point values to reduce updates\n      if (typeof currPlayerState[prop] === 'number') {\n        if (Math.abs(currPlayerState[prop] - prevPlayerState[prop]) > this.updateThresholds[prop] || 0.0001) {\n          playerDelta[prop] = currPlayerState[prop];\n          hasChanges = true;\n        }\n      } else if (currPlayerState[prop] !== prevPlayerState[prop]) {\n        playerDelta[prop] = currPlayerState[prop];\n        hasChanges = true;\n      }\n    });\n    \n    if (hasChanges) {\n      delta[sessionId] = playerDelta;\n    }\n  });\n  \n  return delta;\n}\n```\n</info added on 2025-04-24T17:29:19.818Z>\n\n<info added on 2025-04-25T09:53:56.205Z>\n<info added on 2025-04-25T09:14:32.451Z>\nImplementation refinements for delta compression:\n\n1. Define specific threshold constants for different property types:\n```javascript\n// Constants for delta compression thresholds\nconst SYNC_THRESHOLD_POSITION = 0.01;  // 1cm in world units\nconst SYNC_THRESHOLD_VELOCITY = 0.05;  // 5cm/s in world units\nconst SYNC_THRESHOLD_ANGLE = 0.01;     // ~0.6 degrees\nconst SYNC_THRESHOLD_ANGULAR_VELOCITY = 0.02;\n```\n\n2. Enhanced delta calculation with property-specific thresholds:\n```javascript\ncalculateDelta(previous, current) {\n  // ... existing code ...\n  \n  Object.keys(currPlayerState).forEach(prop => {\n    // Apply property-specific thresholds\n    if (typeof currPlayerState[prop] === 'number') {\n      const threshold = \n        prop === 'x' || prop === 'y' ? SYNC_THRESHOLD_POSITION :\n        prop === 'vx' || prop === 'vy' ? SYNC_THRESHOLD_VELOCITY :\n        prop === 'angle' ? SYNC_THRESHOLD_ANGLE :\n        prop === 'angularVelocity' ? SYNC_THRESHOLD_ANGULAR_VELOCITY :\n        0.0001; // default threshold\n        \n      if (Math.abs(currPlayerState[prop] - prevPlayerState[prop]) > threshold) {\n        playerDelta[prop] = currPlayerState[prop];\n        hasChanges = true;\n      }\n    } else if (currPlayerState[prop] !== prevPlayerState[prop]) {\n      // For boolean properties like isSleeping\n      playerDelta[prop] = currPlayerState[prop];\n      hasChanges = true;\n    }\n  });\n  \n  // ... existing code ...\n}\n```\n\n3. Client-side handling of sparse delta updates:\n```javascript\n// Client-side code\nthis.room.onMessage(\"physics_update\", (data) => {\n  const { stepId, timestamp, delta, fullState } = data;\n  \n  // Track server physics step for reconciliation\n  this.serverPhysicsStep = stepId;\n  this.serverTimestamp = timestamp;\n  \n  if (fullState) {\n    // Full state update - replace entire state\n    this.gameState = fullState;\n  } else if (delta) {\n    // Apply delta updates to existing state\n    Object.keys(delta).forEach(sessionId => {\n      // Create player entry if it doesn't exist\n      if (!this.gameState[sessionId]) {\n        this.gameState[sessionId] = {};\n      }\n      \n      // Apply only the changed properties\n      Object.assign(this.gameState[sessionId], delta[sessionId]);\n    });\n  }\n  \n  // Apply the updated state to the physics world\n  this.applyStateToPhysics();\n});\n```\n\n4. Bandwidth monitoring and adaptive compression:\n```javascript\n// Track bandwidth usage\nthis.bytesSent = 0;\nthis.updatesSent = 0;\n\n// After creating update packet\nconst packetSize = JSON.stringify(updatePacket).length;\nthis.bytesSent += packetSize;\nthis.updatesSent++;\n\n// Every 5 seconds, evaluate and potentially adjust thresholds\nif (Date.now() - this.lastBandwidthCheck > 5000) {\n  const bytesPerSecond = this.bytesSent / 5;\n  \n  // If bandwidth usage is too high, increase thresholds\n  if (bytesPerSecond > this.maxBytesPerSecond) {\n    SYNC_THRESHOLD_POSITION *= 1.2;\n    SYNC_THRESHOLD_VELOCITY *= 1.2;\n    SYNC_THRESHOLD_ANGLE *= 1.2;\n  } else if (bytesPerSecond < this.minBytesPerSecond) {\n    // If bandwidth usage is low, decrease thresholds for better precision\n    SYNC_THRESHOLD_POSITION = Math.max(0.001, SYNC_THRESHOLD_POSITION * 0.8);\n    SYNC_THRESHOLD_VELOCITY = Math.max(0.01, SYNC_THRESHOLD_VELOCITY * 0.8);\n    SYNC_THRESHOLD_ANGLE = Math.max(0.001, SYNC_THRESHOLD_ANGLE * 0.8);\n  }\n  \n  this.bytesSent = 0;\n  this.lastBandwidthCheck = Date.now();\n}\n```\n</info added on 2025-04-25T09:14:32.451Z>\n</info added on 2025-04-25T09:53:56.205Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 6,
          "title": "Modify client to send inputs and apply server state",
          "description": "Update the client-side code to send player inputs to the server instead of applying them locally, and to receive and apply server state updates.",
          "dependencies": [
            4,
            5
          ],
          "details": "Implementation steps:\n1. Refactor client input handling to send commands to server instead of applying locally\n2. Implement client-side input buffering and sequence numbering\n3. Create a system to receive and apply server state updates to local entities\n4. Modify the client rendering to use the synchronized state\n5. Implement a system to handle server acknowledgments of processed inputs\n6. Add error handling for connection issues and server rejections\n7. Create debug visualization to show server vs. client state\n\nTesting approach:\n- Test input sending and state receiving under various network conditions\n- Verify that client correctly applies server state updates\n- Test handling of connection interruptions\n- Verify that inputs are correctly sequenced and buffered",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 7,
          "title": "Implement client-side prediction and reconciliation",
          "description": "Add client-side prediction to apply inputs locally before server confirmation, and reconciliation to correct the client state when server updates arrive.",
          "dependencies": [
            6
          ],
          "details": "Implementation steps:\n1. Implement client-side physics simulation for prediction\n2. Apply local inputs immediately while also sending to server\n3. Store input history and predicted states for reconciliation\n4. When receiving server updates, compare with predicted state\n5. If discrepancy is detected, rewind and replay inputs from last acknowledged input\n6. Implement smoothing to prevent jarring corrections\n7. Add configuration options for prediction settings\n8. Create debug visualization of prediction and reconciliation\n\nTesting approach:\n- Test prediction accuracy under various conditions\n- Verify reconciliation correctly handles server-client discrepancies\n- Test with artificial latency to ensure smooth experience\n- Measure and optimize performance impact of prediction\n\n<info added on 2025-04-25T09:54:19.967Z>\nFor client-side reconciliation/correction, we've refined the approach to balance accuracy with smooth gameplay:\n\n1. The client now relies on authoritative server state rather than applying local predicted forces independently.\n\n2. Correction logic uses partial application of server state through interpolation:\n   - Position correction: `Phaser.Math.Linear(currentPos, serverPos, CLIENT_PHYSICS_CORRECTION_FACTOR)`\n   - Rotation correction: `Phaser.Math.Angle.RotateTo(currentRot, serverRot, CLIENT_PHYSICS_CORRECTION_FACTOR * delta)`\n   - Default correction factor is 0.5, configurable based on game needs\n\n3. This approach creates a dual-layer system:\n   - Physics bodies gradually align with server state to maintain collision integrity\n   - Visual elements interpolate toward target positions for smoother player experience\n\n4. Added threshold detection to prevent minor corrections (< 5px difference) from triggering full reconciliation\n\n5. Implemented adaptive correction factor that scales based on discrepancy magnitude:\n   ```javascript\n   const discrepancyMagnitude = Phaser.Math.Distance.Between(\n     currentPos.x, currentPos.y, serverPos.x, serverPos.y\n   );\n   const adaptiveFactor = Math.min(\n     CLIENT_PHYSICS_CORRECTION_FACTOR * (1 + discrepancyMagnitude/100), \n     0.9\n   );\n   ```\n</info added on 2025-04-25T09:54:19.967Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 8,
          "title": "Add interpolation and implement collision handling",
          "description": "Implement client-side interpolation for smooth rendering between state updates and server-side collision detection and resolution.",
          "dependencies": [
            5,
            7
          ],
          "details": "Implementation steps:\n1. Implement entity interpolation on the client to smooth movement between state updates\n2. Create a buffer of recent server states for interpolation\n3. Add configurable interpolation delay to balance smoothness vs. latency\n4. Implement server-side collision detection using Matter.js collision system\n5. Create event handlers for different collision types on the server\n6. Synchronize collision effects to clients\n7. Add special handling for important gameplay collisions (damage, pickups, etc.)\n8. Implement client-side collision prediction for responsive feedback\n\nTesting approach:\n- Test visual smoothness with various network conditions\n- Verify that collisions are correctly detected and resolved on server\n- Test collision events are properly synchronized to clients\n- Verify that interpolation correctly handles object creation and destruction",
          "status": "done",
          "parentTaskId": 13
        }
      ]
    },
    {
      "id": 14,
      "title": "Refactor Physics Logic for Client-Server Consistency with Client-Side Prediction",
      "description": "Create a shared physics implementation between client and server, then implement client-side prediction with server correction to improve gameplay responsiveness while maintaining authoritative server physics.",
      "details": "This task involves restructuring our physics implementation to improve consistency and responsiveness:\n\n1. Create the following directory and files:\n   - `@shared/physics/` directory\n   - `@shared/physics/Constants.ts` for physics constants (gravity strength, air resistance factors)\n   - `@shared/physics/PhysicsLogic.ts` for core physics calculations\n   - `@shared/physics/CollisionCategories.ts` (moved from current location)\n\n2. Move the following logic to shared implementation:\n   - Extract `applyCustomGravity` and `applyAirResistance` from `src/game/physics/PhysicsManager.ts` to `PhysicsLogic.ts`\n   - Ensure all physics constants are defined in `Constants.ts`\n   - Move collision categories to shared location\n\n3. Update client and server implementations:\n   - Modify `src/game/physics/PhysicsManager.ts` to use shared logic\n   - Update server physics in `ServerPhysicsManager` and `GameRoom` to apply shared logic before `Engine.update`\n\n4. Implement refined client-side prediction:\n   - In `src/game/scenes/MainScene.ts`, remove local predicted force application to eliminate physics judder\n   - Update `Rocket.update` to set visuals directly from its physics body (remove local interpolation for player's rocket)\n   - Implement partial physics body correction using `CLIENT_PHYSICS_CORRECTION_FACTOR` towards server state instead of instant snapping\n   - Adjust local visual interpolation factor for better responsiveness while maintaining smoothness\n   - Keep interpolation for remote rockets\n\n5. Update all import paths throughout the codebase to reference the new shared modules\n   - Use `@ts-ignore` for shared imports if needed due to build configuration\n\n6. Implement thruster visibility synchronization:\n   - Add `isThrusting` property to shared PlayerState schema\n   - Update server to broadcast thrust state as part of player state\n   - Modify client to read thrust state from server updates\n   - Update Rocket entity to use the `isThrusting` property to control visual thruster display\n   - Fix any related type errors and schema import path issues\n\nThe server remains the authority for physics simulation, but the client now predicts movement based on input using the same physics logic, creating a more responsive experience while maintaining consistency.\n\n**Implementation Plan:**\n1.  **Create Shared Physics Logic (`@shared`)**:\n    *   Create a new directory `@shared/physics`.\n    *   Create `Constants.ts` for shared physics constants (G, DRAG_COEFFICIENT).\n    *   Create `PhysicsLogic.ts` for shared physics calculation functions.\n    *   Move the core logic of `applyCustomGravity` from `src/game/physics/PhysicsManager.ts` into a static function (e.g., `PhysicsLogic.calculateAndApplyGravity`) in the shared file.\n    *   Move the core logic of `applyAirResistance` from `src/game/physics/PhysicsManager.ts` into a static function (e.g., `PhysicsLogic.calculateAndApplyAirResistance`) in the shared file.\n    *   Move `src/game/physics/CollisionCategories.ts` to `@shared/physics/CollisionCategories.ts`.\n\n2.  **Update Client Physics (`src/game/physics/PhysicsManager.ts`)**:\n    *   Modify it to import and use the shared functions from `@shared/physics/PhysicsLogic.ts` within its `update` method.\n    *   Remove the local implementations of `applyCustomGravity` and `applyAirResistance`.\n    *   Update imports for `CollisionCategories`.\n\n3.  **Update Server Physics (`server/src/physics/ServerPhysicsManager.ts` & `server/src/rooms/GameRoom.ts`)**:\n    *   Modify `ServerPhysicsManager` (or `GameRoom`'s physics loop) to import and use the shared functions from `@shared/physics/PhysicsLogic.ts` to apply gravity and air resistance to player bodies *before* calling `Engine.update`.\n    *   Update imports for `CollisionCategories` if used.\n\n4.  **Implement Refined Client-Side Prediction**:\n    *   **Remove Local Force Application:** Eliminate direct force application on the client to prevent physics judder.\n    *   **Define Correction Factor:** Add `CLIENT_PHYSICS_CORRECTION_FACTOR` constant to control how quickly local physics bodies correct toward server state.\n    *   **Partial Correction:** Instead of instantly snapping to server positions, gradually move the local physics body toward server state using the correction factor.\n    *   **Visual Update:** Adjust the visual interpolation factor for the local rocket to balance responsiveness and smoothness.\n    *   **Keep Remote Interpolation:** Maintain the existing interpolation for remote rockets.\n\n5.  **Implement State Correction (`src/game/scenes/MainScene.ts`)**:\n    *   **Modify `handlePhysicsUpdate`:** For the local player, apply partial correction to the local `rocket.body` state using the correction factor.\n    *   **Implement Lerping:** Use linear interpolation between current state and server state based on the correction factor.\n\n6.  **Implement Thruster Visibility Synchronization**:\n    *   Update the shared PlayerState schema to include an `isThrusting` boolean property\n    *   Modify server code to track and broadcast the thrust state of each player\n    *   Update client code to read the thrust state from server updates\n    *   Modify the Rocket entity to use the `isThrusting` property to control visual thruster display\n    *   Resolve any type errors and schema import path issues that arise\n\n7.  **Handle Imports & `@ts-ignore`**:\n    *   Update all import paths referencing the moved files.\n    *   Use `@ts-ignore` comments for shared imports if necessary.",
      "testStrategy": "Testing should verify both the refactoring and the client-side prediction implementation:\n\n1. Unit Tests:\n   - Create tests for shared physics functions to verify calculations are identical to previous implementation\n   - Test that constants are properly exported and accessible\n   - Verify the CLIENT_PHYSICS_CORRECTION_FACTOR produces expected interpolation results\n\n2. Integration Tests:\n   - Verify server physics still behaves identically after refactoring\n   - Confirm client can import and use shared physics modules\n   - Test the partial correction mechanism with various correction factor values\n\n3. Functional Tests:\n   - Test high-latency scenarios (use network throttling tools):\n     - Player movement should feel responsive despite latency\n     - Verify partial correction occurs smoothly when server updates arrive\n     - Confirm no physics judder during gameplay with the refined approach\n     - No visible 'snapping' during normal gameplay\n   - Test edge cases:\n     - Rapid input changes during high latency\n     - Collision handling with prediction\n     - Multiple simultaneous player interactions\n     - Extreme server-client position differences\n   - Test thruster visibility synchronization:\n     - Verify thrusters display correctly for local player with prediction\n     - Confirm remote players' thrusters appear/disappear appropriately\n     - Test thruster state during network interruptions\n\n4. Visual Verification:\n   - Record side-by-side comparison of gameplay before and after changes\n   - Verify that remote players' movements appear smooth\n   - Confirm local player movement is more responsive but still stable\n   - Compare different CLIENT_PHYSICS_CORRECTION_FACTOR values visually\n   - Verify thruster visual effects match player actions for both local and remote players\n\n5. Performance Testing:\n   - Measure client frame rate before and after changes\n   - Verify no significant increase in CPU usage from prediction calculations\n   - Test performance with different correction factor values",
      "status": "done",
      "dependencies": [],
      "priority": "high"
    },
    {
      "id": 15,
      "title": "Refactor Project to Monorepo Workspace Structure",
      "description": "Migrate client, server, and shared code into a monorepo structure using npm/yarn/pnpm workspaces for better code sharing and dependency management. Original files have been moved to a 'monorepo-conversion' directory to ensure a clean workspace.",
      "details": "## Implementation Steps:\n\n1. **Setup Root Configuration**\n   - Create/update root package.json with workspace definition (e.g., `\"workspaces\": [\"packages/*\"]`)\n   - Set up base tsconfig.json with common compiler options\n   - Add .gitignore for node_modules at root and package levels\n\n2. **Create Packages Structure**\n   - Create packages/ directory at project root\n   - Create subdirectories: packages/client/, packages/server/, packages/shared/\n\n3. **Migrate Client Code**\n   - Copy relevant client code from monorepo-conversion/src/ to packages/client/src/\n   - Copy client assets from monorepo-conversion/public/ to packages/client/public/\n   - Create client package.json with appropriate dependencies (reference original package.json)\n   - Add dependency on shared package (e.g., `\"@one-button-to-space/shared\": \"*\"`)\n   - Create client-specific tsconfig.json extending from root\n   - Update build paths and scripts\n\n4. **Migrate Server Code**\n   - Copy server code from monorepo-conversion/server/ to packages/server/src/\n   - Create server package.json with appropriate dependencies (reference original package.json)\n   - Add dependency on shared package\n   - Create server-specific tsconfig.json extending from root\n   - Update build paths and scripts\n\n5. **Set Up Shared Package**\n   - Copy shared code from monorepo-conversion/shared/ to packages/shared/src/\n   - Create package.json with name `@one-button-to-space/shared`\n   - Configure for proper TypeScript declarations\n   - Set up build process to generate distributable files\n\n6. **Refactor Import Statements**\n   - Update all imports in client and server to use the shared package\n   - Replace relative imports (../../shared) with package imports (@one-button-to-space/shared)\n\n7. **Package Installation**\n   - Run workspace-aware install from root (npm/yarn/pnpm install)\n   - Verify node_modules structure and hoisting\n\n8. **Root Scripts Configuration**\n   - Add scripts to root package.json for managing workspaces:\n     - `\"build\": \"npm run build --workspaces\"`\n     - `\"dev\": \"npm run dev --workspaces --parallel\"`\n     - `\"test\": \"npm run test --workspaces\"`\n     - Add other workspace management scripts as needed\n\n9. **Update CI/CD Pipeline**\n   - Modify CI/CD configuration to work with monorepo structure\n   - Update build and deployment scripts\n\n10. **Configuration Files Migration**\n    - Review and migrate relevant configuration from monorepo-conversion/config/ to appropriate packages\n    - Update paths and references in configuration files to match new structure\n\n11. **Cleanup**\n    - After successful testing, remove the temporary monorepo-conversion directory",
      "testStrategy": "## Testing Approach:\n\n1. **Build Verification**\n   - Run `npm run build` at root level\n   - Verify all packages build successfully without errors\n   - Check that output directories contain expected files\n\n2. **Functionality Testing**\n   - Start both client and server applications\n   - Verify all core functionality works as before\n   - Test all major user flows to ensure nothing broke during migration\n   - Compare behavior with the original implementation in monorepo-conversion directory\n\n3. **Shared Code Propagation Test**\n   - Make a change to a type or function in the shared package\n   - Rebuild all packages (`npm run build`)\n   - Verify the change is correctly reflected in both client and server\n   - Test functionality that depends on the modified shared code\n\n4. **Package Dependency Test**\n   - Add a new function or type to the shared package\n   - Import and use it in both client and server\n   - Verify it works correctly in both places\n\n5. **Development Workflow Test**\n   - Test the development workflow with the new structure\n   - Verify hot reloading works correctly\n   - Ensure developers can easily run and test individual packages\n\n6. **CI Pipeline Test**\n   - Run the updated CI pipeline\n   - Verify all build, test, and deployment steps complete successfully\n\n7. **Side-by-Side Comparison**\n   - Run the original application from monorepo-conversion directory\n   - Run the new monorepo version\n   - Compare functionality, performance, and behavior to ensure equivalence",
      "status": "done",
      "dependencies": [],
      "priority": "medium"
    },
    {
      "id": 16,
      "title": "Upgrade Rocket Visuals and Implement Precise Collision Detection",
      "description": "Replace the placeholder rocket graphic with a high-quality image asset, implement a mesh-based collision detection system, and add animated thruster effects to enhance gameplay visuals and physics.",
      "details": "This task involves three main components:\n\n1. **Rocket Asset Replacement**:\n   - Source or create a detailed rocket image asset (recommended dimensions: 128x256px with transparent background)\n   - Implement the new asset in the game's rendering system\n   - Ensure proper scaling and rotation of the new asset\n   - Maintain the rocket's center of mass at the appropriate position\n\n2. **Mesh-based Collision Detection**:\n   - Create a collision mesh that closely follows the contours of the new rocket asset\n   - Replace the current collision detection system (likely using simple shapes) with a mesh-based approach\n   - Implement efficient collision detection algorithms suitable for real-time gameplay\n   - Ensure collision response physics remain consistent with game design\n   - Add appropriate hitbox visualization for debug mode\n\n3. **Animated Thruster Effects**:\n   - Create or source a sprite sheet for thruster animation (recommended: 4-8 frames)\n   - Implement animation system for the thruster effects\n   - Tie animation state to player input (e.g., more intense animation when thrust is higher)\n   - Ensure proper positioning of thruster effects relative to the rocket\n   - Add appropriate particle effects to enhance the visual appeal\n\nPerformance considerations: The mesh-based collision should be optimized to maintain frame rate. Consider using simplified collision meshes rather than pixel-perfect collision if performance issues arise.\n\n**Implementation Notes:**\n- **Visual Upgrade:** Replaced placeholder rectangle with `rocket.png` for improved visual fidelity. Player-specific coloring retained via `setTint()` for differentiation, choosing this over complex shaders for simplicity.\n- **Collision Accuracy:** Replaced rectangular physics body with a more accurate 7-point vertex-based shape (`fromVertices`) derived from the asset image to improve collision detection. Iteratively adjusted vertices and visual offset (`visualOffsetY`) to align physics and visual representation. Moved vertex definition to shared package for client-server consistency.\n- **Physics/Visual Link:** Removed client-side visual interpolation (decoupling `gameObject` from `targetX/Y/Angle`). Visuals now directly mirror the (server-corrected) physics body state, prioritizing physics accuracy over potential visual smoothing.\n- **Thruster Effect:** Replaced static graphics thruster with a flickering `Sprite` using two images (`thruster_001.png`, `thruster_002.png`) as a preliminary animated effect. Adjusted position, scale, depth, and flicker rate based on visual feedback. Particle effects deferred.",
      "testStrategy": "Testing should verify all three components function correctly:\n\n1. **Visual Testing**:\n   - Verify the rocket asset displays correctly at different screen resolutions\n   - Confirm the rocket rotates smoothly without visual artifacts\n   - Ensure the thruster animation plays correctly when thrust is applied\n   - Check that the animation intensity corresponds to thrust level\n   - Verify thruster position remains fixed relative to the rocket during movement\n\n2. **Collision Testing**:\n   - Test collision detection with various game objects (asteroids, power-ups, boundaries)\n   - Verify collisions are detected accurately at the visual edges of the rocket\n   - Test edge cases: high-speed collisions, glancing collisions, multi-point collisions\n   - Ensure no false positives/negatives in collision detection\n   - Measure performance impact of new collision system (should maintain target FPS)\n\n3. **Integration Testing**:\n   - Verify rocket controls remain responsive with new visuals\n   - Test game balance hasn't been affected by collision changes\n   - Ensure save/load functionality works with the new rocket implementation\n   - Test on minimum spec hardware to verify performance\n   - Verify the physics-visual coupling works correctly with server corrections\n   - Test player color tinting across different game scenarios\n\nCreate a debug visualization toggle to display collision meshes during testing.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Source and Integrate New Rocket Asset",
          "description": "Source or create a high-quality rocket image and integrate it into the game's rendering system, replacing the current placeholder graphic.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Source or create a detailed rocket image (128x256px with transparent background)\n2. Add the new asset to the project's resource folder\n3. Update the asset loading code to reference the new rocket image\n4. Modify the rendering code to use the new asset instead of the placeholder\n5. Ensure proper scaling and rotation of the new asset\n6. Verify the rocket's center of mass is correctly positioned\n\nTesting approach:\n- Visually confirm the new rocket renders correctly in different game states\n- Test rotation and movement to ensure the rocket behaves as expected\n- Verify the rocket maintains proper scale across different screen resolutions",
          "status": "done",
          "parentTaskId": 16
        },
        {
          "id": 2,
          "title": "Create Collision Mesh for Rocket",
          "description": "Design and implement a collision mesh that accurately follows the contours of the new rocket asset for more precise collision detection.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Analyze the new rocket asset to determine appropriate collision points\n2. Create a polygon-based collision mesh that follows the rocket's contours\n3. Implement a data structure to store the collision mesh vertices\n4. Add a utility function to transform the mesh based on rocket position and rotation\n5. Create a debug visualization mode to display the collision mesh\n\nTesting approach:\n- Use debug visualization to verify the mesh properly follows the rocket's shape\n- Test the mesh transformation with various rocket positions and rotations\n- Verify the collision mesh updates correctly during gameplay",
          "status": "done",
          "parentTaskId": 16
        },
        {
          "id": 3,
          "title": "Implement Mesh-based Collision Detection System",
          "description": "Replace the current collision detection with a mesh-based system that uses the new collision mesh for more accurate collision detection.",
          "dependencies": [
            2
          ],
          "details": "Implementation steps:\n1. Implement polygon-polygon intersection algorithms for collision detection\n2. Modify the game's collision detection system to use the new mesh-based approach\n3. Optimize the collision detection for performance (consider spatial partitioning if needed)\n4. Ensure collision response physics remain consistent with game design\n5. Add configuration options to adjust collision precision vs. performance\n6. Move vertex definition to shared package for client-server consistency\n7. Implement the 7-point vertex-based shape using `fromVertices` derived from the asset image\n8. Adjust vertices and visual offset (`visualOffsetY`) to align physics and visual representation\n\nTesting approach:\n- Test collision detection with various game objects and scenarios\n- Benchmark performance to ensure frame rate remains acceptable\n- Compare collision behavior with previous system to ensure consistency\n- Test edge cases like high-speed collisions and near-misses\n- Verify client-server consistency with the shared vertex definitions",
          "status": "done",
          "parentTaskId": 16
        },
        {
          "id": 4,
          "title": "Create Thruster Animation Assets and System",
          "description": "Design and implement the animation system for rocket thrusters, including creating or sourcing appropriate sprite sheets.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create or source a sprite sheet for thruster animation (4-8 frames)\n2. Add the thruster assets to the project's resource folder\n3. Implement a sprite animation system if not already present\n4. Create animation sequences for different thruster states (idle, low power, full power)\n5. Determine proper positioning of thruster effects relative to the rocket\n\nTesting approach:\n- Verify all animation frames display correctly\n- Test animation timing and transitions between states\n- Ensure thruster position remains correct during rocket movement and rotation",
          "status": "done",
          "parentTaskId": 16
        },
        {
          "id": 5,
          "title": "Integrate Thruster Effects with Player Input",
          "description": "Connect the thruster animation system to player input and add particle effects to enhance visual appeal.",
          "dependencies": [
            4
          ],
          "details": "Implementation steps:\n1. Modify the player input handling to trigger appropriate thruster animations\n2. Implement intensity scaling based on thrust level\n3. Add a particle system for thruster exhaust effects\n4. Configure particles to match the thruster animation state\n5. Optimize particle effects for performance\n6. Add sound effects that correspond to thruster intensity\n\nTesting approach:\n- Test responsiveness of thruster effects to player input\n- Verify particle effects render correctly and match thruster animations\n- Ensure performance remains stable with multiple particle effects active\n- Test on different hardware to ensure effects scale appropriately",
          "status": "done",
          "parentTaskId": 16
        },
        {
          "id": 6,
          "title": "Implement Direct Physics-Visual Coupling",
          "description": "Remove client-side visual interpolation and ensure visuals directly mirror the physics body state for improved accuracy.",
          "dependencies": [
            3
          ],
          "details": "Implementation steps:\n1. Remove the existing client-side visual interpolation system that decouples `gameObject` from `targetX/Y/Angle`\n2. Modify rendering code to directly use the physics body state for visual representation\n3. Ensure server corrections to physics state are properly reflected in visuals\n4. Test for visual artifacts or jitter that might result from this change\n5. Document the design decision prioritizing physics accuracy over visual smoothing\n\nTesting approach:\n- Compare visual behavior before and after the change\n- Test under various network conditions to ensure server corrections display properly\n- Verify that physics and visuals remain in sync during gameplay\n- Assess if any visual smoothing is still needed in specific scenarios",
          "status": "done",
          "parentTaskId": 16
        },
        {
          "id": 7,
          "title": "Enhance Thruster Visual Effects",
          "description": "Improve the current flickering thruster effect with more sophisticated animation and potential particle effects.",
          "dependencies": [
            5
          ],
          "details": "Implementation steps:\n1. Evaluate the current flickering `Sprite` implementation using two thruster images\n2. Refine the flicker rate, position, scale, and depth based on visual feedback\n3. Consider implementing a more complex animation sequence if needed\n4. Assess the feasibility of adding particle effects as originally planned\n5. If implementing particles, create a configurable system that scales with thrust level\n\nTesting approach:\n- Gather feedback on the visual appeal of the thruster effects\n- Test performance impact of any new visual effects added\n- Verify thruster effects remain properly positioned during all rocket movements\n- Ensure effects scale appropriately with different thrust levels",
          "status": "done",
          "parentTaskId": 16
        },
        {
          "id": 8,
          "title": "Implement Player-Specific Rocket Coloring",
          "description": "Ensure the rocket coloring system using setTint() works correctly for player differentiation.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Review the current implementation of player-specific coloring using `setTint()`\n2. Test the coloring system with various player configurations\n3. Document the decision to use tinting over more complex shader approaches\n4. Ensure tint colors are visually distinct and maintain the rocket's visual details\n5. Create a color palette that works well with the rocket asset\n\nTesting approach:\n- Verify all player colors render correctly and are visually distinct\n- Test color persistence through different game states\n- Ensure colors don't interfere with visual effects like thruster animations\n- Test on different displays to ensure colors remain distinguishable",
          "status": "done",
          "parentTaskId": 16
        }
      ]
    },
    {
      "id": 17,
      "title": "Implement Client-Side Deterministic Star Field Background",
      "description": "Create a procedurally generated star field background that renders consistently across sessions using a deterministic algorithm. The effect should be performant and visually appealing.",
      "details": "Develop a JavaScript module that generates and renders a star field background on an HTML canvas element. The implementation should:\n\n1. Use a seeded random number generator to ensure the same star pattern is generated each time with the same seed value\n2. Allow configuration of parameters such as:\n   - Star density (stars per unit area)\n   - Star size range (min/max pixel size)\n   - Star brightness/color variation\n   - Background color/gradient\n   - Optional parallax effect based on mouse movement or scrolling\n3. Optimize rendering performance using:\n   - Canvas optimization techniques\n   - Efficient animation loops (requestAnimationFrame)\n   - Only redrawing when necessary\n4. Implement a resize handler to ensure the star field properly fills the container when the window size changes\n5. Provide a simple API for initialization, seed setting, and configuration updates\n6. Include options for static stars or subtle twinkling/pulsing effects\n7. Ensure the module works across all major browsers\n8. Keep the implementation lightweight with minimal dependencies",
      "testStrategy": "1. Unit Testing:\n   - Verify the seeded random number generator produces consistent results with the same seed\n   - Test that star positions are deterministic with the same configuration\n   - Validate all configuration parameters affect the output as expected\n\n2. Visual Testing:\n   - Compare screenshots of star fields generated with the same seed to confirm visual consistency\n   - Verify the star field renders correctly at different screen sizes and device pixel ratios\n\n3. Performance Testing:\n   - Measure and benchmark rendering performance using browser dev tools\n   - Test with varying star densities to ensure performance remains acceptable\n   - Monitor memory usage during extended periods\n\n4. Cross-Browser Testing:\n   - Verify the star field renders consistently across Chrome, Firefox, Safari, and Edge\n   - Test on both desktop and mobile devices\n\n5. Integration Testing:\n   - Ensure the star field initializes correctly when the page loads\n   - Verify the resize handler properly adjusts the star field when the window is resized\n   - Test that configuration changes at runtime update the star field appropriately",
      "status": "done",
      "dependencies": [],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Seeded Random Number Generator Module",
          "description": "Implement a deterministic random number generator that can be seeded to produce consistent results across sessions",
          "dependencies": [],
          "details": "1. Research and implement a high-quality seeded PRNG algorithm (like Mulberry32 or xorshift)\n2. Create a module with the following functions:\n   - `setSeed(seed)`: Initialize the generator with a specific seed value\n   - `random()`: Return a random float between 0 and 1 (similar to Math.random())\n   - `randomRange(min, max)`: Return a random number within a specified range\n   - `randomInt(min, max)`: Return a random integer within a specified range\n3. Add unit tests to verify determinism by comparing sequences with the same seed\n4. Ensure the implementation is efficient and has no external dependencies\n5. Test across different browsers to ensure consistent behavior\n\n<info added on 2025-04-26T14:37:52.642Z>\nThe Mulberry32 algorithm is a good choice for this implementation as it offers a good balance between speed and randomness quality. Here's some additional technical information:\n\n1. Implementation details:\n   - The core algorithm uses a 32-bit state that's updated with each call\n   - The bit manipulation operations (shifts, XORs) create high-quality pseudorandom sequences\n   - Time complexity is O(1) for each random number generation\n\n2. Optimization considerations:\n   - Used bitwise operations for performance\n   - Implemented `next()` method that returns raw integers for cases where float conversion isn't needed\n   - Added internal state caching to avoid recalculating when the same seed is set multiple times\n\n3. Testing recommendations:\n   - Create test vectors with known seeds and expected output sequences\n   - Test edge cases like seed=0, seed=MAX_INT, etc.\n   - Verify statistical properties using chi-square tests for randomness quality\n\n4. Usage example:\n```typescript\n// Example usage in game systems\nconst rng = new DeterministicRNG(12345); // Seed with level ID\nconst damage = rng.randomRange(10, 20); // Consistent damage roll\n```\n\n5. Added JSDoc comments to all public methods for better developer experience and type hinting.\n</info added on 2025-04-26T14:37:52.642Z>",
          "status": "done",
          "parentTaskId": 17
        },
        {
          "id": 2,
          "title": "Implement Star Generation Algorithm",
          "description": "Create a module that generates star data using the seeded random number generator",
          "dependencies": [
            1
          ],
          "details": "1. Create a `StarField` class that accepts configuration parameters (density, size range, color variations, etc.)\n2. Implement a `generateStars(width, height)` method that:\n   - Uses the seeded RNG from subtask 1\n   - Creates an array of star objects based on the configured density\n   - Each star should have properties: x, y positions, size, color, brightness\n   - Distributes stars evenly across the specified dimensions\n3. Add methods to regenerate stars when parameters change\n4. Implement optional twinkling/pulsing by adding time-based properties to stars\n5. Test with different configurations to ensure proper star distribution\n6. Add validation for configuration parameters with sensible defaults\n\n<info added on 2025-04-26T14:39:07.059Z>\nI've reviewed the implementation and can provide these additional technical details:\n\n```typescript\n// Star interface represents individual star properties\ninterface Star {\n  x: number;\n  y: number;\n  size: number;\n  color: string;\n  brightness: number;\n  twinkleSpeed?: number;\n  twinklePhase?: number;\n}\n\n// Configuration interface with sensible defaults\ninterface StarFieldConfig {\n  density: number; // stars per 1000pxÂ²\n  minSize: number;\n  maxSize: number;\n  colors: string[];\n  enableTwinkling: boolean;\n  twinkleVariation: number;\n}\n\n// Implementation notes:\n// - Used HSL color model for stars to easily control brightness\n// - Color generation: `hsl(${hue}, ${saturation}%, ${brightness}%)`\n// - Twinkling implemented via sine wave: brightness * (1 + Math.sin(time * twinkleSpeed + twinklePhase) * twinkleVariation)\n// - Density calculation: Math.floor((width * height / 1000) * config.density)\n// - Added spatial distribution check to prevent star clustering\n// - Performance optimization: pre-calculated colors array for common star types\n// - Added optional z-index property for parallax effects in future enhancements\n```\n\nThe implementation includes proper validation with error handling for configuration parameters and maintains O(n) time complexity for star generation.\n</info added on 2025-04-26T14:39:07.059Z>",
          "status": "done",
          "parentTaskId": 17
        },
        {
          "id": 3,
          "title": "Develop Canvas Rendering System",
          "description": "Create an optimized rendering system that draws the generated stars onto an HTML canvas",
          "dependencies": [
            2
          ],
          "details": "1. Implement a `render(canvas)` method in the StarField class that:\n   - Clears the canvas\n   - Draws the background (solid color or gradient)\n   - Efficiently renders each star with appropriate size and color\n   - Uses appropriate canvas optimization techniques (e.g., batching similar operations)\n2. Implement a main animation loop using requestAnimationFrame\n3. Add logic to only redraw when necessary (for static stars or when animation parameters change)\n4. Create helper methods for drawing different star styles (circles, glows, etc.)\n5. Test rendering performance with various star densities\n6. Add FPS monitoring during development to ensure smooth performance\n7. Implement browser-specific optimizations if needed\n\n<info added on 2025-04-26T14:40:23.643Z>\nFor the `StarFieldRenderer` implementation:\n\n- The `render()` method uses Phaser's Graphics API to efficiently batch star drawing operations, improving performance over individual draw calls\n- Implemented depth sorting to ensure stars appear in correct z-order based on their size/brightness\n- Added configurable rendering options including:\n  - `blendMode`: Support for 'ADD', 'MULTIPLY', etc. for different visual effects\n  - `alpha`: Global transparency control for the entire starfield\n  - `tint`: Optional color tinting for stars\n- Optimized rendering by:\n  - Using object pooling to avoid garbage collection during animation\n  - Implementing culling for off-screen stars\n  - Using Phaser's camera system to only render stars in the visible viewport\n- Added support for different star shapes beyond circles (diamond, cross, pixel)\n- Implemented optional post-processing effects like bloom and motion blur\n- Added performance monitoring with debug toggle to display render statistics\n</info added on 2025-04-26T14:40:23.643Z>",
          "status": "done",
          "parentTaskId": 17
        },
        {
          "id": 4,
          "title": "Add Responsive Behavior and Event Handling",
          "description": "Implement resize handling and optional parallax effects based on user interaction",
          "dependencies": [
            3
          ],
          "details": "1. Add a resize event listener to adjust the canvas size when the window or container changes\n2. Implement logic to regenerate or reposition stars when the canvas is resized\n3. Create a parallax effect system that:\n   - Tracks mouse movement or scroll position\n   - Moves stars at different rates based on their size/depth\n   - Provides smooth transitions between positions\n4. Add configuration options to enable/disable parallax and adjust its sensitivity\n5. Ensure all event listeners are properly added and removed to prevent memory leaks\n6. Test responsiveness across different devices and screen sizes\n7. Optimize event handlers with debouncing/throttling for performance\n\n<info added on 2025-04-26T14:41:59.100Z>\nHere's additional technical information for your subtask:\n\n```typescript\n// Implementation notes for resize handling:\n// Use Phaser's built-in scale manager events for reliable resize detection\nthis.scene.scale.on('resize', this.handleResize, this);\n\n// Example handleResize implementation:\nprivate handleResize(gameSize: Phaser.Structs.Size): void {\n  this.width = gameSize.width;\n  this.height = gameSize.height;\n  \n  // Only regenerate if size changed significantly (optimization)\n  if (Math.abs(this.width - this.prevWidth) > 50 || Math.abs(this.height - this.prevHeight) > 50) {\n    this.regenerateStars();\n    this.prevWidth = this.width;\n    this.prevHeight = this.height;\n  }\n}\n\n// Parallax implementation using camera position:\nprivate applyParallax(): void {\n  if (!this.config.enableParallax) return;\n  \n  const camera = this.scene.cameras.main;\n  const parallaxFactor = this.config.parallaxFactor || 0.1;\n  \n  this.stars.forEach(star => {\n    // Deeper stars (brighter/larger) move slower for realistic depth effect\n    const depthFactor = 1 - (star.brightness * 0.5);\n    star.x -= camera.scrollX * parallaxFactor * depthFactor;\n    star.y -= camera.scrollY * parallaxFactor * depthFactor;\n    \n    // Wrap stars that move off-screen\n    this.wrapStarPosition(star);\n  });\n}\n\n// Viewport culling optimization:\nprivate isInViewport(x: number, y: number, buffer: number = 100): boolean {\n  const camera = this.scene.cameras.main;\n  return (\n    x >= camera.scrollX - buffer &&\n    x <= camera.scrollX + this.width + buffer &&\n    y >= camera.scrollY - buffer &&\n    y <= camera.scrollY + this.height + buffer\n  );\n}\n\n// Clean destroy method to prevent memory leaks:\npublic destroy(): void {\n  this.scene.scale.off('resize', this.handleResize, this);\n  this.graphics.destroy();\n  this.stars = [];\n}\n```\n\nThe parallax effect creates a sense of depth by moving stars at different rates based on their brightness/size. Viewport culling significantly improves performance by only rendering stars visible in the current view.\n</info added on 2025-04-26T14:41:59.100Z>",
          "status": "done",
          "parentTaskId": 17
        },
        {
          "id": 5,
          "title": "Create Public API and Documentation",
          "description": "Finalize the module with a clean public API, configuration options, and comprehensive documentation",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Design and implement a clean public API with methods for:\n   - Initialization with configuration options\n   - Updating configuration at runtime\n   - Starting/stopping animation\n   - Manually triggering redraws\n   - Cleaning up resources\n2. Add comprehensive JSDoc comments for all public methods and properties\n3. Create a demo page showcasing different configurations and features\n4. Write README documentation with:\n   - Installation instructions\n   - Usage examples\n   - Configuration options reference\n   - Performance considerations\n   - Browser compatibility notes\n5. Add error handling with meaningful error messages\n6. Perform cross-browser testing and fix any compatibility issues\n7. Optimize bundle size and consider providing both ES modules and UMD formats",
          "status": "done",
          "parentTaskId": 17
        }
      ]
    },
    {
      "id": 18,
      "title": "Implement Game Engine Architecture with Variable Update Rates and Layered Rendering",
      "description": "Design and implement a foundational client-side architecture that separates physics, logic, and rendering into independent update loops with different rates, while organizing game objects into a scene management system with separate render layers.",
      "details": "This task involves restructuring the client-side game engine to follow best practices for 2D game development, performance and maintainability:\n\n1. Variable Update Rate System:\n   - Implement a time management system that tracks delta time between frames\n   - Create separate update loops for game logic (fixed timestep) and rendering (variable, potentially V-sync limited)\n   - Implement interpolation between states for smooth rendering at higher framerates\n   - Design a central TimeManager class to provide timing information to all systems\n\n2. Scene/State Management:\n   - Create a SceneManager class that maintains a collection of active game objects\n   - Implement scene loading/unloading functionality with proper resource management\n   - Design a state transition system for different game states (menu, gameplay, etc.)\n   - Add support for hierarchical object relationships (parent-child transforms)\n\n3. Dedicated Update Manager:\n   - Develop an UpdateManager that orchestrates the execution order of systems\n   - Implement component registration for different update phases (early, standard, late)\n   - Create a priority system for controlling update sequence within each phase\n   - Add support for pausing specific systems independently\n\n4. Layered Rendering:\n   - Separate rendering into distinct layers (specifically game world and UI/HUD)\n   - Ensure UI elements remain fixed while game camera moves\n   - Create a camera system that can render to specific layers\n   - Design a compositing system to combine layers with appropriate blending\n\n5. 2D Game Development Best Practices:\n   - Implement efficient sprite batching for improved rendering performance\n   - Create a robust collision detection system appropriate for 2D games\n   - Design a flexible animation system for sprite-based animations\n   - Implement proper camera controls and viewport management for 2D space\n\n6. Code Cleanup and Organization:\n   - Enforce consistent naming conventions and code style\n   - Implement proper memory management with appropriate patterns\n   - Add comprehensive error handling and logging\n   - Ensure systems use interfaces/abstract classes for better decoupling\n   - Document all major systems with clear API documentation",
      "testStrategy": "Testing should verify both individual components and their integration:\n\n1. Time and Update Rate Testing:\n   - Unit test the TimeManager to ensure accurate delta time calculation\n   - Verify logic updates occur at fixed intervals regardless of frame rate\n   - Test rendering at different frame rates (30, 60, 144 fps) to confirm smooth motion\n   - Create a visualization tool that displays the actual update rates of each system\n   - Stress test with intentional frame drops to ensure stability\n\n2. Scene/State Management Testing:\n   - Verify objects are correctly added to and removed from scenes\n   - Test state transitions for memory leaks and proper resource cleanup\n   - Benchmark scene loading times with different numbers of objects\n   - Verify parent-child relationships maintain proper transformations\n\n3. Update System Testing:\n   - Create mock components that log their update order\n   - Verify components execute in the correct sequence based on priority\n   - Test pausing specific systems while others continue\n   - Measure performance impact of the update manager overhead\n\n4. Render Layer Testing:\n   - Create a test scene with objects on different layers (game world vs HUD)\n   - Verify UI elements remain fixed while game camera moves\n   - Test proper layering of game elements and UI components\n   - Verify performance with many objects across different layers\n\n5. 2D Specific Testing:\n   - Test sprite batching performance with varying numbers of sprites\n   - Verify collision detection accuracy and performance\n   - Test animation system with different sprite-based animations\n   - Verify camera controls and viewport management in 2D space\n\n6. Integration Testing:\n   - Create a benchmark scene that exercises all systems together\n   - Profile CPU/GPU usage to identify bottlenecks\n   - Test on different hardware configurations\n   - Implement automated tests that verify the correct interaction between all systems",
      "status": "pending",
      "dependencies": [],
      "priority": "medium"
    },
    {
      "id": 19,
      "title": "Implement Server-Authoritative Physics System with Client Prediction",
      "description": "Design and implement a server-authoritative physics system that maintains game state integrity while providing responsive client experiences through prediction and reconciliation techniques.",
      "details": "This task involves implementing a comprehensive server-authoritative physics system with the following components:\n\n1. Server-side physics implementation:\n   - Implement deterministic physics calculations on the server as the source of truth\n   - Set up a fixed timestep physics update loop independent of network tick rate\n   - Create data structures for efficiently storing and processing physics state\n\n2. Client-side prediction:\n   - Implement local physics simulation that mirrors server logic\n   - Apply local inputs immediately while tracking input sequence numbers\n   - Store recent input history and predicted states for reconciliation\n   - Use interpolation for non-controlled entities\n\n3. Server reconciliation:\n   - Send authoritative state updates with corresponding input sequence numbers\n   - Implement state correction that smoothly transitions from incorrect to correct states\n   - Add jitter buffer to handle network inconsistencies\n   - Implement adaptive error thresholds based on network conditions\n\n4. State synchronization optimization:\n   - Implement delta compression to send only changed values\n   - Add relevancy filtering based on player proximity/visibility\n   - Set up variable update rates based on entity importance\n   - Use quantization to reduce bandwidth requirements\n\n5. Input validation:\n   - Implement server-side validation of all client inputs\n   - Add anti-cheat measures to detect physics manipulation\n   - Create rate limiting for inputs to prevent flooding\n   - Design graceful handling of rejected inputs\n\nThe implementation should prioritize security while maintaining a responsive feel for players, even under suboptimal network conditions.",
      "testStrategy": "Testing should verify both correctness and performance of the physics system:\n\n1. Functional testing:\n   - Unit test physics calculations on both client and server to ensure identical results\n   - Verify reconciliation correctly handles state divergence by artificially introducing errors\n   - Test input validation by sending malformed or impossible inputs\n   - Confirm delta compression correctly transmits only changed values\n\n2. Performance testing:\n   - Measure bandwidth usage with and without optimizations under various player counts\n   - Profile CPU usage on both client and server during high-activity scenarios\n   - Test memory consumption over extended play sessions\n\n3. Network condition testing:\n   - Simulate various network conditions (packet loss, latency, jitter) using network simulation tools\n   - Verify system degrades gracefully under poor conditions\n   - Test reconnection scenarios and state recovery\n\n4. Integration testing:\n   - Verify physics interactions between multiple clients work correctly\n   - Test edge cases like rapid direction changes and collision scenarios\n   - Ensure synchronization remains stable during extended gameplay\n\n5. User experience testing:\n   - Conduct blind tests comparing local-only vs. networked physics to assess perceived responsiveness\n   - Measure and minimize visible correction artifacts\n   - Verify the system feels responsive across various network conditions\n\nDocument baseline metrics before and after implementation to quantify improvements.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium"
    }
  ],
  "metadata": {
    "projectName": "One Button to Space",
    "totalTasks": 10,
    "sourceFile": "C:\\dev\\personal\\one-button-to-space\\scripts\\prd.txt",
    "generatedAt": "2023-11-05"
  }
}