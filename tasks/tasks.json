{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Repository and Development Environment",
      "description": "Initialize the project repository with TypeScript, set up the build pipeline, and configure the basic project structure.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create a new TypeScript project using Vite for faster performance and simpler configuration. Initialize the project with a Vite template using `npm create vite@latest your-project-name -- --template vanilla-ts` which handles initial TypeScript setup, basic structure, and dev server configuration. Install necessary dependencies via npm/yarn including a physics engine (Matter.js or Planck.js) and a rendering library (Phaser.js or Pixi.js). Create folder structure for assets, src/game, src/physics, src/ui, and utilities. Set up a basic HTML template with a canvas element.",
      "testStrategy": "Verify that the Vite development environment builds successfully and runs in a browser. Test that TypeScript compilation works correctly. Ensure that the chosen physics and rendering libraries can be imported and used in the project. Confirm that the development server starts without errors and hot module replacement works as expected."
    },
    {
      "id": 2,
      "title": "Implement Basic Rendering and Game Loop",
      "description": "Set up the core game loop and rendering system to display a simple scene with a rocket.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Initialize Phaser.js with a canvas that fills the viewport. Create a game loop that handles updates and rendering at an appropriate frame rate. Implement a simple camera system that can follow the rocket. Create a basic rocket sprite/shape and render it on screen. Implement a simple background to represent space.",
      "testStrategy": "Verify that the game renders at a consistent frame rate. Test that the rocket appears correctly on screen. Ensure the game loop executes properly by logging timing information.",
      "subtasks": [
        {
          "id": 2.1,
          "title": "Create MainScene class",
          "description": "Create `src/game/scenes/MainScene.ts` and define a `class MainScene extends Phaser.Scene`.",
          "status": "done"
        },
        {
          "id": 2.2,
          "title": "Implement MainScene#create()",
          "description": "Set background color to black and add a white `Phaser.GameObjects.Rectangle` at the center of the screen to represent the rocket.",
          "status": "done"
        },
        {
          "id": 2.3,
          "title": "Implement empty preload() and update() methods",
          "description": "Add empty `preload()` and `update()` methods to the MainScene class for future implementation.",
          "status": "done"
        },
        {
          "id": 2.4,
          "title": "Configure Phaser in main.ts",
          "description": "Modify `src/main.ts` to import MainScene, define Phaser.Types.Core.GameConfig with appropriate settings (canvas size, physics), instantiate the Phaser.Game, and remove placeholder console logs.",
          "status": "done",
          "details": "Set the game canvas to fill the window size. Configure basic arcade physics with debug set to false. Add the MainScene to the scenes array in the config."
        }
      ]
    },
    {
      "id": 3,
      "title": "Implement Core Physics Engine Integration",
      "description": "Integrate the physics engine and set up the basic physics world with gravity simulation.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Initialize the chosen physics engine (Matter.js or Planck.js). Create a physics world with configurable gravity. Implement the rocket as a physics body with appropriate mass and shape. Set up collision detection for the rocket. Create a system for variable gravity that increases as the rocket approaches celestial bodies. Implement a basic planetary body with gravity influence.",
      "testStrategy": "Test that the rocket responds to gravity correctly. Verify that gravity increases as the rocket approaches planetary bodies. Ensure collision detection works by creating test objects and checking for collision events.",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize Physics Engine and Create Physics World",
          "description": "Set up the chosen physics engine (Matter.js or Planck.js) and create the basic physics world with default gravity settings.",
          "dependencies": [],
          "details": "1. Install the chosen physics engine via npm (e.g., `npm install matter-js`)\n2. Create a module for physics initialization\n3. Initialize the physics engine with basic configuration\n4. Create a physics world with default gravity (e.g., 9.8 m/sÂ² downward)\n5. Set up the main update loop to step the physics simulation\n6. Add configuration options for world parameters\n7. Test by creating a simple falling object and verifying gravity works correctly\n\n<info added on 2025-04-22T19:48:06.966Z>\nHere's the implementation plan to add:\n\n```typescript\n// Implementation details:\n\n// 1. PhysicsManager.ts structure\nexport class PhysicsManager {\n  private engine: Matter.Engine;\n  private world: Matter.World;\n  \n  constructor(scene: Phaser.Scene) {\n    this.engine = Matter.Engine.create({\n      enableSleeping: true,\n      gravity: { x: 0, y: 1 }\n    });\n    this.world = this.engine.world;\n    \n    // Connect to Phaser's Matter physics\n    scene.matter.world.engine = this.engine;\n  }\n  \n  initializeEngine(options = {}) {\n    // Configure additional engine options\n    Matter.Engine.update(this.engine, options);\n    return this;\n  }\n  \n  createWorld(bounds = { x: 0, y: 0, width: 800, height: 600 }) {\n    // Set world bounds\n    Matter.World.setBounds(this.world, bounds.x, bounds.y, bounds.width, bounds.height);\n    return this;\n  }\n  \n  update(delta: number) {\n    // Fixed timestep for consistent physics\n    Matter.Engine.update(this.engine, delta);\n  }\n  \n  // Test method\n  createTestBody(x: number, y: number) {\n    return Matter.Bodies.circle(x, y, 30, {\n      restitution: 0.8,\n      friction: 0.005\n    });\n  }\n}\n\n// 2. Main.ts physics configuration\nconst config = {\n  // ...other config\n  physics: {\n    default: 'matter',\n    matter: {\n      gravity: { y: 1 },\n      debug: true,\n      debugBodyColor: 0x0000ff\n    }\n  }\n};\n\n// 3. Usage in MainScene.ts\nimport { PhysicsManager } from '../physics/PhysicsManager';\n\nexport class MainScene extends Phaser.Scene {\n  private physicsManager: PhysicsManager;\n  \n  create() {\n    this.physicsManager = new PhysicsManager(this);\n    this.physicsManager.initializeEngine().createWorld();\n    \n    // Test physics\n    const testBody = this.physicsManager.createTestBody(400, 100);\n    Matter.World.add(this.physicsManager.world, testBody);\n  }\n  \n  update(time: number, delta: number) {\n    this.physicsManager.update(delta);\n  }\n}\n```\n</info added on 2025-04-22T19:48:06.966Z>",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 2,
          "title": "Implement Rocket as Physics Body",
          "description": "Create the rocket as a physics body with appropriate mass, shape, and physical properties.",
          "dependencies": [
            1
          ],
          "details": "1. Define the rocket's physical properties (mass, dimensions, moment of inertia)\n2. Create the rocket as a rigid body in the physics world\n3. Set appropriate collision properties (friction, restitution)\n4. Add methods to apply forces for rocket propulsion\n5. Implement rotation controls for the rocket\n6. Connect the physics body to the rocket's visual representation\n7. Test by applying forces and verifying the rocket moves according to physics rules",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 3,
          "title": "Implement Collision Detection System",
          "description": "Set up collision detection for the rocket with other objects in the physics world.",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Define collision categories for different types of objects\n2. Set up collision filters to control which objects can collide\n3. Create event listeners for collision events\n4. Implement collision response handlers\n5. Add methods to detect and respond to landing conditions\n6. Create a system to track collision data for game logic\n7. Test by creating test objects and verifying collision detection works correctly",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 4,
          "title": "Create Planetary Body with Gravity",
          "description": "Implement a basic planetary body that exists in the physics world and has its own gravity field.",
          "dependencies": [
            1
          ],
          "details": "1. Define the planetary body's physical properties (mass, radius)\n2. Create the planet as a static body in the physics world\n3. Add visual representation for the planet\n4. Create a method to calculate gravitational force based on distance\n5. Set up collision properties for the planet surface\n6. Implement a basic atmosphere effect (optional)\n7. Test by placing objects near the planet and verifying they're attracted to it\n\n<info added on 2025-04-22T20:15:25.364Z>\nFor implementing the planetary body with gravity, here's a detailed implementation plan:\n\n1. **Physics Implementation:**\n   ```typescript\n   // In constants.ts\n   export const GRAVITY_CONSTANT = 0.01; // Adjust based on desired strength\n\n   // In Planet.ts class\n   export class Planet {\n     body: MatterJS.Body;\n     radius: number;\n     mass: number;\n     scene: Phaser.Scene;\n     sprite: Phaser.GameObjects.Graphics;\n     \n     constructor(scene: Phaser.Scene, x: number, y: number, radius: number, mass: number) {\n       this.scene = scene;\n       this.radius = radius;\n       this.mass = mass;\n       \n       // Create visual representation\n       this.sprite = scene.add.graphics();\n       this.sprite.fillStyle(0x3366aa, 1);\n       this.sprite.fillCircle(0, 0, radius);\n       \n       // Create physics body\n       this.body = scene.matter.add.circle(x, y, radius, {\n         isStatic: true,\n         label: 'planet',\n         collisionFilter: {\n           category: CollisionCategory.GROUND,\n           mask: CollisionCategory.ROCKET | CollisionCategory.DEBRIS\n         }\n       });\n       \n       // Register update method for gravity calculations\n       scene.events.on('update', this.applyGravity, this);\n     }\n     \n     applyGravity() {\n       // Get all dynamic bodies in the scene\n       const bodies = this.scene.matter.world.localWorld.bodies.filter(b => !b.isStatic);\n       \n       bodies.forEach(body => {\n         const dx = this.body.position.x - body.position.x;\n         const dy = this.body.position.y - body.position.y;\n         const distance = Math.sqrt(dx * dx + dy * dy);\n         \n         if (distance > this.radius) { // Only apply gravity outside planet radius\n           const force = GRAVITY_CONSTANT * (this.mass * body.mass) / (distance * distance);\n           const angle = Math.atan2(dy, dx);\n           \n           this.scene.matter.world.engine.world.gravity.x = Math.cos(angle) * force;\n           this.scene.matter.world.engine.world.gravity.y = Math.sin(angle) * force;\n         }\n       });\n     }\n   }\n   ```\n\n2. **Atmosphere Effect:**\n   ```typescript\n   // Add to Planet class\n   createAtmosphere() {\n     const atmosphere = this.scene.add.graphics();\n     atmosphere.fillStyle(0x3366aa, 0.2);\n     atmosphere.fillCircle(this.body.position.x, this.body.position.y, this.radius * 1.2);\n     \n     // Add drag effect when objects are in atmosphere\n     this.scene.matter.world.on('beforeupdate', () => {\n       const bodies = this.scene.matter.world.localWorld.bodies.filter(b => !b.isStatic);\n       \n       bodies.forEach(body => {\n         const distance = Phaser.Math.Distance.Between(\n           this.body.position.x, this.body.position.y,\n           body.position.x, body.position.y\n         );\n         \n         if (distance < this.radius * 1.2 && distance > this.radius) {\n           // Apply drag force in atmosphere\n           const dragFactor = 0.98;\n           body.velocity.x *= dragFactor;\n           body.velocity.y *= dragFactor;\n         }\n       });\n     });\n   }\n   ```\n\n3. **Integration in MainScene:**\n   ```typescript\n   // In MainScene.create()\n   this.planet = new Planet(this, \n     this.cameras.main.centerX,\n     this.cameras.main.height + 200, // Position below screen\n     300, // Radius\n     1000 // Mass\n   );\n   \n   // Optional atmosphere\n   this.planet.createAtmosphere();\n   \n   // Disable default gravity\n   this.matter.world.engine.world.gravity.y = 0;\n   ```\n\n4. **Testing Method:**\n   ```typescript\n   // Add to MainScene\n   testPlanetGravity() {\n     // Create test objects at different positions\n     for (let i = 0; i < 5; i++) {\n       const testBody = this.matter.add.circle(\n         this.cameras.main.centerX + (i - 2) * 100,\n         100,\n         10,\n         { restitution: 0.8, frictionAir: 0.01 }\n       );\n       \n       // Add visual for test body\n       const visual = this.add.circle(0, 0, 10, 0xff0000);\n       this.matter.add.gameObject(testBody, visual);\n     }\n   }\n   ```\n</info added on 2025-04-22T20:15:25.364Z>",
          "status": "done",
          "parentTaskId": 3
        },
        {
          "id": 5,
          "title": "Implement Variable Gravity System",
          "description": "Create a system for variable gravity that changes based on distance to celestial bodies.",
          "dependencies": [
            1,
            2,
            4
          ],
          "details": "1. Create a gravity manager to track all gravity sources\n2. Implement the inverse square law for gravity calculation\n3. Add methods to calculate net gravitational force from multiple bodies\n4. Override the default world gravity with the variable gravity system\n5. Apply gravitational forces to the rocket in each physics step\n6. Add a debug visualization for gravity fields\n7. Test by moving the rocket around different celestial bodies and verifying gravity changes appropriately\n\n<info added on 2025-04-22T20:55:06.315Z>\nHere's the implementation plan to add:\n\n1. **Disable Default Gravity:** In `src/main.ts` Matter config, set `gravity: { x: 0, y: 0 }`.\n2. **Enhance `PhysicsManager`:**\n   - Add `gravitySources: { body: Matter.Body, mass: number }[] = [];` property.\n   - Add `registerGravitySource(body: Matter.Body, mass: number)` method.\n   - In constructor, add listener: `Matter.Events.on(this.engine, 'beforeupdate', this.applyCustomGravity.bind(this));`\n   - Create `applyCustomGravity()` method:\n     - Get dynamic bodies: `Matter.Composite.allBodies(this.world).filter(b => !b.isStatic);`\n     - Loop through dynamic bodies.\n     - Inside, loop through `gravitySources`.\n     - Calculate distance, vector, and inverse square law force (need a `GRAVITY_CONSTANT`).\n     - Apply force using `Matter.Body.applyForce(dynamicBody, dynamicBody.position, calculatedForceVector);`.\n3. **Update `MainScene.create()`:**\n   - Add `mass` property to planet body options.\n   - Call `this.physicsManager.registerGravitySource(this.planetBody, planetMass);`.\n4. **Test:** Verify rocket is pulled towards planet center.\n</info added on 2025-04-22T20:55:06.315Z>",
          "status": "done",
          "parentTaskId": 3
        }
      ]
    },
    {
      "id": 4,
      "title": "Implement Rocket Controls - Thrust and World Tilt",
      "description": "Develop the core control mechanisms: single-touch thrust and device tilt for world orientation.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Implement touch/click event listeners to activate the rocket's main thruster. Apply appropriate force to the rocket in its current facing direction when thrust is activated. Set up accelerometer API integration to detect device tilt. Translate tilt data into changes in the world's gravity direction. Implement fallback keyboard controls for desktop testing (e.g., arrow keys for tilt, spacebar for thrust). Add visual feedback for thrust activation (e.g., flame effect, particle system).",
      "testStrategy": "Test thrust activation on both touch and click events. Verify that the rocket moves in the correct direction when thrust is applied. Test accelerometer integration on mobile devices. Ensure the world tilts correctly in response to device movement. Verify fallback controls work properly on desktop."
    },
    {
      "id": 5,
      "title": "Implement Advanced Physics Features",
      "description": "Add air resistance, collision physics, and prepare for cargo physics implementation.",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "medium",
      "details": "Implement atmospheric density that increases closer to planetary surfaces. Create air resistance effects that affect rocket movement based on atmospheric density. Refine collision physics to make interactions between the rocket and terrain realistic. Set up the foundation for cargo physics by creating physics bodies that can be attached to the rocket. Implement a system to detect landing (successful vs. crash) based on velocity and orientation.",
      "testStrategy": "Test that air resistance increases appropriately near planetary surfaces. Verify that the rocket's movement is affected by atmospheric density. Test collision responses with different surfaces and at different velocities. Ensure the landing detection system correctly identifies successful landings versus crashes.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Atmospheric Density System",
          "description": "Create a system that calculates atmospheric density based on distance from planetary surfaces",
          "dependencies": [],
          "details": "Implementation steps:\n1. Define an atmospheric density curve that increases exponentially as objects get closer to planetary surfaces\n2. Create a function that calculates density based on altitude from planet surface\n3. Implement different density profiles for different planet types (e.g., Earth-like, gas giants, airless bodies)\n4. Add visualization helpers for debugging atmospheric density (optional)\n5. Create unit tests to verify density calculations at different altitudes\n\nTesting approach:\n- Test density values at various altitudes to ensure they follow expected curves\n- Verify edge cases (surface level, very high altitudes, transitions between space and atmosphere)\n\n<info added on 2025-04-23T20:15:44.278Z>\nFor the atmospheric density system, here's the additional implementation information:\n\nThe refactored approach moves density calculation responsibility to the Planet class through a new `getDensityAt(altitude)` method. This method implements a linear falloff model where:\n\n```javascript\n// Example implementation in Planet class\ngetDensityAt(altitude) {\n  const atmosphereHeight = this.atmosphereData.maxHeight;\n  if (altitude >= atmosphereHeight) return 0;\n  \n  // Linear falloff from surface (1.0) to edge of atmosphere (0.0)\n  return 1.0 - (altitude / atmosphereHeight);\n}\n```\n\nThe layered visual representation adds concentric semi-transparent shells around planets:\n- Inner layer: High density atmosphere (higher opacity, ~0.4 alpha)\n- Middle layer: Medium density (medium opacity, ~0.2 alpha)\n- Outer layer: Low density atmosphere (low opacity, ~0.1 alpha)\n\nEach layer uses a shader that applies appropriate coloration based on planet type (blue-white for Earth-like, orange-red for gas giants, etc.) and handles smooth transitions between layers.\n\nThis approach improves performance by avoiding expensive exponential calculations and provides better visual feedback during gameplay.\n</info added on 2025-04-23T20:15:44.278Z>",
          "status": "done",
          "parentTaskId": 5
        },
        {
          "id": 2,
          "title": "Add Air Resistance Physics",
          "description": "Implement air resistance effects that affect rocket movement based on atmospheric density",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a physics force calculator that applies drag forces to objects moving through atmosphere\n2. Calculate drag based on object velocity, cross-sectional area, and atmospheric density from subtask 1\n3. Implement drag coefficient properties for different object shapes\n4. Apply the calculated forces to the rocket's physics body\n5. Add visual effects for atmospheric entry (optional)\n\nTesting approach:\n- Test rocket deceleration in atmosphere at different velocities and altitudes\n- Verify that differently shaped objects experience appropriate levels of drag\n- Test extreme cases like high-speed atmospheric entry\n\n<info added on 2025-04-23T20:18:52.126Z>\nFor the drag force calculation, we'll use the standard aerodynamic drag equation: F_drag = 0.5 * C_d * Ï * A * v^2, where C_d is the drag coefficient, Ï is atmospheric density, A is cross-sectional area, and v is velocity.\n\nImplementation details:\n- In PhysicsManager.update(), query atmospheric density at rocket position using Planet.getDensityAt(position)\n- Calculate drag magnitude using F_drag = 0.5 * rocket.dragCoefficient * density * rocket.crossSectionalArea * velocity.magnitudeSquared()\n- Apply force in direction opposite to velocity: dragForce = -velocity.normalized() * dragMagnitude\n- Add configurable drag coefficients (C_d) for different rocket parts (0.8 for blunt objects, 0.2 for streamlined)\n- Implement cross-sectional area calculation based on rocket orientation relative to velocity vector\n- Add temperature increase calculation for high-speed atmospheric entry: temp += k * density * velocity^3 * deltaTime\n\nCode snippet for core implementation:\n```javascript\nfunction calculateDragForce(rocket, atmosphere) {\n  const density = atmosphere.getDensityAt(rocket.position);\n  const velocityMag = rocket.velocity.magnitude();\n  const dragCoef = rocket.getDragCoefficient(rocket.velocity);\n  const area = rocket.getEffectiveCrossSectionalArea(rocket.velocity);\n  \n  const dragMagnitude = 0.5 * dragCoef * density * area * velocityMag * velocityMag;\n  return rocket.velocity.normalized().multiplyScalar(-dragMagnitude);\n}\n```\n</info added on 2025-04-23T20:18:52.126Z>",
          "status": "done",
          "parentTaskId": 5
        },
        {
          "id": 3,
          "title": "Refine Collision Physics System",
          "description": "Enhance collision detection and response to create realistic interactions between rocket and terrain",
          "dependencies": [],
          "details": "Implementation steps:\n1. Improve collision detection precision for terrain interactions\n2. Implement material-based collision responses (e.g., metal-on-rock, metal-on-ice)\n3. Add impact force calculations based on velocity and angle of collision\n4. Create a system for structural integrity that responds to collision forces\n5. Add appropriate audio and visual feedback for different collision types\n\nTesting approach:\n- Test collisions at various speeds and angles\n- Verify that different terrain types produce appropriate collision responses\n- Test edge cases like grazing collisions and high-velocity impacts",
          "status": "pending",
          "parentTaskId": 5
        },
        {
          "id": 4,
          "title": "Implement Landing Detection System",
          "description": "Create a system to detect and classify landings as successful or crash based on velocity and orientation",
          "dependencies": [
            3
          ],
          "details": "Implementation steps:\n1. Define parameters for successful landing (max vertical/horizontal velocity, orientation angle range)\n2. Create a landing detection system that monitors rocket state during ground contact\n3. Implement classification logic to determine if a landing is successful or a crash\n4. Add appropriate game events and notifications for different landing outcomes\n5. Create a data logging system to record landing statistics\n\nTesting approach:\n- Test various landing scenarios (perfect landing, too fast, wrong angle)\n- Verify edge cases like landing on slopes or uneven terrain\n- Test that appropriate game events are triggered for different landing outcomes",
          "status": "pending",
          "parentTaskId": 5
        },
        {
          "id": 5,
          "title": "Set Up Cargo Physics Foundation",
          "description": "Create the foundation for cargo physics with attachable physics bodies for the rocket",
          "dependencies": [
            2,
            3
          ],
          "details": "Implementation steps:\n1. Design a cargo attachment system with connection points on the rocket\n2. Implement physics joints that can connect cargo to the rocket with realistic constraints\n3. Create cargo mass and inertia calculations that affect the rocket's flight dynamics\n4. Add cargo detachment mechanics for jettisoning or deploying payloads\n5. Implement air resistance effects on cargo items (using system from subtask 2)\n\nTesting approach:\n- Test rocket flight characteristics with different cargo configurations\n- Verify that cargo properly affects center of mass and flight stability\n- Test cargo attachment/detachment under various conditions\n- Verify that detached cargo interacts properly with atmosphere and gravity",
          "status": "pending",
          "parentTaskId": 5
        },
        {
          "id": 6,
          "title": "Implement Atmospheric Re-entry Heating Effect",
          "description": "Calculate and apply temperature increase to the rocket based on atmospheric density and velocity.",
          "details": "Implement temperature calculation `temp += k * density * velocity^3 * deltaTime`. Define heating coefficient `k`. Add `temperature` to `PlayerState` schema. Synchronize temperature. Add visual effects based on temperature.",
          "status": "pending",
          "dependencies": [
            "5.2"
          ],
          "parentTaskId": 5
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Cargo System and Physics",
      "description": "Create the cargo system with pickup, transport, and delivery mechanics.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "Design and implement cargo items as distinct physics entities. Create internal cargo bay mechanics for storing items. Implement external cargo attachment using constraints (ropes, springs) in the physics engine. Develop pickup mechanics that allow the player to collect cargo when in proximity. Create delivery mechanics that detect when cargo has been successfully transported to a destination. Implement visual feedback for cargo status (picked up, attached, delivered).",
      "testStrategy": "Test that cargo items behave as expected under physics simulation. Verify that cargo can be picked up when the rocket is in the correct position. Test that attached cargo affects the rocket's handling. Ensure cargo delivery is correctly detected when items reach their destination."
    },
    {
      "id": 7,
      "title": "Design and Implement Mission System",
      "description": "Create the mission structure with objectives, locations, and progression.",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "Design a mission data structure that includes start location, pickup point, delivery destination, and rewards. Implement a mission manager that tracks active missions and their status. Create location markers and landing zones for mission start points, pickup points, and destinations. Develop a mission UI that displays current objectives and progress. Implement mission completion logic that triggers rewards and unlocks new missions.",
      "testStrategy": "Test that missions can be loaded and displayed correctly. Verify that mission objectives are tracked properly. Test mission completion conditions and ensure rewards are granted. Ensure new missions become available after completing prerequisites."
    },
    {
      "id": 8,
      "title": "Create Game UI and Feedback Systems",
      "description": "Develop the user interface elements and feedback mechanisms for gameplay.",
      "status": "pending",
      "dependencies": [
        7
      ],
      "priority": "medium",
      "details": "Design and implement a heads-up display (HUD) showing relevant information (e.g., mission objectives). Create visual indicators for physics states (gravity strength, atmospheric density). Implement feedback for player actions (thrust activation, successful/failed landing). Design and implement mission briefing and completion screens. Add basic tutorial elements to explain controls and mechanics. Create a pause menu with options to restart or quit missions.",
      "testStrategy": "Verify that all UI elements display correctly across different screen sizes. Test that physics state indicators accurately reflect the game state. Ensure feedback is clear and timely for player actions. Test that mission screens and menus function as expected."
    },
    {
      "id": 9,
      "title": "Implement Basic Level Design and Progression",
      "description": "Create a set of initial levels with increasing complexity and implement progression mechanics.",
      "status": "pending",
      "dependencies": [
        7,
        8
      ],
      "priority": "low",
      "details": "Design at least 5 initial levels with varying terrain, gravity conditions, and mission objectives. Implement a level loading system that can instantiate different level configurations. Create a progression system that tracks completed missions and unlocks new locations. Design difficulty curve by gradually introducing more challenging physics scenarios. Implement a level selection interface if multiple missions are available simultaneously.",
      "testStrategy": "Test that each level loads correctly with its specific configuration. Verify that the progression system correctly tracks completed missions. Test that new locations and missions unlock as expected. Ensure the difficulty progression feels appropriate through playtesting."
    },
    {
      "id": 10,
      "title": "Implement Audio and Visual Polish",
      "description": "Add sound effects, basic visual effects, and polish the overall presentation.",
      "status": "pending",
      "dependencies": [
        8,
        9
      ],
      "priority": "low",
      "details": "Source or create 8-bit style sound effects for thrust, collisions, and mission events. Implement background music loops suitable for the space/retro theme. Add visual effects for key events (thrust, landing, mission completion). Improve the visual representation of the rocket, terrain, and objects using simple geometric shapes. Implement screen transitions between game states. Add basic animations for interactive elements.",
      "testStrategy": "Test that sound effects play correctly for corresponding game events. Verify that music loops seamlessly. Ensure visual effects enhance rather than distract from gameplay. Test the overall presentation for consistency and polish through user feedback."
    },
    {
      "id": 11,
      "title": "Implement Mouse Wheel Camera Zoom for Desktop Game View",
      "description": "Add a camera zoom feature to the main game view that allows players to zoom in and out using the mouse wheel. This functionality should be optimized for desktop environments.",
      "details": "Implement a smooth camera zoom system controlled by the mouse wheel scroll action. The zoom should be centered on the current mouse position to provide an intuitive experience. Key implementation points:\n\n1. Create a zoom controller that captures mouse wheel events (deltaY property)\n2. Define minimum and maximum zoom levels (suggested: 0.5x to 2.0x of default view)\n3. Implement smooth zoom transitions using interpolation (e.g., lerp function with configurable speed)\n4. Ensure the camera maintains focus on the point under the cursor during zoom\n5. Add a visual indicator showing current zoom level (optional)\n6. Implement zoom speed configuration (pixels per scroll unit)\n7. Handle edge cases such as zooming at map boundaries\n8. Add fallback controls for users without mouse wheels (e.g., keyboard shortcuts)\n9. Optimize performance by limiting zoom calculation frequency\n10. Ensure the feature only activates when the game view has focus\n\nThe implementation should use the existing camera system and integrate with the current rendering pipeline without introducing performance issues.",
      "testStrategy": "Testing should verify both functionality and user experience aspects of the zoom feature:\n\n1. Unit Tests:\n   - Verify zoom level changes correctly based on scroll input\n   - Confirm zoom stays within defined min/max boundaries\n   - Test that zoom center calculation works with different mouse positions\n\n2. Integration Tests:\n   - Ensure zoom works with all game view content types\n   - Verify performance remains stable during rapid zoom actions\n   - Test compatibility with other camera controls (pan, rotate)\n\n3. User Experience Tests:\n   - Conduct playtests to evaluate zoom smoothness and intuitiveness\n   - Test on various desktop configurations (different OS, mouse types)\n   - Verify zoom behavior at game boundaries and with different scene densities\n\n4. Edge Cases:\n   - Test behavior when rapidly scrolling\n   - Verify correct handling when switching between windows/losing focus\n   - Test with extremely large and small game worlds\n\nAcceptance Criteria: Zoom should feel smooth and intuitive, maintain 60+ FPS during zoom operations, correctly focus on mouse position, and work consistently across all supported desktop environments.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Mouse Wheel Event Capture and Basic Zoom Logic",
          "description": "Create the foundation for the zoom system by capturing mouse wheel events and implementing the basic zoom level adjustment logic.",
          "dependencies": [],
          "details": "1. Create a new ZoomController class/component that will handle all zoom functionality.\n2. Add event listeners for the 'wheel' event on the game canvas element.\n3. Extract the deltaY property from wheel events to determine zoom direction and intensity.\n4. Implement a zoom level variable that changes based on wheel input (increase/decrease).\n5. Define and enforce minimum (0.5x) and maximum (2.0x) zoom constraints.\n6. Add simple getter/setter methods for the zoom level.\n7. Test by logging zoom level changes to console when scrolling the mouse wheel.\n8. Ensure the controller only responds when the game view has focus by checking document.activeElement or similar.\n\n<info added on 2025-04-23T20:38:12.344Z>\n# Implementation Plan\n\n```typescript\n// src/game/controllers/ZoomController.ts\nexport class ZoomController {\n  private scene: Phaser.Scene;\n  private currentZoom: number = 1.0;\n  private readonly minZoom: number = 0.5;\n  private readonly maxZoom: number = 2.0;\n  private readonly zoomStep: number = 0.05;\n  \n  constructor(scene: Phaser.Scene) {\n    this.scene = scene;\n    this.init();\n  }\n  \n  private init(): void {\n    const canvas = this.scene.game.canvas;\n    canvas.addEventListener('wheel', this.handleWheelEvent.bind(this));\n  }\n  \n  private handleWheelEvent(event: WheelEvent): void {\n    // Only process wheel events when canvas has focus\n    if (document.activeElement !== this.scene.game.canvas) return;\n    \n    // Prevent default scrolling behavior\n    event.preventDefault();\n    \n    // Calculate new zoom level based on wheel direction\n    const zoomDirection = -Math.sign(event.deltaY);\n    const targetZoom = this.currentZoom + (zoomDirection * this.zoomStep);\n    \n    // Apply zoom constraints\n    this.currentZoom = Phaser.Math.Clamp(targetZoom, this.minZoom, this.maxZoom);\n    \n    console.log('Zoom level:', this.currentZoom);\n  }\n  \n  public getZoomLevel(): number {\n    return this.currentZoom;\n  }\n  \n  public setZoomLevel(level: number): void {\n    this.currentZoom = Phaser.Math.Clamp(level, this.minZoom, this.maxZoom);\n  }\n  \n  public destroy(): void {\n    // Clean up event listener when controller is destroyed\n    this.scene.game.canvas.removeEventListener('wheel', this.handleWheelEvent.bind(this));\n  }\n}\n```\n\nIntegration example in MainScene:\n```typescript\n// In MainScene.ts\nimport { ZoomController } from '../controllers/ZoomController';\n\n// Inside create() method\nthis.zoomController = new ZoomController(this);\n\n// In scene shutdown/destroy\nthis.zoomController.destroy();\n```\n</info added on 2025-04-23T20:38:12.344Z>\n\n<info added on 2025-04-23T20:38:45.479Z>\n<info added on 2025-04-24T15:22:45.000Z>\n## Performance Considerations\n\nWhen implementing the zoom controller, consider these performance optimizations:\n\n1. **Debounce wheel events**: Mouse wheel events fire rapidly, which can cause performance issues:\n\n```typescript\nprivate lastWheelEventTime: number = 0;\nprivate readonly wheelEventThreshold: number = 50; // ms\n\nprivate handleWheelEvent(event: WheelEvent): void {\n  // Skip processing if events are firing too rapidly\n  const now = Date.now();\n  if (now - this.lastWheelEventTime < this.wheelEventThreshold) return;\n  this.lastWheelEventTime = now;\n  \n  // Rest of wheel event handling...\n}\n```\n\n2. **Smooth zoom transitions**: For better UX, implement smooth zoom transitions rather than immediate jumps:\n\n```typescript\nprivate targetZoom: number = 1.0;\n\n// In your scene's update method\npublic update(time: number, delta: number): void {\n  // Smoothly interpolate current zoom toward target zoom\n  if (this.currentZoom !== this.targetZoom) {\n    const zoomSpeed = 0.1;\n    this.currentZoom = Phaser.Math.Linear(\n      this.currentZoom,\n      this.targetZoom,\n      zoomSpeed\n    );\n    \n    // Apply zoom to camera\n    this.scene.cameras.main.setZoom(this.currentZoom);\n  }\n}\n\n// Then in handleWheelEvent, set targetZoom instead of currentZoom\nthis.targetZoom = Phaser.Math.Clamp(targetZoom, this.minZoom, this.maxZoom);\n```\n\n3. **Zoom around cursor position**: For natural zooming behavior, implement zooming centered on cursor position:\n\n```typescript\nprivate zoomAroundCursor(newZoom: number): void {\n  const camera = this.scene.cameras.main;\n  const oldZoom = camera.zoom;\n  \n  // Get cursor position in world coordinates before zoom\n  const mouseX = this.scene.input.activePointer.worldX;\n  const mouseY = this.scene.input.activePointer.worldY;\n  \n  // Apply new zoom\n  camera.setZoom(newZoom);\n  \n  // Calculate offset to keep cursor at same world position\n  const zoomFactor = newZoom / oldZoom;\n  const newX = mouseX * zoomFactor;\n  const newY = mouseY * zoomFactor;\n  \n  // Adjust camera position\n  camera.scrollX += (mouseX - newX);\n  camera.scrollY += (mouseY - newY);\n}\n```\n\nRemember to call `this.zoomAroundCursor(this.currentZoom)` when applying zoom changes.\n</info added on 2025-04-24T15:22:45.000Z>\n</info added on 2025-04-23T20:38:45.479Z>\n\n<info added on 2025-04-23T20:45:43.704Z>\n## Implementation Notes and Fixes\n\nWhen implementing the ZoomController, I encountered and resolved these issues:\n\n1. **Canvas Focus Detection Issue**: The `document.activeElement` check was unreliable as the canvas element doesn't automatically receive focus even with proper tabindex. Modified the approach to use:\n\n```typescript\nprivate isCanvasHovered(): boolean {\n  const pointer = this.scene.input.activePointer;\n  const canvas = this.scene.game.canvas;\n  const rect = canvas.getBoundingClientRect();\n  \n  return pointer.x >= 0 && pointer.y >= 0 && \n         pointer.x <= canvas.width && pointer.y <= canvas.height;\n}\n```\n\n2. **Event Propagation**: Added passive event option to improve scrolling performance:\n\n```typescript\ncanvas.addEventListener('wheel', this.handleWheelEvent.bind(this), { passive: false });\n```\n\n3. **Memory Management**: Implemented proper event cleanup with a stored reference to the bound handler:\n\n```typescript\nprivate boundWheelHandler: (e: WheelEvent) => void;\n\nconstructor(scene: Phaser.Scene) {\n  this.scene = scene;\n  this.boundWheelHandler = this.handleWheelEvent.bind(this);\n  this.init();\n}\n\npublic destroy(): void {\n  this.scene.game.canvas.removeEventListener('wheel', this.boundWheelHandler);\n}\n```\n\n4. **Testing Results**: Verified zoom functionality works correctly across different browsers (Chrome, Firefox, Safari) with consistent behavior.\n</info added on 2025-04-23T20:45:43.704Z>",
          "status": "done",
          "parentTaskId": 11
        },
        {
          "id": 2,
          "title": "Implement Smooth Zoom Transitions with Interpolation",
          "description": "Add smooth interpolation between zoom levels to create a fluid zooming experience rather than abrupt changes.",
          "dependencies": [
            1
          ],
          "details": "1. Implement a target zoom level variable separate from the current zoom level.\n2. Create an update method that runs each frame to gradually adjust current zoom toward target zoom.\n3. Implement a lerp (linear interpolation) function: currentZoom = currentZoom + (targetZoom - currentZoom) * smoothFactor.\n4. Add a configurable smoothFactor parameter (suggested default: 0.1-0.2).\n5. Ensure the interpolation stops when the difference becomes negligible (to prevent floating-point issues).\n6. Test the smoothness by rapidly scrolling and observing the transition.\n7. Optimize the update method to limit calculations when no zoom change is occurring.\n8. Add a direct zoom method that bypasses interpolation for situations requiring immediate zoom changes.\n\n<info added on 2025-04-23T20:52:56.155Z>\n## Implementation Plan for Smooth Zoom\n\nHere's the plan to implement smooth zooming in `ZoomController.ts` and integrate it with `MainScene.ts`:\n\n**1. `ZoomController.ts` Modifications:**\n\n   - **Add Properties:**\n     ```typescript\n     private targetZoom: number = 1.0; // Target zoom level for interpolation\n     private readonly smoothFactor: number = 0.1; // Interpolation speed factor\n     private readonly epsilon: number = 0.001; // Threshold to stop interpolation\n     private boundWheelHandler: (e: WheelEvent) => void; // For correct listener removal\n     ```\n   - **Modify `constructor`:**\n     - Initialize `this.targetZoom = this.currentZoom;`.\n     - Store the bound event handler: `this.boundWheelHandler = this.handleWheelEvent.bind(this);`.\n   - **Modify `init`:**\n     - Use `this.boundWheelHandler` when adding the event listener.\n   - **Modify `handleWheelEvent`:**\n     - Instead of setting `this.currentZoom`, calculate the new target and set `this.targetZoom`:\n       ```typescript\n       const newTargetZoom = this.currentZoom + zoomDirection * this.zoomStep; // Use currentZoom here for calc\n       this.targetZoom = Phaser.Math.Clamp(newTargetZoom, this.minZoom, this.maxZoom);\n       // Remove console.log and camera application from here\n       ```\n   - **Add `update(delta: number)` Method:**\n     ```typescript\n     public update(delta: number): void {\n       // Adjust smooth factor based on delta time for frame rate independence\n       // Assuming 60 FPS (16.666ms per frame) as the baseline\n       const adjustedSmoothFactor = this.smoothFactor * (delta / 16.666);\n\n       // Check if current zoom is already close enough to the target\n       if (Math.abs(this.currentZoom - this.targetZoom) < this.epsilon) {\n         // Snap to target if very close to prevent floating point issues\n         if (this.currentZoom !== this.targetZoom) {\n            this.currentZoom = this.targetZoom;\n            this.scene.cameras.main.setZoom(this.currentZoom);\n            // console.log(`Zoom snapped to target: ${this.currentZoom.toFixed(3)}`); // Optional debug\n         }\n         return; // No need to interpolate further\n       }\n\n       // Interpolate current zoom towards the target zoom\n       this.currentZoom = Phaser.Math.Linear(\n         this.currentZoom,\n         this.targetZoom,\n         adjustedSmoothFactor\n       );\n\n       // Apply the interpolated zoom to the camera\n       this.scene.cameras.main.setZoom(this.currentZoom);\n       // console.log(`Zoom interpolating: Current=${this.currentZoom.toFixed(3)}, Target=${this.targetZoom.toFixed(3)}`); // Optional debug\n     }\n     ```\n   - **Modify `setZoomLevel`:**\n     - Set `this.targetZoom` instead of `this.currentZoom`.\n     - Remove the `console.log`.\n     ```typescript\n     public setZoomLevel(level: number): void {\n       this.targetZoom = Phaser.Math.Clamp(level, this.minZoom, this.maxZoom);\n     }\n     ```\n   - **Add `setZoomLevelImmediate(level: number)`:**\n     ```typescript\n     public setZoomLevelImmediate(level: number): void {\n       this.currentZoom = Phaser.Math.Clamp(level, this.minZoom, this.maxZoom);\n       this.targetZoom = this.currentZoom; // Sync target\n       this.scene.cameras.main.setZoom(this.currentZoom); // Apply immediately\n       console.log(\"Zoom set immediately to:\", this.currentZoom.toFixed(2));\n     }\n     ```\n   - **Modify `destroy`:**\n     - Use `this.boundWheelHandler` to remove the listener.\n\n**2. `MainScene.ts` Modifications:**\n\n   - **Modify `update(time: number, delta: number)`:**\n     - Add the call to the zoom controller's update method:\n       ```typescript\n       if (this.zoomController) {\n         this.zoomController.update(delta);\n       }\n       ```\n</info added on 2025-04-23T20:52:56.155Z>",
          "status": "done",
          "parentTaskId": 11
        },
        {
          "id": 4,
          "title": "Implement Zoom Speed Configuration and Keyboard Fallback Controls",
          "description": "Add customizable zoom speed settings and implement alternative zoom controls for users without mouse wheels.",
          "dependencies": [
            2
          ],
          "details": "1. Add a zoomSpeed configuration parameter to control sensitivity (pixels per scroll unit).\n2. Implement a method to change zoom speed at runtime and save preference.\n3. Add keyboard shortcut handlers for zooming (e.g., '+' and '-' keys or 'Ctrl+Up/Down').\n4. Ensure keyboard zooming uses the same smooth transition logic as mouse wheel zooming.\n5. For keyboard zooming, use the screen center as the zoom focus point instead of cursor position.\n6. Create a simple API to allow zooming programmatically from other game systems.\n7. Test both mouse wheel and keyboard controls, ensuring consistent behavior.\n8. Add configuration options to invert zoom direction for both mouse and keyboard if desired.",
          "status": "pending",
          "parentTaskId": 11
        },
        {
          "id": 5,
          "title": "Add Visual Zoom Indicator and Performance Optimization",
          "description": "Implement a visual indicator showing the current zoom level and optimize the zoom system for performance.",
          "dependencies": [
            1,
            2,
            4
          ],
          "details": "1. Create a simple UI element showing current zoom percentage (e.g., '100%', '150%', etc.).\n2. Make the indicator appear briefly when zoom changes and fade out after inactivity.\n3. Position the indicator in a non-intrusive corner of the screen.\n4. Implement throttling for wheel events to prevent excessive calculations (e.g., limit to one zoom adjustment per 50ms).\n5. Add a small buffer zone around map edges to prevent zooming when it would push view beyond boundaries.\n6. Optimize the update loop to skip calculations when zoom is not changing.\n7. Add an option to disable the zoom feature entirely for performance-critical situations.\n8. Test the system under various performance conditions to ensure smooth operation.\n9. Implement proper cleanup methods to remove event listeners when the controller is destroyed.",
          "status": "pending",
          "parentTaskId": 11
        }
      ]
    },
    {
      "id": 12,
      "title": "Implement Colyseus Multiplayer Client Integration",
      "description": "Integrate the Colyseus client library into our application to enable real-time multiplayer functionality. This includes setting up connection handling, state synchronization, and message passing within a single predefined game room.",
      "details": "This task involves implementing the client-side integration with Colyseus multiplayer framework using a single-session approach:\n\n1. Install the Colyseus client library using npm: `npm install colyseus.js`\n\n2. Create a multiplayer service class that will handle:\n   - Connection establishment and management to the Colyseus server\n   - Automatic joining of the predefined 'game_room'\n   - State synchronization and delta handling\n   - Message sending and receiving\n   - Reconnection logic\n\n3. Implement event listeners for key Colyseus events:\n   - onJoin: When successfully connected to the game room\n   - onLeave: When disconnected from the game room\n   - onStateChange: When room state changes\n   - onError: For handling connection and runtime errors\n\n4. Create a client-side room state model that mirrors the server-side schema, focusing on player state\n\n5. Implement methods for sending player state updates to the server using room.send()\n\n6. Add connection status indicators in the UI to show players when they're connected/disconnected\n\n7. Implement proper error handling and user feedback for connection issues\n\n8. Add configuration options for different environments (development, staging, production)\n\nEnsure the implementation follows a clean architecture pattern where game logic is separated from the networking layer. The client should be able to handle network interruptions gracefully with automatic reconnection attempts.",
      "testStrategy": "Testing should verify the correct implementation of the Colyseus client integration:\n\n1. Unit Tests:\n   - Test the multiplayer service class methods with mocked Colyseus client\n   - Verify proper event handling for all Colyseus events\n   - Test reconnection logic works as expected\n\n2. Integration Tests:\n   - Set up a test Colyseus server instance with the predefined 'game_room'\n   - Verify client can successfully connect to the server and join the room\n   - Verify state synchronization works correctly\n   - Test message sending and receiving between client and server\n\n3. Manual Testing:\n   - Connect multiple clients to the 'game_room' and verify they can see each other\n   - Test disconnection scenarios (server shutdown, network interruption)\n   - Verify reconnection works properly without data loss\n   - Test with different network conditions (high latency, packet loss) using network throttling\n\n4. Performance Testing:\n   - Measure connection establishment time\n   - Evaluate state synchronization performance with many entities\n   - Test with maximum expected number of simultaneous clients in the single room\n\nDocument all test results and any edge cases discovered during testing.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Colyseus client library and create multiplayer service",
          "description": "Install the Colyseus client library and create a base multiplayer service class with connection management functionality.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Install Colyseus client library using npm: `npm install colyseus.js`\n2. Create a MultiplayerService class with the following methods:\n   - connect(): Establishes connection to the Colyseus server at ws://localhost:2567 and automatically joins the predefined 'game_room'\n   - disconnect(): Properly closes the connection\n   - isConnected(): Returns connection status\n3. Implement connection configuration for different environments (dev, staging, prod)\n4. Add basic error handling for connection issues\n5. Create connection status indicators (connected/disconnected)\n\nTesting approach:\n- Create unit tests for the service using a mock server\n- Test connection establishment and disconnection\n- Verify environment configuration loading works correctly\n- Test automatic joining of the predefined 'game_room'\n\n<info added on 2025-04-23T21:26:27.708Z>\nHere's additional implementation information for the MultiplayerService:\n\n```typescript\n// Environment configuration implementation\nprivate loadEnvironmentConfig(): void {\n  // Load from environment variables or config file\n  const env = process.env.NODE_ENV || 'development';\n  \n  switch(env) {\n    case 'production':\n      this.serverUrl = process.env.COLYSEUS_SERVER_URL || 'wss://game-server.example.com';\n      break;\n    case 'staging':\n      this.serverUrl = process.env.COLYSEUS_SERVER_URL || 'wss://staging-game-server.example.com';\n      break;\n    default: // development\n      this.serverUrl = process.env.COLYSEUS_SERVER_URL || 'ws://localhost:2567';\n  }\n  \n  // Allow room name override from environment\n  this.roomName = process.env.COLYSEUS_ROOM_NAME || 'game_room';\n}\n```\n\nFor connection status indicators:\n\n```typescript\n// Add to MultiplayerService class\nprivate statusListeners: Array<(status: 'disconnected' | 'connecting' | 'connected' | 'error') => void> = [];\n\npublic addStatusListener(callback: (status: 'disconnected' | 'connecting' | 'connected' | 'error') => void): void {\n  this.statusListeners.push(callback);\n}\n\npublic removeStatusListener(callback: (status: 'disconnected' | 'connecting' | 'connected' | 'error') => void): void {\n  const index = this.statusListeners.indexOf(callback);\n  if (index !== -1) {\n    this.statusListeners.splice(index, 1);\n  }\n}\n\n// Update the setter for connectionStatus\nprivate setConnectionStatus(status: 'disconnected' | 'connecting' | 'connected' | 'error'): void {\n  this.connectionStatus = status;\n  // Notify all listeners\n  this.statusListeners.forEach(listener => listener(status));\n}\n```\n\nFor reconnection handling:\n\n```typescript\nprivate reconnectAttempts = 0;\nprivate maxReconnectAttempts = 5;\nprivate reconnectTimeout: NodeJS.Timeout | null = null;\n\npublic async attemptReconnect(): Promise<void> {\n  if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n    console.error(`MultiplayerService: Maximum reconnection attempts (${this.maxReconnectAttempts}) reached.`);\n    return;\n  }\n  \n  this.reconnectAttempts++;\n  const backoffTime = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 30000);\n  \n  console.log(`MultiplayerService: Attempting reconnect ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${backoffTime}ms`);\n  \n  this.reconnectTimeout = setTimeout(async () => {\n    try {\n      await this.connect();\n      if (this.isConnected()) {\n        this.reconnectAttempts = 0;\n      }\n    } catch (e) {\n      console.error(\"MultiplayerService: Reconnection attempt failed:\", e);\n    }\n  }, backoffTime);\n}\n```\n\nExample unit test structure:\n\n```typescript\n// tests/services/MultiplayerService.test.ts\nimport { MultiplayerService } from '../../src/services/MultiplayerService';\nimport { Server, Room } from 'colyseus.server-mock';\n\ndescribe('MultiplayerService', () => {\n  let service: MultiplayerService;\n  let mockServer: Server;\n  \n  beforeEach(() => {\n    // Setup mock Colyseus server\n    mockServer = new Server();\n    mockServer.define('game_room', Room);\n    mockServer.listen(2567);\n    \n    service = new MultiplayerService();\n  });\n  \n  afterEach(() => {\n    service.disconnect();\n    mockServer.shutdown();\n  });\n  \n  test('should connect to server successfully', async () => {\n    await service.connect();\n    expect(service.isConnected()).toBe(true);\n  });\n  \n  test('should handle disconnection properly', async () => {\n    await service.connect();\n    service.disconnect();\n    expect(service.isConnected()).toBe(false);\n  });\n  \n  test('should notify status listeners on connection state changes', async () => {\n    const statusCallback = jest.fn();\n    service.addStatusListener(statusCallback);\n    \n    await service.connect();\n    expect(statusCallback).toHaveBeenCalledWith('connecting');\n    expect(statusCallback).toHaveBeenCalledWith('connected');\n    \n    service.disconnect();\n    expect(statusCallback).toHaveBeenCalledWith('disconnected');\n  });\n});\n```\n</info added on 2025-04-23T21:26:27.708Z>\n\n<info added on 2025-04-23T21:28:53.661Z>\nHere's additional information about implementing connection status indicators:\n\n```typescript\n// Define a type for connection status for better type safety\nexport type ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'error';\n\n// Add to MultiplayerService class\nexport class MultiplayerService {\n  // ... existing code\n\n  // UI integration methods for connection status\n  public getStatusColorCode(status: ConnectionStatus): string {\n    switch(status) {\n      case 'connected': return '#4CAF50'; // Green\n      case 'connecting': return '#FFC107'; // Amber\n      case 'disconnected': return '#9E9E9E'; // Gray\n      case 'error': return '#F44336'; // Red\n      default: return '#9E9E9E';\n    }\n  }\n\n  public getStatusDisplayText(status: ConnectionStatus): string {\n    switch(status) {\n      case 'connected': return 'Connected to game server';\n      case 'connecting': return 'Connecting to game server...';\n      case 'disconnected': return 'Disconnected from game server';\n      case 'error': return 'Connection error';\n      default: return 'Unknown status';\n    }\n  }\n\n  // Connection monitoring\n  private setupConnectionMonitoring(): void {\n    // Ping server every 30 seconds to verify connection is still alive\n    this.pingInterval = setInterval(() => {\n      if (this.client && this.room) {\n        try {\n          this.room.send('ping');\n          this.lastPingTime = Date.now();\n        } catch (e) {\n          console.warn('Failed to ping server:', e);\n          if (this.connectionStatus === 'connected') {\n            this.setConnectionStatus('error');\n            this.attemptReconnect();\n          }\n        }\n      }\n    }, 30000);\n  }\n\n  // Cleanup method\n  public destroy(): void {\n    this.disconnect();\n    this.statusListeners = [];\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n  }\n\n  // Example usage in a React component\n  /*\n  // In a React component:\n  useEffect(() => {\n    const handleStatusChange = (status: ConnectionStatus) => {\n      setConnectionStatus(status);\n    };\n    \n    multiplayerService.addStatusListener(handleStatusChange);\n    \n    return () => {\n      multiplayerService.removeStatusListener(handleStatusChange);\n    };\n  }, []);\n  \n  return (\n    <div \n      style={{ \n        color: multiplayerService.getStatusColorCode(connectionStatus),\n        padding: '8px',\n        borderRadius: '4px',\n        display: 'inline-block'\n      }}\n    >\n      {multiplayerService.getStatusDisplayText(connectionStatus)}\n    </div>\n  );\n  */\n}\n```\n</info added on 2025-04-23T21:28:53.661Z>",
          "status": "done",
          "parentTaskId": 12
        },
        {
          "id": 3,
          "title": "Create client-side room state model and state synchronization",
          "description": "Define the client-side state model that mirrors the server schema and implement state synchronization functionality.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a player state schema with properties: id, x, y, angle, cargo\n2. Implement the following in MultiplayerService:\n   - onStateChange event handler to process state updates\n   - getState(): Returns current synchronized state\n   - applyPatch(patch): Applies delta updates to local state\n3. Add state validation to ensure data integrity\n4. Implement optimistic updates for local player actions\n5. Set up listeners for player joining, leaving, and state changes within the 'game_room'\n\nTesting approach:\n- Create unit tests for state synchronization\n- Test delta patching with various state changes\n- Verify state validation correctly identifies invalid states\n- Test optimistic updates and reconciliation\n- Verify correct handling of players joining and leaving the room\n\n<info added on 2025-04-23T21:33:47.889Z>\n## State Synchronization Implementation Plan\n\nFollowing the creation of `State.ts`:\n\n1.  **Import State Types:** In `MultiplayerService.ts`, import `RoomState` and `PlayerState`.\n2.  **Update Room Type:** Change `private room: Colyseus.Room<any> | null = null;` to `private room: Colyseus.Room<RoomState> | null = null;`.\n3.  **Local State Storage:** Add `private players: Map<string, PlayerState> = new Map();`.\n4.  **Listener Registration:**\n    *   Define callback types: `PlayerAddListener`, `PlayerUpdateListener`, `PlayerRemoveListener`.\n    *   Add private arrays: `playerAddListeners`, `playerUpdateListeners`, `playerRemoveListeners`.\n    *   Add public methods: `addPlayerAddListener`, `addPlayerUpdateListener`, `addPlayerRemoveListener` (and corresponding remove methods).\n    *   Add private notification methods: `notifyPlayerAdded`, `notifyPlayerUpdated`, `notifyPlayerRemoved`.\n5.  **Implement `setupRoomListeners`:**\n    *   Attach `this.room.onStateChange((state) => { ... });`.\n    *   Inside `onStateChange` (first time setup):\n        *   Attach `state.players.onAdd = (player, key) => { ... };`\n            *   Store `player` in the local `this.players` map (using `key` as the ID).\n            *   Call `this.notifyPlayerAdded(key, player);`.\n            *   Crucially, check if `key === this.room?.sessionId` to identify the local player and potentially skip notification or handle differently.\n        *   Attach `state.players.onChange = (player, key) => { ... };`\n            *   Update the local `this.players` map.\n            *   Call `this.notifyPlayerUpdated(key, player);` (Note: Colyseus schema `onChange` provides the full updated object, not just changes, usually. We might need to diff or just pass the full state).\n        *   Attach `state.players.onRemove = (player, key) => { ... };`\n            *   Remove player from the local `this.players` map.\n            *   Call `this.notifyPlayerRemoved(key);`.\n    *   Handle potential initial state iteration if needed when `onStateChange` first fires.\n</info added on 2025-04-23T21:33:47.889Z>\n\n<info added on 2025-04-23T21:36:20.438Z>\n## Player State Access Methods\n\nFor the MultiplayerService, implement these additional methods to access player state:\n\n```typescript\n/**\n * Returns a Map containing all current player states\n * @returns Map of player IDs to PlayerState objects\n */\npublic getAllPlayersState(): Map<string, PlayerState> {\n  // Return a copy to prevent external modification of internal state\n  return new Map(this.players);\n}\n\n/**\n * Get a specific player's state by ID\n * @param playerId The player's session ID\n * @returns PlayerState or undefined if player not found\n */\npublic getPlayerState(playerId: string): PlayerState | undefined {\n  return this.players.get(playerId);\n}\n\n/**\n * Get the local player's state\n * @returns The local player's state or undefined if not connected\n */\npublic getLocalPlayerState(): PlayerState | undefined {\n  if (!this.room?.sessionId) return undefined;\n  return this.players.get(this.room.sessionId);\n}\n```\n\nThese methods provide controlled access to player state data while maintaining encapsulation of the internal players Map.\n</info added on 2025-04-23T21:36:20.438Z>",
          "status": "done",
          "parentTaskId": 12
        },
        {
          "id": 4,
          "title": "Implement message sending functionality",
          "description": "Add methods for sending the local player's state updates to the server periodically.",
          "dependencies": [
            3
          ],
          "details": "Implementation steps:\n1. Add the following methods to MultiplayerService:\n   - sendPlayerState(state): Sends the local player's state (x, y, angle, cargo) to the server using room.send('updateState', state)\n   - startStateSync(interval): Begins sending periodic state updates at the specified interval (default: 100ms)\n   - stopStateSync(): Stops the periodic state updates\n2. Implement message validation before sending\n3. Add error handling for message sending failures\n4. Optimize state updates to only send when changes occur\n\nTesting approach:\n- Test state sending with various player states\n- Verify periodic updates are sent at the correct interval\n- Test optimization to ensure updates are only sent when needed\n- Verify error handling works correctly for failed sends\n\n<info added on 2025-04-23T21:37:46.282Z>\n## Message Sending Implementation Details\n\nFor the state validation before sending:\n```typescript\nprivate validateState(state: Partial<PlayerState>): boolean {\n  // Check for required properties\n  if (state.x === undefined || state.y === undefined || state.angle === undefined) {\n    console.warn('Invalid player state: missing required properties');\n    return false;\n  }\n  \n  // Validate value ranges\n  if (isNaN(state.x) || isNaN(state.y) || isNaN(state.angle)) {\n    console.warn('Invalid player state: NaN values detected');\n    return false;\n  }\n  \n  return true;\n}\n```\n\nFor the optimization to only send when changes occur:\n```typescript\nprivate lastSentState: PlayerState = null;\n\npublic sendPlayerState(state: Partial<PlayerState>): boolean {\n  // Only send if state has changed significantly\n  if (this.lastSentState && this.isStateSimilar(state, this.lastSentState)) {\n    return false; // No need to send\n  }\n  \n  // Validation and sending logic...\n  \n  // Store last sent state for comparison\n  this.lastSentState = {...state};\n  return true;\n}\n\nprivate isStateSimilar(newState: Partial<PlayerState>, oldState: PlayerState): boolean {\n  // Define thresholds for significant changes\n  const positionThreshold = 0.5; // 0.5 pixels\n  const angleThreshold = 0.05; // ~3 degrees\n  \n  return (\n    Math.abs(newState.x - oldState.x) < positionThreshold &&\n    Math.abs(newState.y - oldState.y) < positionThreshold &&\n    Math.abs(newState.angle - oldState.angle) < angleThreshold &&\n    newState.cargo === oldState.cargo\n  );\n}\n```\n\nFor error handling implementation:\n```typescript\npublic sendPlayerState(state: Partial<PlayerState>): boolean {\n  if (!this.isConnected()) {\n    this.eventEmitter.emit('connection:error', 'Cannot send state: not connected');\n    return false;\n  }\n  \n  if (!this.validateState(state)) {\n    return false;\n  }\n  \n  try {\n    this.room.send(\"updateState\", state);\n    return true;\n  } catch (error) {\n    console.error('Failed to send player state:', error);\n    this.eventEmitter.emit('message:error', error);\n    return false;\n  }\n}\n```\n</info added on 2025-04-23T21:37:46.282Z>",
          "status": "done",
          "parentTaskId": 12
        },
        {
          "id": 5,
          "title": "Implement basic single-room Colyseus server & Phaser integration",
          "description": "Create a basic Colyseus server with a single game room and integrate the multiplayer service with the Phaser game engine.",
          "dependencies": [
            1,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Create a basic Colyseus server (Node.js/TypeScript):\n   - Define a GameRoom class extending Colyseus Room, registered as 'game_room'\n   - Create a schema for player state (id, x, y, angle, cargo)\n   - Implement onJoin to assign session ID and add player to state\n   - Implement onLeave to remove player from state\n   - Add message handler for 'updateState' to update player state\n   - Configure server to allow anonymous connections\n2. Integrate MultiplayerService with Phaser's MainScene:\n   - Initialize and connect the MultiplayerService\n   - Start periodic state sending for the local player\n   - Use state change listeners (onAdd, onChange, onRemove) to:\n     * Create sprites for new remote players\n     * Update positions of existing remote players\n     * Remove sprites for disconnected players\n3. Implement interpolation for smooth remote player movement\n4. Add visual indicators for connection status in the UI\n\nTesting approach:\n- Test end-to-end functionality with multiple clients\n- Verify player movements are correctly synchronized\n- Test disconnection and reconnection scenarios\n- Verify server correctly handles player joining and leaving\n- Test interpolation provides smooth movement for remote players\n\n<info added on 2025-04-23T21:44:06.078Z>\n## Phaser Integration Plan\n\nIntegrating `MultiplayerService` into `MainScene.ts`:\n\n1.  **Import:** `MultiplayerService` from `../../services/MultiplayerService` and `PlayerState` from `../../colyseus/schema/State`.\n2.  **Add Properties:**\n    *   `private multiplayerService!: MultiplayerService;`\n    *   `private remotePlayers: Map<string, Phaser.GameObjects.GameObject> = new Map();`\n    *   `private lastStateSendTime: number = 0;`\n    *   `private readonly stateSendInterval: number = 100; // ms`\n3.  **In `create()`:**\n    *   Instantiate `MultiplayerService`.\n    *   Call `connect()`.\n    *   Register `handlePlayerAdd`, `handlePlayerUpdate`, `handlePlayerRemove` using the service's listener methods.\n4.  **Implement Listener Callbacks:**\n    *   `handlePlayerAdd(playerId, state)`: Creates a `Phaser.GameObjects.Rectangle` at `state.x`, `state.y`, sets its angle, adds it to the scene, and stores it in `remotePlayers` map using `playerId`.\n    *   `handlePlayerUpdate(playerId, state)`: Finds the corresponding GameObject in `remotePlayers`, updates its `x`, `y`, and `angle`.\n    *   `handlePlayerRemove(playerId)`: Finds the GameObject, calls `destroy()`, and removes it from the `remotePlayers` map.\n5.  **In `update(time, delta)`:**\n    *   Check timer: `if (time > this.lastStateSendTime + this.stateSendInterval)`.\n    *   Inside check: Get local rocket state (`this.rocket.body.position.x`, `this.rocket.body.position.y`, `this.rocket.body.angle`), create state object `Partial<PlayerState>`. Call `this.multiplayerService.sendPlayerState(localState)`. Update `this.lastStateSendTime`.\n6.  **In `shutdown()`:**\n    *   Call `this.multiplayerService.disconnect();`.\n\n**Next steps (after this edit):** Implement interpolation and connection status UI.\n</info added on 2025-04-23T21:44:06.078Z>\n\n<info added on 2025-04-23T21:46:50.361Z>\n## Interpolation Implementation Plan\n\n1.  **Update `remotePlayers` Map:** Change type to `Map<string, { visual: Phaser.GameObjects.Rectangle; targetX: number; targetY: number; targetAngle: number; }>`.\n2.  **Modify `handlePlayerAdd`:** Store initial state in `targetX`, `targetY`, `targetAngle` when creating the map entry.\n3.  **Modify `handlePlayerUpdate`:** Update `targetX`, `targetY`, `targetAngle` in the map entry instead of setting visual properties directly.\n4.  **Add Interpolation Logic to `MainScene.update()`:**\n    *   Iterate `remotePlayers`.\n    *   Get `visual`, `targetX`, `targetY`, `targetAngle`.\n    *   Calculate `lerpFactor = 0.2 * (delta / 16.666)` (example).\n    *   `visual.x = Phaser.Math.Linear(visual.x, targetX, lerpFactor);`\n    *   `visual.y = Phaser.Math.Linear(visual.y, targetY, lerpFactor);`\n    *   `visual.angle = Phaser.Math.Angle.RotateTo(visual.angle, Phaser.Math.RadToDeg(targetAngle), lerpFactor);` // Use RotateTo for angle interpolation\n</info added on 2025-04-23T21:46:50.361Z>\n\n<info added on 2025-04-23T21:48:18.304Z>\n## Connection Status UI Plan\n\n1. **Define ConnectionStatus Enum:**\n   ```typescript\n   // In MultiplayerService.ts\n   export enum ConnectionStatus {\n     DISCONNECTED = 'disconnected',\n     CONNECTING = 'connecting',\n     CONNECTED = 'connected',\n     RECONNECTING = 'reconnecting',\n     ERROR = 'error'\n   }\n   ```\n\n2. **Add Status Management to MultiplayerService:**\n   ```typescript\n   private status: ConnectionStatus = ConnectionStatus.DISCONNECTED;\n   private statusListeners: ((status: ConnectionStatus) => void)[] = [];\n   \n   public addStatusListener(callback: (status: ConnectionStatus) => void): void {\n     this.statusListeners.push(callback);\n     // Immediately notify with current status\n     callback(this.status);\n   }\n   \n   private updateStatus(newStatus: ConnectionStatus): void {\n     this.status = newStatus;\n     this.statusListeners.forEach(listener => listener(newStatus));\n   }\n   ```\n\n3. **UI Implementation in MainScene:**\n   ```typescript\n   private connectionStatusText!: Phaser.GameObjects.Text;\n   \n   // In create():\n   this.connectionStatusText = this.add.text(10, 10, 'Status: Disconnected', {\n     fontSize: '16px',\n     color: '#ff0000',\n     backgroundColor: 'rgba(0,0,0,0.5)',\n     padding: { x: 5, y: 5 }\n   }).setScrollFactor(0).setDepth(100);\n   \n   handleConnectionStatusChange(status: ConnectionStatus): void {\n     let color = '#ff0000';\n     switch(status) {\n       case ConnectionStatus.CONNECTED:\n         color = '#00ff00';\n         break;\n       case ConnectionStatus.CONNECTING:\n       case ConnectionStatus.RECONNECTING:\n         color = '#ffff00';\n         break;\n     }\n     this.connectionStatusText.setText(`Status: ${status}`);\n     this.connectionStatusText.setColor(color);\n   }\n   ```\n\n4. **Add Status Updates in MultiplayerService Methods:**\n   ```typescript\n   async connect(): Promise<void> {\n     this.updateStatus(ConnectionStatus.CONNECTING);\n     try {\n       // existing connection code\n       this.updateStatus(ConnectionStatus.CONNECTED);\n     } catch (error) {\n       this.updateStatus(ConnectionStatus.ERROR);\n       throw error;\n     }\n   }\n   \n   disconnect(): void {\n     // existing disconnect code\n     this.updateStatus(ConnectionStatus.DISCONNECTED);\n   }\n   ```\n\n5. **Add Reconnection Logic:**\n   ```typescript\n   // In MultiplayerService\n   private setupReconnection(): void {\n     this.client.onClose.once(() => {\n       if (this.status !== ConnectionStatus.DISCONNECTED) {\n         this.updateStatus(ConnectionStatus.RECONNECTING);\n         this.attemptReconnect();\n       }\n     });\n   }\n   \n   private async attemptReconnect(attempts = 0): Promise<void> {\n     if (attempts >= 5) {\n       this.updateStatus(ConnectionStatus.ERROR);\n       return;\n     }\n     \n     try {\n       await this.connect();\n     } catch (error) {\n       setTimeout(() => this.attemptReconnect(attempts + 1), 2000);\n     }\n   }\n   ```\n</info added on 2025-04-23T21:48:18.304Z>\n\n<info added on 2025-04-23T22:08:11.803Z>\n## Server-Side Planet Management Implementation\n\n1. **Extend Room State Schema:**\n   ```typescript\n   // In schema/State.ts\n   export class PlanetState extends Schema {\n     @type(\"string\") id: string;\n     @type(\"number\") x: number;\n     @type(\"number\") y: number;\n     @type(\"number\") radius: number;\n     @type(\"string\") textureKey: string;\n     @type(\"number\") mass: number;\n   }\n\n   export class GameState extends Schema {\n     @type({ map: PlayerState }) players = new MapSchema<PlayerState>();\n     @type({ map: PlanetState }) planets = new MapSchema<PlanetState>();\n   }\n   ```\n\n2. **Initialize Planets in GameRoom:**\n   ```typescript\n   // In rooms/GameRoom.ts\n   import { planetConfigurations } from \"../config/PlanetConfig\";\n\n   // Inside onCreate method\n   onCreate() {\n     this.setState(new GameState());\n     \n     // Initialize planets from configuration\n     planetConfigurations.forEach(config => {\n       const planet = new PlanetState();\n       planet.id = config.id;\n       planet.x = config.position.x;\n       planet.y = config.position.y;\n       planet.radius = config.radius;\n       planet.textureKey = config.textureKey;\n       planet.mass = config.mass;\n       \n       this.state.planets.set(planet.id, planet);\n     });\n   }\n   ```\n\n3. **MultiplayerService Planet Handling:**\n   ```typescript\n   // In MultiplayerService.ts\n   import { PlanetState } from '../colyseus/schema/State';\n\n   // Add these properties\n   private planetAddListeners: Map<string, (id: string, data: PlanetState) => void> = new Map();\n   private planetRemoveListeners: Map<string, (id: string) => void> = new Map();\n   \n   // Add these methods\n   public onPlanetAdd(id: string, callback: (id: string, data: PlanetState) => void): void {\n     this.planetAddListeners.set(id, callback);\n     \n     // If already connected, notify about existing planets\n     if (this.room) {\n       this.room.state.planets.forEach((planet, planetId) => {\n         callback(planetId, planet);\n       });\n     }\n   }\n   \n   public onPlanetRemove(id: string, callback: (id: string) => void): void {\n     this.planetRemoveListeners.set(id, callback);\n   }\n   \n   // In connect method, add:\n   this.room.state.planets.onAdd = (planet, planetId) => {\n     this.planetAddListeners.forEach(listener => listener(planetId, planet));\n   };\n   \n   this.room.state.planets.onRemove = (_, planetId) => {\n     this.planetRemoveListeners.forEach(listener => listener(planetId));\n   };\n   ```\n\n4. **MainScene Planet Integration:**\n   ```typescript\n   // In MainScene.ts\n   private planets: Map<string, Phaser.GameObjects.Sprite> = new Map();\n   \n   // In create method:\n   this.multiplayerService.onPlanetAdd('mainScene', (planetId, planetData) => {\n     // Create planet sprite\n     const planetSprite = this.add.sprite(\n       planetData.x, \n       planetData.y, \n       planetData.textureKey\n     );\n     planetSprite.setDisplaySize(planetData.radius * 2, planetData.radius * 2);\n     \n     // Store reference\n     this.planets.set(planetId, planetSprite);\n     \n     // Note: Physics interactions would be added here in a future task\n   });\n   \n   this.multiplayerService.onPlanetRemove('mainScene', (planetId) => {\n     const planet = this.planets.get(planetId);\n     if (planet) {\n       planet.destroy();\n       this.planets.delete(planetId);\n     }\n   });\n   \n   // In shutdown method:\n   this.multiplayerService.onPlanetAdd('mainScene', null);\n   this.multiplayerService.onPlanetRemove('mainScene', null);\n   ```\n\nThis implementation ensures planets are managed by the server and synchronized across all clients, providing a consistent game world for all players.\n</info added on 2025-04-23T22:08:11.803Z>\n\n<info added on 2025-04-23T22:58:06.029Z>\n## Physics Manager Integration with Synchronized Planet Data\n\n```typescript\n// In PhysicsManager.ts\nprivate planetObjectsMap: Map<string, { sprite: Phaser.GameObjects.Sprite; body: Phaser.Physics.Arcade.Body; data: PlanetState }> = new Map();\n\n// Method to receive the planet objects map from MainScene\npublic setPlanetObjectsMap(map: Map<string, { sprite: Phaser.GameObjects.Sprite; body: Phaser.Physics.Arcade.Body; data: PlanetState }>): void {\n  this.planetObjectsMap = map;\n}\n\n// Updated addGravitySource to use PlanetState data\npublic addGravitySource(\n  id: string, \n  body: Phaser.Physics.Arcade.Body, \n  planetData: PlanetState\n): void {\n  this.gravitySources.set(id, {\n    body,\n    mass: planetData.mass,\n    atmosphereHeight: planetData.atmosphereHeight,\n    surfaceDensity: planetData.surfaceDensity\n  });\n}\n\n// Updated applyAirResistance method\nprivate applyAirResistance(rocket: Phaser.Physics.Arcade.Body): void {\n  for (const [_, source] of this.gravitySources) {\n    const dx = rocket.x - source.body.x;\n    const dy = rocket.y - source.body.y;\n    const distanceSquared = dx * dx + dy * dy;\n    const distance = Math.sqrt(distanceSquared);\n    \n    // Get radius from the body\n    const planetRadius = source.body.width / 2;\n    \n    // Check if rocket is within atmosphere\n    if (distance < planetRadius + source.atmosphereHeight) {\n      // Calculate atmospheric density based on height\n      const height = distance - planetRadius;\n      const densityFactor = Math.max(0, 1 - (height / source.atmosphereHeight));\n      const density = source.surfaceDensity * densityFactor;\n      \n      // Apply drag proportional to density and velocity squared\n      const speed = Math.sqrt(rocket.velocity.x * rocket.velocity.x + rocket.velocity.y * rocket.velocity.y);\n      const dragMagnitude = this.dragCoefficient * density * speed * speed;\n      \n      if (speed > 0.1) {\n        const dragX = (dragMagnitude * rocket.velocity.x) / speed;\n        const dragY = (dragMagnitude * rocket.velocity.y) / speed;\n        \n        rocket.velocity.x -= dragX;\n        rocket.velocity.y -= dragY;\n      }\n    }\n  }\n}\n```\n\n```typescript\n// In MainScene.ts\n// Updated planet objects map to include PlanetState data\nprivate planetObjects: Map<string, { \n  sprite: Phaser.GameObjects.Sprite; \n  body: Phaser.Physics.Arcade.Body; \n  data: PlanetState \n}> = new Map();\n\n// In the planet creation handler\nthis.multiplayerService.onPlanetAdd('mainScene', (planetId, planetData) => {\n  const planetSprite = this.add.sprite(planetData.x, planetData.y, planetData.textureKey);\n  planetSprite.setDisplaySize(planetData.radius * 2, planetData.radius * 2);\n  \n  this.physics.add.existing(planetSprite, true);\n  const body = planetSprite.body as Phaser.Physics.Arcade.Body;\n  \n  // Store all data together\n  this.planetObjects.set(planetId, {\n    sprite: planetSprite,\n    body: body,\n    data: planetData\n  });\n  \n  // Add to physics manager with synchronized data\n  this.physicsManager.addGravitySource(planetId, body, planetData);\n});\n\n// In create() method, after initializing physicsManager\nthis.physicsManager.setPlanetObjectsMap(this.planetObjects);\n```\n\n```typescript\n// In schema/State.ts (server and client)\nexport class PlanetState extends Schema {\n  @type(\"string\") id: string;\n  @type(\"number\") x: number;\n  @type(\"number\") y: number;\n  @type(\"number\") radius: number;\n  @type(\"string\") textureKey: string;\n  @type(\"number\") mass: number;\n  @type(\"number\") atmosphereHeight: number;\n  @type(\"number\") surfaceDensity: number;\n}\n```\n</info added on 2025-04-23T22:58:06.029Z>",
          "status": "done",
          "parentTaskId": 12
        }
      ]
    },
    {
      "id": 13,
      "title": "Implement Server-Side Physics with Matter.js",
      "description": "Refactor the architecture to move authoritative physics simulation to the server using Matter.js, while ensuring client-side synchronization and smooth gameplay experience.",
      "details": "This task involves a major architectural shift to move physics simulation from the client to the server for authoritative game state management. Key implementation steps include:\n\n1. Set up Matter.js on the server side with the same configuration as currently used on the client\n2. Modify the Colyseus GameRoom to initialize and maintain the physics world\n3. Implement a fixed timestep physics update loop on the server\n4. Update state schemas to include necessary physics properties (positions, velocities, rotations)\n5. Create a system to receive player inputs from clients and apply them to the physics simulation\n6. Implement state synchronization to send authoritative physics updates to clients\n7. Modify the client to:\n   - Send player inputs to the server instead of applying them locally\n   - Receive and apply server state updates\n   - Implement client-side prediction and reconciliation to minimize perceived latency\n   - Add interpolation for smooth rendering between state updates\n8. Ensure proper handling of object creation and destruction in the physics world\n9. Implement collision detection and resolution on the server\n10. Add performance optimizations to minimize network traffic (delta compression, etc.)\n\nConsiderations:\n- Network latency will impact player experience; implement appropriate prediction/reconciliation\n- Physics simulation must be deterministic across server restarts\n- Consider how to handle disconnections and reconnections\n- Ensure the server can handle the computational load of physics for multiple game rooms",
      "testStrategy": "Testing should verify both the correctness of the physics simulation and the quality of the networked experience:\n\n1. Unit Tests:\n   - Verify server-side physics calculations match expected outcomes\n   - Test state schema serialization/deserialization\n   - Validate input handling and application to physics bodies\n\n2. Integration Tests:\n   - Confirm proper synchronization between server and client states\n   - Test object creation/destruction across the network\n   - Verify collision detection and resolution works correctly on the server\n\n3. Performance Tests:\n   - Measure server CPU usage under various player loads\n   - Benchmark network bandwidth usage\n   - Test with artificial network latency and packet loss\n\n4. Gameplay Tests:\n   - Conduct A/B testing comparing client-side vs. server-side physics\n   - Verify gameplay feels responsive despite network latency\n   - Test edge cases like high-speed collisions and stacking objects\n\n5. Specific Test Cases:\n   - Connect multiple clients and verify consistent physics state across all\n   - Test reconnection scenario to ensure proper state recovery\n   - Verify that server authority properly overrides client prediction when conflicts occur\n   - Test with various network conditions (high latency, packet loss) to ensure graceful degradation",
      "status": "done",
      "dependencies": [
        12
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Matter.js on the server and initialize physics world in GameRoom",
          "description": "Configure Matter.js on the server with the same settings as the client and integrate it with the Colyseus GameRoom to initialize and maintain the physics world.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Install Matter.js as a server dependency\n2. Create a PhysicsManager class that will encapsulate the Matter.js functionality\n3. Import and configure Matter.js with identical settings to client (gravity, bounds, etc.)\n4. Modify the GameRoom class to instantiate the physics world during room creation\n5. Set up the basic world properties and configuration options\n6. Ensure the physics world is properly destroyed when the room is disposed\n\nTesting approach:\n- Create unit tests to verify physics world initialization with expected parameters\n- Test that the physics engine can be created and destroyed properly\n- Verify that basic physics operations (adding bodies, running simulation) work as expected\n\n<info added on 2025-04-24T16:29:30.760Z>\nHere's additional implementation information for subtask 13.1:\n\n```typescript\n// server/src/physics/ServerPhysicsManager.ts\nimport { Engine, World, Bodies, Composite } from 'matter-js';\nimport { Logger } from '../../../shared/utils/Logger';\n\nexport class ServerPhysicsManager {\n  private engine: Matter.Engine;\n  private logger: Logger;\n  \n  constructor() {\n    this.logger = new Logger('ServerPhysicsManager');\n    \n    // Initialize engine with gravity disabled (0, 0)\n    this.engine = Engine.create({\n      gravity: { x: 0, y: 0 },\n      enableSleeping: false,\n      positionIterations: 6,\n      velocityIterations: 4,\n      timing: { timeScale: 1 }\n    });\n    \n    this.logger.info('Physics engine initialized');\n  }\n  \n  public getEngine(): Matter.Engine {\n    return this.engine;\n  }\n  \n  public update(deltaTime: number): void {\n    Engine.update(this.engine, deltaTime);\n  }\n  \n  public addBody(body: Matter.Body): void {\n    Composite.add(this.engine.world, body);\n  }\n  \n  public removeBody(body: Matter.Body): void {\n    Composite.remove(this.engine.world, body);\n  }\n  \n  public destroy(): void {\n    World.clear(this.engine.world, false);\n    Engine.clear(this.engine);\n    this.logger.info('Physics engine destroyed');\n  }\n}\n\n// Integration in GameRoom.ts\nimport { ServerPhysicsManager } from '../physics/ServerPhysicsManager';\n\n// In GameRoom class:\nprivate physicsManager: ServerPhysicsManager;\nprivate physicsInterval: NodeJS.Timeout;\n\nonCreate() {\n  this.physicsManager = new ServerPhysicsManager();\n  \n  // Set up physics update loop at 60fps (16.67ms)\n  const physicsTimeStep = 1000 / 60;\n  this.physicsInterval = setInterval(() => {\n    this.physicsManager.update(physicsTimeStep);\n    // Broadcast updated physics state to clients\n    this.broadcast(\"physics-update\", this.getPhysicsState());\n  }, physicsTimeStep);\n}\n\nonDispose() {\n  if (this.physicsInterval) {\n    clearInterval(this.physicsInterval);\n  }\n  if (this.physicsManager) {\n    this.physicsManager.destroy();\n  }\n}\n\nprivate getPhysicsState() {\n  // Extract relevant physics state to broadcast to clients\n  // This will be expanded in future tasks\n  return {};\n}\n```\n</info added on 2025-04-24T16:29:30.760Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 2,
          "title": "Implement fixed timestep physics update loop on server",
          "description": "Create a deterministic physics update loop on the server that runs at a fixed timestep to ensure consistent simulation regardless of server performance.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Implement a fixed timestep loop in the GameRoom that calls Matter.js update at consistent intervals (e.g., 60 times per second)\n2. Use setInterval or a similar mechanism to ensure regular updates\n3. Track accumulated time to handle potential server lag without affecting simulation accuracy\n4. Add configurable physics timestep value to server configuration\n5. Implement proper time scaling to ensure physics behave consistently regardless of update frequency\n6. Add performance monitoring to log when physics updates take longer than expected\n\nTesting approach:\n- Create tests that verify physics objects move deterministically given the same inputs\n- Test that the simulation remains stable under various server loads\n- Verify that the physics state advances correctly with the fixed timestep\n\n<info added on 2025-04-24T16:34:52.217Z>\nI've reviewed your implementation of the fixed timestep physics loop. Here are additional technical details to enhance the subtask:\n\nFor the `ServerPhysicsManager.update(delta)` method:\n- Ensure you're passing the fixed timestep value to `Engine.update(engine, fixedDelta)` rather than the variable delta to maintain determinism\n- Consider adding a maximum delta cap (e.g., `Math.min(delta, 250)`) to prevent large time jumps during server hiccups\n\nFor the GameRoom implementation:\n- The accumulator pattern is correct, but ensure you're using a while loop (`while (accumulator >= fixedTimestep)`) rather than if statements to handle multiple physics updates when needed\n- Track and store the interpolation factor (`const alpha = accumulator / fixedTimestep`) which will be useful for client-side rendering between physics steps\n- Consider implementing a \"panic mode\" that resets the accumulator if too many consecutive updates are needed (e.g., after server freeze)\n\nConfiguration improvements:\n- Store the physics configuration in a central config object that includes:\n  ```typescript\n  {\n    fixedTimestep: 1000/60, // 16.67ms (60Hz)\n    maxAccumulatedTime: 200, // ms, prevents spiral of death\n    velocityIterations: 8,\n    positionIterations: 3\n  }\n  ```\n\nPerformance monitoring:\n- Use `performance.now()` instead of `Date.now()` for more precise timing\n- Implement a rolling average of physics update times to detect degradation trends\n</info added on 2025-04-24T16:34:52.217Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 3,
          "title": "Update state schemas to include physics properties",
          "description": "Extend the Colyseus state schemas to include all necessary physics properties such as positions, velocities, rotations, and other attributes needed for synchronization.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Identify all physics properties that need to be synchronized (position, velocity, angle, angular velocity, etc.)\n2. Update the entity schemas in the Colyseus state to include these properties\n3. Create mapping functions between Matter.js bodies and Colyseus schema objects\n4. Implement helper methods to update schema from physics bodies and vice versa\n5. Ensure proper type conversion between Matter.js and Colyseus schema types\n6. Add any necessary metadata for reconciliation (like physics step ID)\n\nTesting approach:\n- Test serialization and deserialization of physics properties\n- Verify that all necessary properties are included in the schema\n- Test the mapping functions between Matter.js bodies and schema objects\n\n<info added on 2025-04-24T16:38:08.933Z>\nFor the physics properties implementation, consider these additional details:\n\n1. Use `@filter()` decorator on physics properties that don't need to be sent every frame to reduce bandwidth:\n   ```typescript\n   @filter(function(this: PlayerState, client, value) {\n     // Only send sleeping state changes when they actually change\n     return this.previousIsSleeping !== value;\n   })\n   @type(\"boolean\")\n   isSleeping: boolean;\n   ```\n\n2. Add a `previousTransform` object to store last synchronized values for delta compression:\n   ```typescript\n   @type({ map: \"number\" })\n   previousTransform: MapSchema<number> = new MapSchema();\n   ```\n\n3. Implement threshold-based synchronization to reduce network traffic:\n   ```typescript\n   // In your mapping function\n   if (Math.abs(body.position.x - player.x) > MIN_POSITION_DELTA || \n       Math.abs(body.position.y - player.y) > MIN_POSITION_DELTA) {\n     player.x = body.position.x;\n     player.y = body.position.y;\n   }\n   ```\n\n4. Add a `physicsBodyId` field to maintain reference between schema and Matter.js bodies:\n   ```typescript\n   @type(\"string\")\n   physicsBodyId: string;\n   ```\n\n5. Consider adding interpolation metadata for client-side smoothing:\n   ```typescript\n   @type(\"number\")\n   lastUpdateTime: number;\n   ```\n</info added on 2025-04-24T16:38:08.933Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 4,
          "title": "Create input handling system for client-to-server physics commands",
          "description": "Develop a system to receive player inputs from clients and apply them correctly to the server-side physics simulation.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Define a message format for client input commands (movement, actions, etc.)\n2. Implement server-side handlers to receive these commands in the GameRoom\n3. Create a queue system to store and process inputs in the correct order\n4. Add timestamp and sequence numbering to inputs for reconciliation\n5. Implement the logic to apply these inputs to the appropriate physics bodies\n6. Add validation to prevent cheating (speed hacks, teleporting, etc.)\n7. Create a system to acknowledge processed inputs back to clients\n\nTesting approach:\n- Test input message handling with various input types\n- Verify that inputs are applied correctly to physics bodies\n- Test input validation and rejection of invalid commands\n- Verify sequence handling works correctly with out-of-order messages",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 5,
          "title": "Implement server-to-client state synchronization",
          "description": "Create a system to efficiently send authoritative physics updates from the server to clients, including delta compression to minimize network traffic.",
          "dependencies": [
            2,
            3
          ],
          "details": "Implementation steps:\n1. Implement a system to track changes in physics state between updates\n2. Create a mechanism to send full state snapshots at regular intervals\n3. Implement delta compression to only send changed properties between full snapshots\n4. Add configurable send rate that may differ from physics update rate\n5. Include physics step ID with each update for reconciliation purposes\n6. Implement bandwidth optimization techniques (property filtering, quantization, etc.)\n7. Add priority system to ensure important objects always get updated\n\nTesting approach:\n- Measure bandwidth usage with and without optimizations\n- Test that clients correctly receive and apply state updates\n- Verify that delta compression correctly identifies and transmits only changed properties\n- Test with various network conditions (packet loss, latency, etc.)\n\n<info added on 2025-04-24T17:29:19.818Z>\nImplementation details:\n\nWithin the GameRoom physics loop, after each physics step:\n```javascript\n// Inside the physics loop after updating physics state\nif (this.accumulator >= this.physicsTimeStep) {\n  // Physics step calculations...\n  \n  // Construct state update for broadcasting\n  const physicsUpdate = {};\n  this.players.forEach(player => {\n    if (player.body) {\n      physicsUpdate[player.sessionId] = {\n        x: player.body.position.x,\n        y: player.body.position.y,\n        angle: player.body.angle,\n        vx: player.body.velocity.x,\n        vy: player.body.velocity.y,\n        angularVelocity: player.body.angularVelocity,\n        isSleeping: player.body.isSleeping\n      };\n    }\n  });\n  \n  // Add physics step ID for reconciliation\n  const updatePacket = {\n    stepId: this.currentPhysicsStep,\n    timestamp: Date.now(),\n    delta: this.calculateDelta(this.lastBroadcastState, physicsUpdate),\n    fullState: this.shouldSendFullState() ? physicsUpdate : undefined\n  };\n  \n  // Store last broadcast state for delta calculation\n  this.lastBroadcastState = {...physicsUpdate};\n  \n  // Broadcast to all clients\n  this.broadcast(\"physics_update\", updatePacket);\n  \n  this.currentPhysicsStep++;\n}\n```\n\nThe `calculateDelta` function compares current and previous states to only send changed properties:\n```javascript\ncalculateDelta(previous, current) {\n  if (!previous) return current; // First update sends everything\n  \n  const delta = {};\n  Object.keys(current).forEach(sessionId => {\n    const prevPlayerState = previous[sessionId];\n    const currPlayerState = current[sessionId];\n    \n    if (!prevPlayerState) {\n      // New player, include all properties\n      delta[sessionId] = currPlayerState;\n      return;\n    }\n    \n    // Check which properties changed\n    const playerDelta = {};\n    let hasChanges = false;\n    \n    Object.keys(currPlayerState).forEach(prop => {\n      // Apply threshold for floating point values to reduce updates\n      if (typeof currPlayerState[prop] === 'number') {\n        if (Math.abs(currPlayerState[prop] - prevPlayerState[prop]) > this.updateThresholds[prop] || 0.0001) {\n          playerDelta[prop] = currPlayerState[prop];\n          hasChanges = true;\n        }\n      } else if (currPlayerState[prop] !== prevPlayerState[prop]) {\n        playerDelta[prop] = currPlayerState[prop];\n        hasChanges = true;\n      }\n    });\n    \n    if (hasChanges) {\n      delta[sessionId] = playerDelta;\n    }\n  });\n  \n  return delta;\n}\n```\n</info added on 2025-04-24T17:29:19.818Z>\n\n<info added on 2025-04-25T09:53:56.205Z>\n<info added on 2025-04-25T09:14:32.451Z>\nImplementation refinements for delta compression:\n\n1. Define specific threshold constants for different property types:\n```javascript\n// Constants for delta compression thresholds\nconst SYNC_THRESHOLD_POSITION = 0.01;  // 1cm in world units\nconst SYNC_THRESHOLD_VELOCITY = 0.05;  // 5cm/s in world units\nconst SYNC_THRESHOLD_ANGLE = 0.01;     // ~0.6 degrees\nconst SYNC_THRESHOLD_ANGULAR_VELOCITY = 0.02;\n```\n\n2. Enhanced delta calculation with property-specific thresholds:\n```javascript\ncalculateDelta(previous, current) {\n  // ... existing code ...\n  \n  Object.keys(currPlayerState).forEach(prop => {\n    // Apply property-specific thresholds\n    if (typeof currPlayerState[prop] === 'number') {\n      const threshold = \n        prop === 'x' || prop === 'y' ? SYNC_THRESHOLD_POSITION :\n        prop === 'vx' || prop === 'vy' ? SYNC_THRESHOLD_VELOCITY :\n        prop === 'angle' ? SYNC_THRESHOLD_ANGLE :\n        prop === 'angularVelocity' ? SYNC_THRESHOLD_ANGULAR_VELOCITY :\n        0.0001; // default threshold\n        \n      if (Math.abs(currPlayerState[prop] - prevPlayerState[prop]) > threshold) {\n        playerDelta[prop] = currPlayerState[prop];\n        hasChanges = true;\n      }\n    } else if (currPlayerState[prop] !== prevPlayerState[prop]) {\n      // For boolean properties like isSleeping\n      playerDelta[prop] = currPlayerState[prop];\n      hasChanges = true;\n    }\n  });\n  \n  // ... existing code ...\n}\n```\n\n3. Client-side handling of sparse delta updates:\n```javascript\n// Client-side code\nthis.room.onMessage(\"physics_update\", (data) => {\n  const { stepId, timestamp, delta, fullState } = data;\n  \n  // Track server physics step for reconciliation\n  this.serverPhysicsStep = stepId;\n  this.serverTimestamp = timestamp;\n  \n  if (fullState) {\n    // Full state update - replace entire state\n    this.gameState = fullState;\n  } else if (delta) {\n    // Apply delta updates to existing state\n    Object.keys(delta).forEach(sessionId => {\n      // Create player entry if it doesn't exist\n      if (!this.gameState[sessionId]) {\n        this.gameState[sessionId] = {};\n      }\n      \n      // Apply only the changed properties\n      Object.assign(this.gameState[sessionId], delta[sessionId]);\n    });\n  }\n  \n  // Apply the updated state to the physics world\n  this.applyStateToPhysics();\n});\n```\n\n4. Bandwidth monitoring and adaptive compression:\n```javascript\n// Track bandwidth usage\nthis.bytesSent = 0;\nthis.updatesSent = 0;\n\n// After creating update packet\nconst packetSize = JSON.stringify(updatePacket).length;\nthis.bytesSent += packetSize;\nthis.updatesSent++;\n\n// Every 5 seconds, evaluate and potentially adjust thresholds\nif (Date.now() - this.lastBandwidthCheck > 5000) {\n  const bytesPerSecond = this.bytesSent / 5;\n  \n  // If bandwidth usage is too high, increase thresholds\n  if (bytesPerSecond > this.maxBytesPerSecond) {\n    SYNC_THRESHOLD_POSITION *= 1.2;\n    SYNC_THRESHOLD_VELOCITY *= 1.2;\n    SYNC_THRESHOLD_ANGLE *= 1.2;\n  } else if (bytesPerSecond < this.minBytesPerSecond) {\n    // If bandwidth usage is low, decrease thresholds for better precision\n    SYNC_THRESHOLD_POSITION = Math.max(0.001, SYNC_THRESHOLD_POSITION * 0.8);\n    SYNC_THRESHOLD_VELOCITY = Math.max(0.01, SYNC_THRESHOLD_VELOCITY * 0.8);\n    SYNC_THRESHOLD_ANGLE = Math.max(0.001, SYNC_THRESHOLD_ANGLE * 0.8);\n  }\n  \n  this.bytesSent = 0;\n  this.lastBandwidthCheck = Date.now();\n}\n```\n</info added on 2025-04-25T09:14:32.451Z>\n</info added on 2025-04-25T09:53:56.205Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 6,
          "title": "Modify client to send inputs and apply server state",
          "description": "Update the client-side code to send player inputs to the server instead of applying them locally, and to receive and apply server state updates.",
          "dependencies": [
            4,
            5
          ],
          "details": "Implementation steps:\n1. Refactor client input handling to send commands to server instead of applying locally\n2. Implement client-side input buffering and sequence numbering\n3. Create a system to receive and apply server state updates to local entities\n4. Modify the client rendering to use the synchronized state\n5. Implement a system to handle server acknowledgments of processed inputs\n6. Add error handling for connection issues and server rejections\n7. Create debug visualization to show server vs. client state\n\nTesting approach:\n- Test input sending and state receiving under various network conditions\n- Verify that client correctly applies server state updates\n- Test handling of connection interruptions\n- Verify that inputs are correctly sequenced and buffered",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 7,
          "title": "Implement client-side prediction and reconciliation",
          "description": "Add client-side prediction to apply inputs locally before server confirmation, and reconciliation to correct the client state when server updates arrive.",
          "dependencies": [
            6
          ],
          "details": "Implementation steps:\n1. Implement client-side physics simulation for prediction\n2. Apply local inputs immediately while also sending to server\n3. Store input history and predicted states for reconciliation\n4. When receiving server updates, compare with predicted state\n5. If discrepancy is detected, rewind and replay inputs from last acknowledged input\n6. Implement smoothing to prevent jarring corrections\n7. Add configuration options for prediction settings\n8. Create debug visualization of prediction and reconciliation\n\nTesting approach:\n- Test prediction accuracy under various conditions\n- Verify reconciliation correctly handles server-client discrepancies\n- Test with artificial latency to ensure smooth experience\n- Measure and optimize performance impact of prediction\n\n<info added on 2025-04-25T09:54:19.967Z>\nFor client-side reconciliation/correction, we've refined the approach to balance accuracy with smooth gameplay:\n\n1. The client now relies on authoritative server state rather than applying local predicted forces independently.\n\n2. Correction logic uses partial application of server state through interpolation:\n   - Position correction: `Phaser.Math.Linear(currentPos, serverPos, CLIENT_PHYSICS_CORRECTION_FACTOR)`\n   - Rotation correction: `Phaser.Math.Angle.RotateTo(currentRot, serverRot, CLIENT_PHYSICS_CORRECTION_FACTOR * delta)`\n   - Default correction factor is 0.5, configurable based on game needs\n\n3. This approach creates a dual-layer system:\n   - Physics bodies gradually align with server state to maintain collision integrity\n   - Visual elements interpolate toward target positions for smoother player experience\n\n4. Added threshold detection to prevent minor corrections (< 5px difference) from triggering full reconciliation\n\n5. Implemented adaptive correction factor that scales based on discrepancy magnitude:\n   ```javascript\n   const discrepancyMagnitude = Phaser.Math.Distance.Between(\n     currentPos.x, currentPos.y, serverPos.x, serverPos.y\n   );\n   const adaptiveFactor = Math.min(\n     CLIENT_PHYSICS_CORRECTION_FACTOR * (1 + discrepancyMagnitude/100), \n     0.9\n   );\n   ```\n</info added on 2025-04-25T09:54:19.967Z>",
          "status": "done",
          "parentTaskId": 13
        },
        {
          "id": 8,
          "title": "Add interpolation and implement collision handling",
          "description": "Implement client-side interpolation for smooth rendering between state updates and server-side collision detection and resolution.",
          "dependencies": [
            5,
            7
          ],
          "details": "Implementation steps:\n1. Implement entity interpolation on the client to smooth movement between state updates\n2. Create a buffer of recent server states for interpolation\n3. Add configurable interpolation delay to balance smoothness vs. latency\n4. Implement server-side collision detection using Matter.js collision system\n5. Create event handlers for different collision types on the server\n6. Synchronize collision effects to clients\n7. Add special handling for important gameplay collisions (damage, pickups, etc.)\n8. Implement client-side collision prediction for responsive feedback\n\nTesting approach:\n- Test visual smoothness with various network conditions\n- Verify that collisions are correctly detected and resolved on server\n- Test collision events are properly synchronized to clients\n- Verify that interpolation correctly handles object creation and destruction",
          "status": "done",
          "parentTaskId": 13
        }
      ]
    },
    {
      "id": 14,
      "title": "Refactor Physics Logic for Client-Server Consistency with Client-Side Prediction",
      "description": "Create a shared physics implementation between client and server, then implement client-side prediction with server correction to improve gameplay responsiveness while maintaining authoritative server physics.",
      "details": "This task involves restructuring our physics implementation to improve consistency and responsiveness:\n\n1. Create the following directory and files:\n   - `@shared/physics/` directory\n   - `@shared/physics/Constants.ts` for physics constants (gravity strength, air resistance factors)\n   - `@shared/physics/PhysicsLogic.ts` for core physics calculations\n   - `@shared/physics/CollisionCategories.ts` (moved from current location)\n\n2. Move the following logic to shared implementation:\n   - Extract `applyCustomGravity` and `applyAirResistance` from `src/game/physics/PhysicsManager.ts` to `PhysicsLogic.ts`\n   - Ensure all physics constants are defined in `Constants.ts`\n   - Move collision categories to shared location\n\n3. Update client and server implementations:\n   - Modify `src/game/physics/PhysicsManager.ts` to use shared logic\n   - Update server physics in `ServerPhysicsManager` and `GameRoom` to apply shared logic before `Engine.update`\n\n4. Implement refined client-side prediction:\n   - In `src/game/scenes/MainScene.ts`, remove local predicted force application to eliminate physics judder\n   - Update `Rocket.update` to set visuals directly from its physics body (remove local interpolation for player's rocket)\n   - Implement partial physics body correction using `CLIENT_PHYSICS_CORRECTION_FACTOR` towards server state instead of instant snapping\n   - Adjust local visual interpolation factor for better responsiveness while maintaining smoothness\n   - Keep interpolation for remote rockets\n\n5. Update all import paths throughout the codebase to reference the new shared modules\n   - Use `@ts-ignore` for shared imports if needed due to build configuration\n\n6. Implement thruster visibility synchronization:\n   - Add `isThrusting` property to shared PlayerState schema\n   - Update server to broadcast thrust state as part of player state\n   - Modify client to read thrust state from server updates\n   - Update Rocket entity to use the `isThrusting` property to control visual thruster display\n   - Fix any related type errors and schema import path issues\n\nThe server remains the authority for physics simulation, but the client now predicts movement based on input using the same physics logic, creating a more responsive experience while maintaining consistency.\n\n**Implementation Plan:**\n1.  **Create Shared Physics Logic (`@shared`)**:\n    *   Create a new directory `@shared/physics`.\n    *   Create `Constants.ts` for shared physics constants (G, DRAG_COEFFICIENT).\n    *   Create `PhysicsLogic.ts` for shared physics calculation functions.\n    *   Move the core logic of `applyCustomGravity` from `src/game/physics/PhysicsManager.ts` into a static function (e.g., `PhysicsLogic.calculateAndApplyGravity`) in the shared file.\n    *   Move the core logic of `applyAirResistance` from `src/game/physics/PhysicsManager.ts` into a static function (e.g., `PhysicsLogic.calculateAndApplyAirResistance`) in the shared file.\n    *   Move `src/game/physics/CollisionCategories.ts` to `@shared/physics/CollisionCategories.ts`.\n\n2.  **Update Client Physics (`src/game/physics/PhysicsManager.ts`)**:\n    *   Modify it to import and use the shared functions from `@shared/physics/PhysicsLogic.ts` within its `update` method.\n    *   Remove the local implementations of `applyCustomGravity` and `applyAirResistance`.\n    *   Update imports for `CollisionCategories`.\n\n3.  **Update Server Physics (`server/src/physics/ServerPhysicsManager.ts` & `server/src/rooms/GameRoom.ts`)**:\n    *   Modify `ServerPhysicsManager` (or `GameRoom`'s physics loop) to import and use the shared functions from `@shared/physics/PhysicsLogic.ts` to apply gravity and air resistance to player bodies *before* calling `Engine.update`.\n    *   Update imports for `CollisionCategories` if used.\n\n4.  **Implement Refined Client-Side Prediction**:\n    *   **Remove Local Force Application:** Eliminate direct force application on the client to prevent physics judder.\n    *   **Define Correction Factor:** Add `CLIENT_PHYSICS_CORRECTION_FACTOR` constant to control how quickly local physics bodies correct toward server state.\n    *   **Partial Correction:** Instead of instantly snapping to server positions, gradually move the local physics body toward server state using the correction factor.\n    *   **Visual Update:** Adjust the visual interpolation factor for the local rocket to balance responsiveness and smoothness.\n    *   **Keep Remote Interpolation:** Maintain the existing interpolation for remote rockets.\n\n5.  **Implement State Correction (`src/game/scenes/MainScene.ts`)**:\n    *   **Modify `handlePhysicsUpdate`:** For the local player, apply partial correction to the local `rocket.body` state using the correction factor.\n    *   **Implement Lerping:** Use linear interpolation between current state and server state based on the correction factor.\n\n6.  **Implement Thruster Visibility Synchronization**:\n    *   Update the shared PlayerState schema to include an `isThrusting` boolean property\n    *   Modify server code to track and broadcast the thrust state of each player\n    *   Update client code to read the thrust state from server updates\n    *   Modify the Rocket entity to use the `isThrusting` property to control visual thruster display\n    *   Resolve any type errors and schema import path issues that arise\n\n7.  **Handle Imports & `@ts-ignore`**:\n    *   Update all import paths referencing the moved files.\n    *   Use `@ts-ignore` comments for shared imports if necessary.",
      "testStrategy": "Testing should verify both the refactoring and the client-side prediction implementation:\n\n1. Unit Tests:\n   - Create tests for shared physics functions to verify calculations are identical to previous implementation\n   - Test that constants are properly exported and accessible\n   - Verify the CLIENT_PHYSICS_CORRECTION_FACTOR produces expected interpolation results\n\n2. Integration Tests:\n   - Verify server physics still behaves identically after refactoring\n   - Confirm client can import and use shared physics modules\n   - Test the partial correction mechanism with various correction factor values\n\n3. Functional Tests:\n   - Test high-latency scenarios (use network throttling tools):\n     - Player movement should feel responsive despite latency\n     - Verify partial correction occurs smoothly when server updates arrive\n     - Confirm no physics judder during gameplay with the refined approach\n     - No visible 'snapping' during normal gameplay\n   - Test edge cases:\n     - Rapid input changes during high latency\n     - Collision handling with prediction\n     - Multiple simultaneous player interactions\n     - Extreme server-client position differences\n   - Test thruster visibility synchronization:\n     - Verify thrusters display correctly for local player with prediction\n     - Confirm remote players' thrusters appear/disappear appropriately\n     - Test thruster state during network interruptions\n\n4. Visual Verification:\n   - Record side-by-side comparison of gameplay before and after changes\n   - Verify that remote players' movements appear smooth\n   - Confirm local player movement is more responsive but still stable\n   - Compare different CLIENT_PHYSICS_CORRECTION_FACTOR values visually\n   - Verify thruster visual effects match player actions for both local and remote players\n\n5. Performance Testing:\n   - Measure client frame rate before and after changes\n   - Verify no significant increase in CPU usage from prediction calculations\n   - Test performance with different correction factor values",
      "status": "done",
      "dependencies": [],
      "priority": "high"
    },
    {
      "id": 15,
      "title": "Refactor Project to Monorepo Workspace Structure",
      "description": "Migrate client, server, and shared code into a monorepo structure using npm/yarn/pnpm workspaces for better code sharing and dependency management. Original files have been moved to a 'monorepo-conversion' directory to ensure a clean workspace.",
      "details": "## Implementation Steps:\n\n1. **Setup Root Configuration**\n   - Create/update root package.json with workspace definition (e.g., `\"workspaces\": [\"packages/*\"]`)\n   - Set up base tsconfig.json with common compiler options\n   - Add .gitignore for node_modules at root and package levels\n\n2. **Create Packages Structure**\n   - Create packages/ directory at project root\n   - Create subdirectories: packages/client/, packages/server/, packages/shared/\n\n3. **Migrate Client Code**\n   - Copy relevant client code from monorepo-conversion/src/ to packages/client/src/\n   - Copy client assets from monorepo-conversion/public/ to packages/client/public/\n   - Create client package.json with appropriate dependencies (reference original package.json)\n   - Add dependency on shared package (e.g., `\"@one-button-to-space/shared\": \"*\"`)\n   - Create client-specific tsconfig.json extending from root\n   - Update build paths and scripts\n\n4. **Migrate Server Code**\n   - Copy server code from monorepo-conversion/server/ to packages/server/src/\n   - Create server package.json with appropriate dependencies (reference original package.json)\n   - Add dependency on shared package\n   - Create server-specific tsconfig.json extending from root\n   - Update build paths and scripts\n\n5. **Set Up Shared Package**\n   - Copy shared code from monorepo-conversion/shared/ to packages/shared/src/\n   - Create package.json with name `@one-button-to-space/shared`\n   - Configure for proper TypeScript declarations\n   - Set up build process to generate distributable files\n\n6. **Refactor Import Statements**\n   - Update all imports in client and server to use the shared package\n   - Replace relative imports (../../shared) with package imports (@one-button-to-space/shared)\n\n7. **Package Installation**\n   - Run workspace-aware install from root (npm/yarn/pnpm install)\n   - Verify node_modules structure and hoisting\n\n8. **Root Scripts Configuration**\n   - Add scripts to root package.json for managing workspaces:\n     - `\"build\": \"npm run build --workspaces\"`\n     - `\"dev\": \"npm run dev --workspaces --parallel\"`\n     - `\"test\": \"npm run test --workspaces\"`\n     - Add other workspace management scripts as needed\n\n9. **Update CI/CD Pipeline**\n   - Modify CI/CD configuration to work with monorepo structure\n   - Update build and deployment scripts\n\n10. **Configuration Files Migration**\n    - Review and migrate relevant configuration from monorepo-conversion/config/ to appropriate packages\n    - Update paths and references in configuration files to match new structure\n\n11. **Cleanup**\n    - After successful testing, remove the temporary monorepo-conversion directory",
      "testStrategy": "## Testing Approach:\n\n1. **Build Verification**\n   - Run `npm run build` at root level\n   - Verify all packages build successfully without errors\n   - Check that output directories contain expected files\n\n2. **Functionality Testing**\n   - Start both client and server applications\n   - Verify all core functionality works as before\n   - Test all major user flows to ensure nothing broke during migration\n   - Compare behavior with the original implementation in monorepo-conversion directory\n\n3. **Shared Code Propagation Test**\n   - Make a change to a type or function in the shared package\n   - Rebuild all packages (`npm run build`)\n   - Verify the change is correctly reflected in both client and server\n   - Test functionality that depends on the modified shared code\n\n4. **Package Dependency Test**\n   - Add a new function or type to the shared package\n   - Import and use it in both client and server\n   - Verify it works correctly in both places\n\n5. **Development Workflow Test**\n   - Test the development workflow with the new structure\n   - Verify hot reloading works correctly\n   - Ensure developers can easily run and test individual packages\n\n6. **CI Pipeline Test**\n   - Run the updated CI pipeline\n   - Verify all build, test, and deployment steps complete successfully\n\n7. **Side-by-Side Comparison**\n   - Run the original application from monorepo-conversion directory\n   - Run the new monorepo version\n   - Compare functionality, performance, and behavior to ensure equivalence",
      "status": "in-progress",
      "dependencies": [],
      "priority": "medium"
    }
  ],
  "metadata": {
    "projectName": "One Button to Space",
    "totalTasks": 10,
    "sourceFile": "C:\\dev\\personal\\one-button-to-space\\scripts\\prd.txt",
    "generatedAt": "2023-11-05"
  }
}