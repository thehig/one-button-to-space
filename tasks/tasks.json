{
  "tasks": [
    {
      "id": 1,
      "title": "Initialize pnpm Monorepo Structure",
      "description": "Set up the initial monorepo structure with client, server, and shared packages using pnpm workspaces.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create a new directory for the project. Initialize pnpm workspace by creating a pnpm-workspace.yaml file in the root with packages defined as ['client', 'server', 'shared']. Set up package.json in the root with workspace configuration. Create subdirectories for each package with their own package.json files. Configure root-level scripts for building and running all packages.",
      "testStrategy": "Verify that pnpm workspaces are correctly configured by running 'pnpm install' and confirming dependencies are hoisted appropriately. Ensure packages can reference each other using the workspace protocol."
    },
    {
      "id": 2,
      "title": "Configure TypeScript for All Packages",
      "description": "Set up TypeScript configuration for client, server, and shared packages with strict type checking.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create a base tsconfig.json in the root directory with strict type checking enabled. Create extended tsconfig.json files in each package directory that reference the base config and add package-specific settings. For client, configure for React/Vite. For server, configure for Node.js. For shared, configure for cross-environment compatibility. Install TypeScript and related type definitions as dev dependencies.",
      "testStrategy": "Run 'tsc --noEmit' in each package to verify TypeScript configuration is valid. Create simple test files in each package to ensure compilation works correctly."
    },
    {
      "id": 3,
      "title": "Set Up Client Package with Vite and React",
      "description": "Initialize the client package with Vite, React, and TypeScript support.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "In the client directory, initialize a new Vite project with React and TypeScript template using 'pnpm create vite . --template react-ts'. Configure vite.config.ts for development and production builds. Set up basic React component structure. Install necessary dependencies including React, React DOM, and Vite. Create a simple App component and entry point to verify setup.",
      "testStrategy": "Run 'pnpm dev' in the client package to verify the Vite development server starts correctly. Confirm the React application renders in the browser without errors."
    },
    {
      "id": 4,
      "title": "Set Up Server Package with Node.js, Express, and Colyseus",
      "description": "Initialize the server package with Node.js, Express, and Colyseus for WebSocket communication.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "In the server directory, initialize a new Node.js project. Install Express, Colyseus, and related dependencies. Create a basic server.ts file that sets up an Express application and integrates Colyseus for WebSocket handling. Configure scripts for development (with nodemon) and production builds. Set up a basic HTTP endpoint for health checks.",
      "testStrategy": "Run the server and verify it starts without errors. Test the health check endpoint with a simple HTTP request. Verify Colyseus is properly initialized by checking server logs."
    },
    {
      "id": 5,
      "title": "Implement Shared Physics Module with Matter.js",
      "description": "Create the core physics simulation module in the shared package using Matter.js.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "In the shared package, install Matter.js and its TypeScript definitions. Create a PhysicsEngine class that encapsulates Matter.js functionality. Implement methods for creating and configuring the physics world, adding/removing bodies, and stepping the simulation with a fixed timestep. Define physics constants (gravity, collision categories, etc.) in a separate constants file. Ensure the implementation is deterministic and can be used identically on both client and server.",
      "testStrategy": "Create unit tests for the physics module to verify deterministic behavior. Run the same simulation with identical inputs on different platforms and compare the results to ensure consistency."
    },
    {
      "id": 6,
      "title": "Integrate Phaser with React in Client",
      "description": "Set up Phaser within the React application and create the basic scene structure.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Install Phaser in the client package. Create a PhaserGame component in React that initializes and manages the Phaser game instance. Set up basic scene classes (BootScene, MainMenuScene, GameScene) following Phaser's lifecycle methods. Create a container div in the React component to mount the Phaser canvas. Implement proper cleanup in the React component's useEffect hook to prevent memory leaks during component unmounting.",
      "testStrategy": "Verify Phaser initializes correctly within the React application. Check that scenes load properly and the game canvas renders. Test component mounting/unmounting to ensure proper cleanup."
    },
    {
      "id": 7,
      "title": "Implement Client-Side Manager Architecture",
      "description": "Create the core manager classes for the client-side game architecture.",
      "status": "done",
      "dependencies": [
        6
      ],
      "priority": "high",
      "details": "Implement the manager classes as specified in the PRD: PhysicsManager (integrating with shared physics), InputManager, NetworkManager, EntityManager, CameraManager, UIManager, and AudioManager. Each manager should have clear lifecycle methods (init, create/start, update, shutdown/destroy). Set up dependency injection between managers. Implement an event bus system using Phaser's event emitters for communication between managers. Ensure proper cleanup in shutdown/destroy methods.",
      "testStrategy": "Create test scenarios that exercise each manager's functionality. Verify managers initialize, update, and clean up correctly. Test event communication between managers. Verify Hot Module Replacement works without memory leaks."
    },
    {
      "id": 8,
      "title": "Implement PhysicsManager Integration with Shared Module",
      "description": "Connect the client-side PhysicsManager with the shared physics module.",
      "status": "done",
      "dependencies": [
        5,
        7
      ],
      "priority": "high",
      "details": "In the PhysicsManager, import and instantiate the physics engine from the shared package. Implement methods to create, update, and render physics bodies. Create a bridge between Phaser's update loop and the fixed timestep physics simulation. Add debug rendering capabilities for physics bodies. Ensure proper synchronization between physics bodies and their visual representations.",
      "testStrategy": "Test physics simulation with various scenarios (gravity, collisions, etc.). Verify visual representations match physics body positions and rotations. Check that the fixed timestep implementation maintains consistent simulation regardless of frame rate."
    },
    {
      "id": 9,
      "title": "Implement Basic Colyseus Room on Server",
      "description": "Create the server-side GameRoom using Colyseus for multiplayer functionality.",
      "status": "pending",
      "dependencies": [
        4,
        5
      ],
      "priority": "high",
      "details": "In the server package, create a GameRoom class extending Colyseus.Room. Implement onCreate, onJoin, onLeave, and onDispose lifecycle methods. Integrate the shared physics module for server-side simulation. Define the initial state schema using @colyseus/schema for state synchronization. Implement basic player management (adding/removing players). Set up a fixed update loop for physics simulation on the server.",
      "testStrategy": "Test room creation, joining, and leaving with mock clients. Verify the physics simulation runs correctly on the server. Check that the state schema is properly defined and synchronized."
    },
    {
      "id": 10,
      "title": "Implement Client-Server Network Communication",
      "description": "Set up communication between client NetworkManager and server GameRoom.",
      "status": "pending",
      "dependencies": [
        7,
        9
      ],
      "priority": "high",
      "details": "In the NetworkManager, implement Colyseus client connection and room joining. Create message types in the shared package for client-server communication. Implement sending player inputs from client to server. Set up receiving and processing state updates from server to client. Add connection status handling and reconnection logic.",
      "testStrategy": "Test client-server connection establishment. Verify input messages are correctly sent from client to server. Check that state updates are received and processed by the client. Test reconnection scenarios."
    },
    {
      "id": 11,
      "title": "Implement Rocket Physics and Control",
      "description": "Create the core rocket physics and player control mechanics.",
      "status": "pending",
      "dependencies": [
        8
      ],
      "priority": "medium",
      "details": "In the shared package, define rocket physics properties (mass, thrust force, etc.). Implement rocket body creation in the physics engine. In the client, create a PlayerRocketController that translates input events to physics forces. Implement thrust and orientation control based on input (touch/click for thrust, device tilt or keyboard for orientation). Add visual feedback for thrust activation.",
      "testStrategy": "Test rocket movement with different input combinations. Verify physics behavior matches expected rocket dynamics. Check that visual feedback correctly reflects the physics state."
    },
    {
      "id": 12,
      "title": "Implement Advanced Physics Simulation",
      "description": "Enhance the shared physics module with gravity, atmospheric effects, and collision handling.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "Extend the physics engine to support variable gravity based on proximity to celestial bodies. Implement atmospheric density and drag effects. Add collision detection and handling, including special logic for landing detection based on velocity and angle. Implement collision categories and groups for different types of objects (rockets, debris, planets, etc.).",
      "testStrategy": "Create test scenarios for each physics feature (gravity, atmosphere, collisions). Verify behavior matches expected physics. Test edge cases like high-velocity impacts and extreme distances from gravity sources."
    },
    {
      "id": 13,
      "title": "Implement Client-Side Prediction and Reconciliation",
      "description": "Add client-side prediction and server reconciliation for smooth multiplayer experience.",
      "status": "pending",
      "dependencies": [
        10,
        11
      ],
      "priority": "medium",
      "details": "In the NetworkManager, implement input sequence numbering and buffering. Add client-side prediction by applying inputs locally before server confirmation. Implement server reconciliation by comparing server state with predicted state and correcting discrepancies. Add interpolation for remote player entities to smooth movement between state updates. Implement a replay system for re-applying inputs after reconciliation.",
      "testStrategy": "Test with artificial network latency to verify prediction and reconciliation. Check visual smoothness of local and remote player movement. Verify recovery from prediction errors."
    },
    {
      "id": 14,
      "title": "Implement Ship Types and Properties",
      "description": "Create different ship types with varying physics properties and constraints.",
      "status": "pending",
      "dependencies": [
        11
      ],
      "priority": "medium",
      "details": "In the shared package, define data structures for different ship types (Tourist, Cargo). Implement varying physics properties (mass, engine force, rotation speed) for each type. Create factory methods for instantiating different ship types in the physics simulation. Add visual representations for each ship type in the client.",
      "testStrategy": "Test each ship type with identical inputs to verify different handling characteristics. Check that physics properties correctly affect movement and control. Verify visual representations match the ship type."
    },
    {
      "id": 15,
      "title": "Implement Cargo System",
      "description": "Create mechanics for picking up, attaching, and delivering cargo items.",
      "status": "pending",
      "dependencies": [
        12,
        14
      ],
      "priority": "medium",
      "details": "Define cargo item physics properties in the shared package. Implement collision detection for cargo pickup. Create attachment mechanics that affect the physics of the carrying ship. Implement cargo delivery detection based on location and velocity. Add visual feedback for cargo attachment and delivery.",
      "testStrategy": "Test cargo pickup with different approach vectors and speeds. Verify physics changes when cargo is attached. Test cargo delivery under various conditions. Check that multiplayer cargo handling works correctly."
    },
    {
      "id": 16,
      "title": "Implement Multiplayer Collision and Debris System",
      "description": "Create the system for player-vs-player collisions and persistent debris generation.",
      "status": "pending",
      "dependencies": [
        9,
        12
      ],
      "priority": "medium",
      "details": "In the server GameRoom, implement collision detection between player rockets. On collision, destroy both rockets and generate debris physics bodies. Add debris to the state schema for synchronization. In the client, implement visual effects for explosions and debris rendering. Ensure debris persists in the simulation and affects other players.",
      "testStrategy": "Test player-vs-player collisions with different velocities and angles. Verify debris generation and persistence. Check that debris correctly affects other players through collisions. Test with multiple simultaneous collisions."
    },
    {
      "id": 17,
      "title": "Implement Basic Mission System",
      "description": "Create a framework for defining and tracking mission objectives.",
      "status": "pending",
      "dependencies": [
        15
      ],
      "priority": "low",
      "details": "Define a mission system architecture with objectives, triggers, and success/fail conditions. Implement initial mission types: Tourism (point A to B with comfort constraints) and Cargo (delivery with time/fuel limits). Create mission tracking and status updating. Add mission selection and assignment in the game flow.",
      "testStrategy": "Test mission assignment and tracking. Verify success and failure conditions trigger correctly. Test mission-specific constraints like G-force limits and time restrictions."
    },
    {
      "id": 18,
      "title": "Implement Visual Effects and Environment",
      "description": "Create visual effects for thrusters, explosions, and the space environment.",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "low",
      "details": "Implement animated thruster effects tied to input state. Create explosion animations for collisions. Implement a procedural star field background using a deterministic seeded approach. Add visual indicators for gravity wells and atmospheric boundaries. Implement particle effects for atmospheric entry.",
      "testStrategy": "Verify visual effects trigger at appropriate times. Check that animations play correctly and clean up properly. Test procedural generation consistency across different clients."
    },
    {
      "id": 19,
      "title": "Implement React UI Components and HUD",
      "description": "Create user interface components for game information and controls.",
      "status": "pending",
      "dependencies": [
        3,
        7
      ],
      "priority": "low",
      "details": "Design and implement React components for velocity, altitude, fuel, and mission info display. Create a main menu component with options for map/mode selection and multiplayer connection. Implement a debug overlay with physics controls and information. Set up communication between React components and Phaser game state via the event bus.",
      "testStrategy": "Test UI component rendering and updates with different game states. Verify user interactions with UI elements work correctly. Check that UI components receive and display accurate game information."
    },
    {
      "id": 20,
      "title": "Implement Camera Controls and Game Polish",
      "description": "Finalize camera behavior and add polish to the game experience.",
      "status": "pending",
      "dependencies": [
        7,
        18
      ],
      "priority": "low",
      "details": "Implement camera following and zooming behavior in the CameraManager. Add smooth transitions between different camera states. Implement depth sorting for game objects to ensure correct rendering order. Add visual and audio feedback for important game events. Optimize performance for different device capabilities.",
      "testStrategy": "Test camera behavior with different game scenarios. Verify smooth transitions and appropriate zoom levels. Check rendering order in complex scenes with many objects. Test performance on various devices."
    },
    {
      "id": 21,
      "title": "Create GameEventLog React Component for Event Display",
      "description": "Develop a new React component that displays events from the CommunicationManager through a React Context Provider, showing events chronologically in a filterable list format.",
      "details": "Create a new React component named `GameEventLog` in the `packages/client/src/components` directory that works with the CommunicationManager system. The implementation should:\n\n1. Create a CommunicationManager class responsible for:\n   - Capturing events from multiple sources including:\n     - The Phaser game's `Phaser.Events.EventEmitter` instance\n     - Individual game scene event emitters\n     - Network event emitters\n     - Any other relevant event emitters in the system\n   - Tagging events by their source (e.g., \"Game\", \"Scene\", \"Network\")\n   - Maintaining an efficient, potentially rolling, chronological log of events to handle high event volume\n   - Providing this data to React components via a React Context Provider\n   - Serving as the central hub for all Phaser-to-React data transfer\n\n2. Implement a React Context Provider that:\n   - Wraps the CommunicationManager functionality\n   - Exposes the event log data to React components\n   - Provides methods for filtering and clearing the log\n\n3. Create the GameEventLog component that:\n   - Consumes the event data from the React Context Provider\n   - Maintains no internal event state (relies on the Context Provider)\n   - Implements UI controls for filtering events by:\n     - Source emitter (e.g., show only network events)\n     - Event name/type\n     - Event data/value\n   - Renders the events as a scrollable list showing:\n     - Event timestamp\n     - Source tag\n     - Event name/type\n     - Relevant event data in a readable format\n   - Includes a clear button to reset the event log through the Context Provider\n   - Uses basic styling to make the log visually distinct\n\n4. Ensure the CommunicationManager:\n   - Employs a clear architectural pattern (e.g., Observer, Pub/Sub) for decoupling event sources and consumers\n   - Subscribes to all emitters when initialized and unsubscribes when destroyed\n   - Implements a maximum number of events to store (e.g., 50) to prevent performance issues\n   - Provides efficient filtering capabilities\n   - Prioritizes clarity, testability, and maintainability in the implementation\n\n5. All Phaser-to-React communication should flow through the CommunicationManager, not directly to the React components.\n\nThe component should be flexible enough to handle different event types without errors and should display the source tags provided by the CommunicationManager.",
      "testStrategy": "Testing should verify both the component's rendering and the CommunicationManager's event handling functionality:\n\n1. **Unit Tests**:\n   - Test that the CommunicationManager correctly captures events from different sources\n   - Verify the CommunicationManager properly tags events by source\n   - Test that the React Context Provider correctly exposes the event data\n   - Verify the GameEventLog component renders without errors\n   - Confirm the CommunicationManager unsubscribes from all emitters when destroyed to prevent memory leaks\n   - Test that the filtering system correctly filters events by source, name, and value\n   - Verify the clear button functionality works through the Context Provider\n   - Test the architectural pattern implementation (Observer/Pub-Sub) for proper decoupling\n\n2. **Integration Tests**:\n   - Mock multiple event emitters (game, scene, network) and dispatch various event types\n   - Verify events from all sources are captured by the CommunicationManager and displayed in chronological order\n   - Check that the CommunicationManager correctly formats different event data types\n   - Test that source tagging works correctly for all emitter types\n   - Verify filter combinations work as expected (e.g., source + event name)\n   - Test the complete flow from Phaser events through the CommunicationManager to the React component\n   - Verify the rolling log mechanism handles high event volumes efficiently\n\n3. **Manual Testing**:\n   - Integrate the component into a game view and verify real events appear from all sources\n   - Test with high-frequency events to ensure performance remains acceptable\n   - Verify the component handles edge cases like empty events or unusual data formats\n   - Check that the component is visually consistent with the rest of the UI\n   - Test all filtering options with real game data\n   - Confirm the automatic source tagging works correctly for all event types\n   - Verify that all Phaser-to-React communication flows through the CommunicationManager",
      "status": "in-progress",
      "dependencies": [],
      "priority": "medium"
    },
    {
      "id": 22,
      "title": "Develop Comprehensive Test Suite for logger-ui Package",
      "description": "Create a complete test suite for the logger-ui package that covers hook logic, component rendering, user interactions, and context usage using React Testing Library.",
      "details": "Implement a comprehensive test suite for the logger-ui package following these requirements:\n\n1. **Hook Testing**:\n   - Test all custom hooks in the package (e.g., useLogger, useLoggerContext)\n   - Verify hooks properly manage state and respond to changes\n   - Test error handling and edge cases\n   - **Specific Hook Testing Plan**:\n     - **`useComponentLayout`**:\n       - Verify layout state management (position, size, visibility)\n       - Test initial state, toggle visibility, update position (drag simulation)\n       - Test update size (resize simulation) and boundary checks\n     - **`useEventFiltering`**:\n       - Verify log event filtering logic\n       - Test initial state, text filtering (including case sensitivity)\n       - Test source filtering, level filtering, combined filters\n       - Test filter clearing and input debouncing (if applicable)\n\n2. **Component Testing**:\n   - Test all UI components for proper rendering\n   - Verify components display correct information based on props\n   - Test component lifecycle behaviors\n   - Ensure accessibility standards are met\n   - **Specific Component Testing Plan**:\n     - **`GameEventLog.tsx`**: \n       - Test rendering with prop variations (`startsOpen`, `startsLocked`, `hijackConsoleLogs`, initial layout)\n       - Test context wrapping and initial events\n       - Verify conditional sections (tree/details)\n       - Test visibility/opacity based on state\n     - **`TreeNode.tsx`**: \n       - Test rendering with various node structures\n       - Test `allowedSources` variations (verify checkbox state)\n       - Test `activeSourcesInLog` variations (verify styling)\n       - Verify count displays and disabled state\n\n3. **User Interaction Testing**:\n   - Test all interactive elements (buttons, inputs, etc.)\n   - Verify event handlers are called with correct parameters\n   - Test keyboard navigation and shortcuts\n   - Simulate user actions and verify expected outcomes\n   - **Specific Interaction/Integration Tests (GameEventLog focus)**:\n     - **Event Handling:** \n       - Simulate `new-event` from manager -> verify UI updates\n       - Test `console.log` hijack -> verify context `logEvent` called & UI updates\n       - Test new source event -> verify filter tree updates\n     - **Filtering:** \n       - Test text input -> verify list filters\n       - Test `TreeNode` checkbox clicks -> verify `allowedSources` updates & list filters\n       - Test parent/child checkbox logic\n     - **UI Controls:** \n       - Test clear button -> verify `clearLog` called & UI clears\n       - Test toggle visibility -> verify state change & window visibility\n       - Test lock button -> verify state change & Rnd props toggle\n       - Test toggle tree/details -> verify sections visibility\n     - **Window Management:** \n       - Simulate Rnd drag/resize -> verify layout state updates via hook\n\n4. **Context Testing**:\n   - Test LoggerContext provider and consumer behavior\n   - Verify context values are properly passed to components\n   - Test context updates and their effects on dependent components\n   - **Specific Context Testing Plan**:\n     - Render consumer -> verify received values (`events`, `clearLog`, `logEvent`)\n     - Test provider props (`maxLogSize`, `redirectEventsToConsole`) -> verify manager methods called (mock manager singleton)\n     - Mock manager -> emit `new-event`/`log-cleared` -> verify context `events` state updates\n     - Call context `clearLog` -> verify manager `clearLog` called\n\nUse React Testing Library as the primary testing tool. Organize tests in a structure that mirrors the package's component hierarchy. Mock external dependencies as needed. Aim for at least 80% test coverage.",
      "testStrategy": "The implementation will be verified through the following approach:\n\n1. **Code Review**:\n   - Verify test files exist for all components, hooks, and contexts\n   - Check that tests follow React Testing Library best practices\n   - Ensure tests are well-organized and maintainable\n\n2. **Test Coverage Analysis**:\n   - Run coverage reports to ensure at least 80% code coverage\n   - Identify and address any gaps in test coverage\n   - Verify all critical paths are tested\n\n3. **Test Quality Verification**:\n   - Confirm tests include positive and negative scenarios\n   - Verify edge cases are covered\n   - Check that tests are deterministic (no flaky tests)\n\n4. **Specific Test Cases to Verify**:\n   - Hook initialization and state management\n   - Component rendering with various prop combinations\n   - Error states and boundary conditions\n   - User interactions (clicks, inputs, etc.)\n   - Context provider behavior and consumer updates\n   - Accessibility compliance\n   - **Hook-Specific Test Cases**:\n     - For `useComponentLayout`: Initial state, visibility toggling, position updates, size updates, boundary conditions\n     - For `useEventFiltering`: Filter application, text search, source/level filtering, combined filters, filter reset\n   - **Component-Specific Test Cases**:\n     - For `GameEventLog`: Prop variations, context integration, conditional rendering, state-based visibility\n     - For `TreeNode`: Node structure rendering, source filtering, styling based on active sources\n   - **Interaction-Specific Test Cases**:\n     - Event handling: Manager events to UI updates, console hijacking, source filtering\n     - UI controls: Clear button, visibility toggle, lock button, tree/details toggle\n     - Window management: Drag and resize operations\n\n5. **CI Integration**:\n   - Ensure tests run successfully in the CI pipeline\n   - Verify tests complete in a reasonable time\n\n6. **Testing Tools**:\n   - Use `renderHook` and `act` from React Testing Library for hook testing\n   - Implement appropriate mocks for dependencies\n   - Use mock functions to verify context and manager interactions",
      "status": "in-progress",
      "dependencies": [],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Unit Tests for useComponentLayout Hook",
          "description": "Create comprehensive unit tests for the useComponentLayout hook to verify layout state management functionality.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new test file `useComponentLayout.test.tsx` in the appropriate test directory\n2. Import the hook and React Testing Library utilities\n3. Write test cases for:\n   - Initial state verification with default and custom parameters\n   - Toggle visibility functionality (verify state changes)\n   - Position update simulation (test drag events)\n   - Size update simulation (test resize events)\n   - Boundary checks for position and size\n   - Lock/unlock functionality\n4. Use React Testing Library's renderHook utility to test the hook in isolation\n5. Mock any required dependencies\n6. Verify state updates after each action\n\nTesting approach:\n- Use renderHook to test the hook directly\n- Create test fixtures for different initial states\n- Simulate state changes by calling the returned functions\n- Assert on the returned state values after each operation\n- Test edge cases like minimum/maximum sizes and boundary positions\n\n<info added on 2025-05-05T11:52:40.459Z>\nBased on your implementation progress, here's additional information to add to the subtask:\n\n```\nTest implementation details:\n\n- Environment setup:\n  - Configured Vitest with jsdom environment to properly simulate DOM events\n  - Added necessary pattern to include hook tests in test runs\n  - Resolved dependency issues with @testing-library/react-hooks and @testing-library/react\n\n- Test fixtures:\n  - Created mockProps object with common test values\n  - Implemented mockEvent factory for simulating drag/resize events with proper coordinates\n\n- Implementation notes:\n  - Used act() to properly handle state updates within tests\n  - Implemented fireEvent for simulating user interactions\n  - Created helper functions to reduce test boilerplate for common assertions\n\n- Test coverage specifics:\n  - Verified that toggleCollapse correctly inverts the isOpen state\n  - Confirmed toggleFilterCollapse properly manages filterOpen state\n  - Validated toggleDetailsCollapse correctly toggles detailsOpen state\n  - Tested handleDragStop updates x/y coordinates based on event data\n  - Verified handleResizeStop correctly calculates and updates width/height\n  - Confirmed state persistence between operations\n\n- Removed tests for locking feature as it's not in the current implementation\n  - Added TODOs for future implementation if feature is added back\n\n- Added snapshot tests for initial state configurations\n```\n</info added on 2025-05-05T11:52:40.459Z>",
          "status": "done",
          "parentTaskId": 22
        },
        {
          "id": 2,
          "title": "Implement Unit Tests for useEventFiltering Hook",
          "description": "Create comprehensive unit tests for the useEventFiltering hook to verify log filtering functionality.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new test file `useEventFiltering.test.tsx` in the appropriate test directory\n2. Import the hook and React Testing Library utilities\n3. Create mock log event data with various sources, levels, and messages\n4. Write test cases for:\n   - Initial state verification (no filters applied)\n   - Text filtering functionality (case sensitive and insensitive)\n   - Source filtering (single and multiple sources)\n   - Level filtering (verify events filtered by log level)\n   - Combined filters (text + source + level)\n   - Filter clearing functionality\n   - Input debouncing (if implemented)\n5. Test with empty log arrays and edge cases\n\nTesting approach:\n- Use renderHook to test the hook directly\n- Create comprehensive test fixtures with varied log events\n- Test each filtering mechanism independently and in combination\n- Verify filtered results match expected output\n- Test performance with large arrays of log events\n- Verify filter state is properly maintained between renders\n\n<info added on 2025-05-05T12:00:58.405Z>\nHere's additional information for the completed tests:\n\n```typescript\n// Sample test implementation details:\nimport { renderHook, act } from '@testing-library/react-hooks';\nimport { useEventFiltering } from '../hooks/useEventFiltering';\n\ndescribe('useEventFiltering', () => {\n  const mockEvents: EventLogEntry[] = [\n    { id: '1', timestamp: '2023-01-01T12:00:00Z', level: 'INFO', source: 'api/users', message: 'User login successful' },\n    { id: '2', timestamp: '2023-01-01T12:01:00Z', level: 'ERROR', source: 'api/auth', message: 'Authentication failed' },\n    { id: '3', timestamp: '2023-01-01T12:02:00Z', level: 'WARN', source: 'api/users/profile', message: 'Profile update incomplete' }\n  ];\n\n  const mockSourceTree: SourceTreeNode[] = [\n    { \n      id: 'api', \n      name: 'api', \n      children: [\n        { id: 'api/users', name: 'users', children: [\n          { id: 'api/users/profile', name: 'profile', children: [] }\n        ]},\n        { id: 'api/auth', name: 'auth', children: [] }\n      ]\n    }\n  ];\n\n  test('parent node toggling affects all descendants', () => {\n    const { result } = renderHook(() => useEventFiltering(mockEvents, mockSourceTree));\n    \n    // Toggle parent node off\n    act(() => {\n      result.current.handleSourceTreeToggle('api');\n    });\n    \n    // Verify all child sources are filtered out\n    expect(result.current.filteredEvents).toHaveLength(0);\n    expect(result.current.allowedSources).not.toContain('api/users');\n    expect(result.current.allowedSources).not.toContain('api/users/profile');\n    expect(result.current.allowedSources).not.toContain('api/auth');\n  });\n\n  test('debounces text filter input', async () => {\n    jest.useFakeTimers();\n    const { result } = renderHook(() => useEventFiltering(mockEvents, mockSourceTree));\n    \n    act(() => {\n      result.current.setFilterName('user');\n    });\n    \n    // Before debounce timeout\n    expect(result.current.filterName).toBe('user');\n    expect(result.current.filteredEvents).toEqual(mockEvents); // Still showing all events\n    \n    // After debounce timeout\n    act(() => {\n      jest.advanceTimersByTime(300); // Assuming 300ms debounce\n    });\n    \n    expect(result.current.filteredEvents).toHaveLength(2); // Only user-related events\n    jest.useRealTimers();\n  });\n\n  test('handles empty event array gracefully', () => {\n    const { result } = renderHook(() => useEventFiltering([], mockSourceTree));\n    \n    expect(result.current.filteredEvents).toHaveLength(0);\n    expect(result.current.eventsCountBySource).toEqual({});\n    \n    // Should not throw when filtering empty array\n    act(() => {\n      result.current.setFilterName('test');\n      result.current.handleSourceTreeToggle('api');\n    });\n    \n    expect(result.current.filteredEvents).toHaveLength(0);\n  });\n}\n```\n\nThe implementation includes proper memoization testing, debounce verification with timer mocking, and comprehensive edge case handling. Tests verify both the filtering logic and the performance optimizations in the hook.\n</info added on 2025-05-05T12:00:58.405Z>",
          "status": "done",
          "parentTaskId": 22
        },
        {
          "id": 3,
          "title": "Implement Component Tests for TreeNode Component",
          "description": "Create tests for the TreeNode component to verify rendering and interaction behavior.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new test file `TreeNode.test.tsx` in the appropriate test directory\n2. Import the component and React Testing Library utilities\n3. Create mock data for different node structures (simple, nested, with counts)\n4. Write test cases for:\n   - Basic rendering with various props\n   - Rendering with different allowedSources configurations\n   - Rendering with different activeSourcesInLog configurations\n   - Proper styling based on active/inactive states\n   - Count display accuracy\n   - Disabled state rendering\n   - Checkbox interaction and state changes\n   - Parent/child node relationships and cascading selections\n5. Test accessibility compliance\n\nTesting approach:\n- Use render from React Testing Library\n- Use screen queries to verify rendered elements\n- Use userEvent to simulate user interactions\n- Test with various prop combinations\n- Verify checkbox state changes trigger the correct callbacks\n- Test keyboard navigation and accessibility\n- Verify proper ARIA attributes are present\n\n<info added on 2025-05-05T12:16:53.485Z>\nHere's the additional information to add:\n\n```\nTest implementation details:\n\n- Created custom test utilities:\n  - `renderTreeNode(props)` helper function for consistent component rendering\n  - `createMockNodeData(options)` factory for generating test data variations\n\n- Mock implementation examples:\n```jsx\nconst mockHandlers = {\n  onToggle: jest.fn(),\n  onExpand: jest.fn()\n};\n\nconst basicNodeMock = {\n  id: 'source1',\n  name: 'Source 1',\n  children: [],\n  eventsCount: 42\n};\n```\n\n- Key test scenarios implemented:\n  - Indeterminate state verification using `expect(checkbox).toHaveProperty('indeterminate', true)`\n  - Nested selection propagation using deeply nested test fixtures\n  - Edge cases for zero-count nodes and their display behavior\n\n- Testing challenges addressed:\n  - Used `jest.spyOn` to verify internal component methods\n  - Implemented `act()` wrapper for asynchronous state updates\n  - Created snapshot tests for regression detection\n  - Added test coverage for keyboard navigation (Tab, Space, Enter)\n\n- Accessibility testing:\n  - Verified proper aria-checked attributes\n  - Confirmed focus indicators meet WCAG standards\n  - Tested screen reader announcements using jest-axe\n\n- Test organization follows AAA pattern (Arrange-Act-Assert) for clarity\n```\n</info added on 2025-05-05T12:16:53.485Z>",
          "status": "done",
          "parentTaskId": 22
        },
        {
          "id": 4,
          "title": "Implement Basic Component Tests for GameEventLog",
          "description": "Create tests for the GameEventLog component focusing on rendering and prop behavior.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new test file `GameEventLog.test.tsx` in the appropriate test directory\n2. Import the component and React Testing Library utilities\n3. Mock any required context providers and dependencies\n4. Write test cases for:\n   - Basic rendering with default props\n   - Rendering with custom props (startsOpen, startsLocked, hijackConsoleLogs, initial layout)\n   - Context wrapping and initial event display\n   - Conditional rendering of tree/details sections\n   - Visibility/opacity based on component state\n   - Proper styling and layout based on props\n5. Test accessibility compliance\n\nTesting approach:\n- Use render from React Testing Library with custom wrapper for context\n- Create mock event data for testing\n- Test with various prop combinations\n- Verify conditional rendering logic\n- Check that initial state matches expected values based on props\n- Verify component structure matches expected DOM hierarchy\n- Test that all required elements are present and properly styled\n\n<info added on 2025-05-05T18:36:39.956Z>\nHere's additional information for the GameEventLog tests:\n\n```\nTest implementation notes:\n\n- Used `screen.getByTestId` with specific data-testid attributes added to key elements for reliable selection\n- Implemented custom render wrapper with GameStateContext provider to simulate real usage\n- Created mock event data factory function to generate test events with varying properties\n- Used `userEvent` to simulate user interactions with the component\n- Added snapshot tests for different prop combinations to catch unintended UI changes\n\nSpecific test improvements:\n- Used `jest.spyOn` to verify console hijacking functionality when `hijackConsoleLogs` is true\n- Implemented tests for drag handle visibility based on locked state\n- Added tests for event filtering functionality\n- Verified proper event tree expansion/collapse behavior\n- Tested keyboard accessibility for expanding/collapsing events\n- Added tests for proper event timestamp formatting\n\nResolved edge cases:\n- Added tests with empty event arrays\n- Tested with extremely long event data to ensure proper truncation/scrolling\n- Verified proper cleanup of event listeners on component unmount\n```\n</info added on 2025-05-05T18:36:39.956Z>",
          "status": "done",
          "parentTaskId": 22
        },
        {
          "id": 5,
          "title": "Implement Interaction Tests for GameEventLog",
          "description": "Create integration tests for GameEventLog focusing on user interactions, event handling, and filtering.",
          "dependencies": [
            3,
            4
          ],
          "details": "Implementation steps:\n1. Extend the GameEventLog test file or create a new integration test file\n2. Mock the logger manager to simulate events and verify interactions\n3. Write test cases for:\n   - Event handling (new-event from manager, console.log hijacking)\n   - Filtering interactions:\n     - Text input filtering\n     - TreeNode checkbox interactions\n     - Parent/child checkbox logic\n   - UI control interactions:\n     - Clear button functionality\n     - Toggle visibility button\n     - Lock/unlock button\n     - Toggle tree/details sections\n   - Window management:\n     - Drag simulation\n     - Resize simulation\n4. Verify state updates after each interaction\n\nTesting approach:\n- Use render from React Testing Library with context providers\n- Use userEvent to simulate complex user interactions\n- Mock the logger manager to emit events and verify handlers\n- Test the full interaction flow from user action to UI update\n- Verify that component state changes correctly after interactions\n- Test keyboard shortcuts and accessibility interactions\n- Simulate window drag/resize events and verify layout updates",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 6,
          "title": "Implement Context Tests for LoggerContext",
          "description": "Create tests for the LoggerContext provider and consumer behavior.",
          "dependencies": [
            4,
            5
          ],
          "details": "Implementation steps:\n1. Create a new test file `LoggerContext.test.tsx` in the appropriate test directory\n2. Import the context, provider, and React Testing Library utilities\n3. Create a mock logger manager for testing\n4. Write test cases for:\n   - Provider initialization with default and custom props\n   - Context value verification (events, clearLog, logEvent functions)\n   - Provider props behavior (maxLogSize, redirectEventsToConsole)\n   - Event emission from manager and context state updates\n   - clearLog functionality\n   - Context consumer behavior\n   - Integration with components that use the context\n5. Test error handling and edge cases\n\nTesting approach:\n- Create test components that consume the context\n- Render the provider with various props and verify context values\n- Mock the logger manager to simulate events and verify context updates\n- Test the full flow from manager events to context updates to component renders\n- Verify that context functions properly call manager methods\n- Test with empty event arrays and maximum size limits\n- Verify proper error handling for missing providers or invalid context usage",
          "status": "pending",
          "parentTaskId": 22
        }
      ]
    }
  ],
  "metadata": {
    "projectName": "One Button to Space Implementation",
    "totalTasks": 20,
    "sourceFile": "PRD_Implementation_Focused.md",
    "generatedAt": "2023-07-10"
  }
}