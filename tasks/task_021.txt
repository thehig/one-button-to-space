# Task ID: 21
# Title: Optimize Client Application Lifecycle with HMR-Compatible Game Manager Reset
# Status: pending
# Dependencies: None
# Priority: medium
# Description: Refactor the client application startup/lifecycle to implement best practices for Hot Module Replacement (HMR), ensuring game managers reset appropriately during development and maintaining lifecycle integrity for future changes.
# Details:
This task involves a comprehensive review and optimization of the client application's startup and lifecycle processes, with a focus on making it work seamlessly with Hot Module Replacement during development. The developer should:

1. Document the current application startup sequence and game manager initialization flow
2. Identify all game managers and state containers that need proper resetting during HMR
3. Implement a centralized lifecycle management system that:
   - Properly disposes resources when HMR triggers
   - Reinitializes game managers with appropriate state
   - Prevents memory leaks during repeated HMR cycles
4. Create clear separation between initialization, runtime, and cleanup phases
5. Add lifecycle hooks that future components can implement to participate in the lifecycle
6. Implement a registry pattern for game managers to ensure they're properly tracked
7. Add safeguards to prevent multiple initializations or partial state during HMR
8. Create developer-friendly console logging for lifecycle events during development
9. Document the new lifecycle flow with sequence diagrams for future developers
10. Update existing game managers to implement the new lifecycle hooks

The implementation should be backward compatible with existing code while providing a clear path for future components to follow the lifecycle pattern.

# Test Strategy:
Testing should verify both the correctness of the lifecycle implementation and its resilience to HMR cycles:

1. Unit Tests:
   - Create tests for each lifecycle phase (init, reset, dispose)
   - Verify game managers properly implement lifecycle hooks
   - Test edge cases like rapid HMR cycles or partial initialization

2. Integration Tests:
   - Simulate complete application startup and verify all managers initialize correctly
   - Trigger mock HMR events and verify proper cleanup and reinitialization
   - Verify no memory leaks occur after multiple HMR cycles using memory profiling

3. Manual Testing:
   - Perform actual development with HMR enabled, making code changes to trigger reloads
   - Verify game state is appropriately maintained or reset as expected
   - Test with various game states (menu, gameplay, etc.) when HMR triggers
   - Verify console logs show proper lifecycle execution

4. Regression Testing:
   - Ensure existing functionality works without changes after implementation
   - Verify application startup performance isn't negatively impacted

5. Documentation Verification:
   - Review lifecycle documentation for completeness
   - Have another developer attempt to implement a new manager using only the documentation

# Subtasks:
## 1. Document Current Application Lifecycle and Create Manager Registry [done]
### Dependencies: None
### Description: Document the existing application startup sequence, game manager initialization flow, and implement a registry pattern for tracking all game managers, with special attention to Phaser/MatterJS lifecycle considerations.
### Details:
Implementation steps:
1. Create a detailed flowchart of the current application startup sequence
2. Document all existing game managers and their initialization methods
3. Document Phaser/MatterJS specific lifecycle events and cleanup requirements
4. Implement a `GameManagerRegistry` class that will:
   - Maintain a collection of all game managers
   - Provide registration/deregistration methods
   - Include a method to iterate through all registered managers
   - Track Phaser-specific and MatterJS-specific objects for proper cleanup
5. Modify existing game managers to register themselves with the registry
6. Add console logging to track registration events during development
7. Document best practices for Phaser/MatterJS cleanup during HMR cycles

Testing approach:
- Verify all existing game managers are properly registered
- Check console logs to ensure registration events are captured
- Manually test that the registry correctly tracks all game managers
- Verify Phaser and MatterJS objects are properly tracked for cleanup

<info added on 2025-05-02T11:23:04.009Z>
Here's additional information to add to the subtask:

## Implementation Details

### GameManagerRegistry Implementation
- Implemented as a singleton with a private static instance accessible via `getInstance()`
- Uses a Map<string, BaseManager> structure for O(1) lookup performance
- Added `registerManager(manager: BaseManager): void` and `unregisterManager(manager: BaseManager): void` methods
- Implemented `getAllManagers(): BaseManager[]` for iteration
- Added specialized tracking for Phaser and MatterJS objects via `trackPhysicsObject()` and `trackPhaserObject()`

### Lifecycle Management
- Created `cleanupAllManagers(isHMR: boolean = false)` method that:
  - Iterates through managers in reverse registration order
  - Calls each manager's cleanup method with the HMR flag
  - Handles cleanup exceptions gracefully with error logging
  - Returns success/failure status

### HMR-Specific Considerations
- Added detection for Phaser's running state before cleanup to prevent errors
- Implemented MatterJS World cleanup that properly removes all constraints and bodies
- Added safeguards against "double-cleanup" scenarios during HMR cycles
- Created special handling for Scene transitions during HMR

### Documentation
- Created flowchart in Mermaid.js format showing application startup sequence
- Documented manager dependencies and initialization order requirements
- Added JSDoc comments to all registry methods explaining proper usage
- Created developer guide for adding new managers to the registry

### Testing Utilities
- Added debug mode toggle with verbose logging of manager lifecycle events
- Implemented registry inspection methods for debugging/testing
- Created helper methods to verify complete cleanup after HMR cycles
</info added on 2025-05-02T11:23:04.009Z>

<info added on 2025-05-02T11:24:23.852Z>
## Progress Update - InputManager Refactoring

### InputManager Refactoring Details
- Separated cleanup logic from destruction by implementing a dedicated `cleanup(isHMRDispose: boolean)` method
- Enhanced key handling with null safety checks to prevent errors during cleanup
- Implemented proper event listener removal in cleanup method to prevent memory leaks
- Added HMR-specific logic that preserves certain input states during hot reloads

### Implementation Specifics
```typescript
// Example of the refactored cleanup method
public cleanup(isHMRDispose: boolean = false): void {
  // Remove all event listeners first
  this.eventEmitter.removeAllListeners();
  
  // Clear all key bindings with safety checks
  Object.values(this.keys).forEach(key => {
    if (key && key.scene) {
      key.destroy();
    }
  });
  
  // Special HMR handling
  if (isHMRDispose) {
    // Store essential state for restoration after HMR
    InputManager.preservedState = {
      lastInputMethod: this.lastInputMethod,
      inputConfig: this.inputConfig
    };
  } else {
    // Full cleanup for non-HMR scenarios
    this.keys = {};
    this.lastInputMethod = null;
  }
  
  // Unregister from registry
  GameManagerRegistry.getInstance().unregisterManager(this);
}
```

### Registry Integration
- Added proper registration timing in `getInstance()` to ensure the manager is tracked immediately upon instantiation
- Implemented unregistration in cleanup to maintain registry accuracy
- Added debug logging for registration/unregistration events when in development mode

### Testing Verification
- Verified input persistence across HMR cycles with manual testing
- Confirmed proper cleanup through memory profiling in Chrome DevTools
- Validated that keyboard inputs remain functional after HMR cycles
</info added on 2025-05-02T11:24:23.852Z>

<info added on 2025-05-02T11:26:56.553Z>
<info added on 2025-05-02T11:25:45.123Z>
## Progress Update - NetworkManager Refactoring

### NetworkManager Refactoring Details
- Implemented proper separation of concerns between `cleanup` and `destroy` methods:
  - New `async cleanup(isHMRDispose: boolean)` method handles resource release
  - Updated `async destroy()` to delegate to `cleanup(false)` for consistency
  - Modified `static async resetInstance()` to use `await instance.cleanup(false)`

### Implementation Specifics
```typescript
// Example of the refactored NetworkManager cleanup method
public async cleanup(isHMRDispose: boolean = false): Promise<void> {
  // Preserve connection state during HMR if needed
  if (isHMRDispose) {
    NetworkManager.preservedState = {
      connectionStatus: this.connectionStatus,
      roomId: this.room?.id || null
    };
    
    // Don't leave room during HMR - main.tsx handles this contextually
    this.logger.debug('HMR cleanup: preserving room connection');
  } else {
    // Full cleanup for non-HMR scenarios
    if (this.room && this.room.connection.isOpen) {
      await this.leaveRoom();
    }
    this.connectionStatus = ConnectionStatus.DISCONNECTED;
  }
  
  // Common cleanup operations
  this.eventEmitter.removeAllListeners();
  
  // Unregister from registry
  GameManagerRegistry.getInstance().unregisterManager(this);
}
```

### Main Application Refactoring
- Centralized cleanup through `GameManagerRegistry`:
  - Removed direct calls to individual manager `resetInstance` methods in `cleanupApp`
  - Added `GameManagerRegistry.getInstance().cleanup(isHMRDispose)` in `cleanupApp`
  - Removed direct call to `NetworkManager.getInstance().leaveRoom()` during HMR
  - Added initialization sequence via `GameManagerRegistry.getInstance().initializeManagers()`

### Benefits
- Resolved previous lint error in `main.tsx` related to direct NetworkManager calls
- Established consistent cleanup pattern across all managers
- Improved HMR reliability by preserving critical network state
- Centralized manager initialization through registry's `initializeManagers()` method
- Created proper dependency resolution during initialization and cleanup
</info added on 2025-05-02T11:25:45.123Z>
</info added on 2025-05-02T11:26:56.553Z>

<info added on 2025-05-02T11:28:04.436Z>
## Progress Update - CameraManager Refactoring

### CameraManager Refactoring Details
- Implemented proper lifecycle management with a dedicated `cleanup(isHMRDispose: boolean)` method
- Separated cleanup logic from destruction to align with manager registry pattern
- Added registry integration with automatic registration in `getInstance()`
- Implemented proper camera reference handling during HMR cycles

### Implementation Specifics
```typescript
// Example of the refactored CameraManager cleanup method
public cleanup(isHMRDispose: boolean = false): void {
  // Remove all camera event listeners
  if (this.mainCamera) {
    this.mainCamera.removeAllListeners();
    
    // Store camera position during HMR for smooth transitions
    if (isHMRDispose && this.mainCamera.scene) {
      CameraManager.preservedState = {
        position: { x: this.mainCamera.scrollX, y: this.mainCamera.scrollY },
        zoom: this.mainCamera.zoom,
        bounds: this.mainCamera.getBounds()
      };
    }
  }
  
  // Clear follow targets and reset properties
  this.followTarget = null;
  this.isShaking = false;
  this.shakeDuration = 0;
  
  // Unregister from registry
  GameManagerRegistry.getInstance().unregisterManager(this);
}

// Static reset method for consistency with other managers
public static async resetInstance(): Promise<void> {
  if (CameraManager.instance) {
    await CameraManager.instance.cleanup(false);
    CameraManager.instance = null;
  }
}
```

### HMR Improvements
- Added camera state preservation during HMR to prevent jarring camera jumps
- Implemented camera restoration logic in `getInstance()` when preserved state exists
- Added safeguards to prevent camera manipulation during scene transitions

### Registry Integration
- Added automatic registration with `GameManagerRegistry` in the `getInstance()` method
- Implemented proper unregistration in the `cleanup()` method
- Added debug logging for camera state changes when in development mode
</info added on 2025-05-02T11:28:04.436Z>

<info added on 2025-05-02T11:29:28.968Z>
## Progress Update - PhysicsManager Refactoring

### PhysicsManager Refactoring Details
- Implemented proper lifecycle management with a dedicated `cleanup(isHMRDispose: boolean)` method
- Moved all Matter.Events and Phaser world event listener removal to cleanup method
- Added specialized handling for MatterJS physics objects during HMR cycles
- Implemented proper collision category preservation during HMR

### Implementation Specifics
```typescript
// Example of the refactored PhysicsManager cleanup method
public cleanup(isHMRDispose: boolean = false): void {
  // Remove all Matter.Events listeners
  if (this.matterEvents) {
    Matter.Events.off(this.matterEvents);
    this.matterEvents = null;
  }
  
  // Remove all Phaser world event listeners
  if (this.scene && this.scene.matter && this.scene.matter.world) {
    this.scene.matter.world.off('collisionstart');
    this.scene.matter.world.off('collisionactive');
    this.scene.matter.world.off('collisionend');
  }
  
  // Special HMR handling
  if (isHMRDispose) {
    // Store collision categories for restoration after HMR
    PhysicsManager.preservedState = {
      collisionCategories: { ...this.collisionCategories },
      debugMode: this.debugMode
    };
    
    // Track all active physics bodies in registry for proper cleanup
    if (this.scene && this.scene.matter && this.scene.matter.world) {
      const bodies = this.scene.matter.world.getAllBodies();
      bodies.forEach(body => {
        GameManagerRegistry.getInstance().trackPhysicsObject(body);
      });
    }
  }
  
  // Reset properties
  this.collisionHandlers = {};
  this.scene = null;
  
  // Unregister from registry
  GameManagerRegistry.getInstance().unregisterManager(this);
}
```

### Collision Handler Updates
- Updated collision handler signature to match Phaser world event emitter arguments:
  ```typescript
  // Old signature
  type CollisionHandler = (bodyA: MatterJS.BodyType, bodyB: MatterJS.BodyType) => void;
  
  // New signature
  type CollisionHandler = (
    event: Phaser.Physics.Matter.Events.CollisionStartEvent | 
           Phaser.Physics.Matter.Events.CollisionActiveEvent | 
           Phaser.Physics.Matter.Events.CollisionEndEvent, 
    bodyA: MatterJS.BodyType, 
    bodyB: MatterJS.BodyType
  ) => void;
  ```
- Updated all collision handler calls to pass the event object as first parameter
- Added type safety checks to prevent errors when handlers are called with invalid parameters

### Registry Integration
- Added automatic registration with `GameManagerRegistry` in the `getInstance()` method
- Implemented proper physics object tracking for MatterJS bodies and constraints
- Added debug visualization toggle that persists across HMR cycles
</info added on 2025-05-02T11:29:28.968Z>

<info added on 2025-05-02T11:30:48.868Z>
## Progress Update - SceneManager Refactoring

### SceneManager Refactoring Details
- Decoupled `Phaser.Game` instance from constructor and `getInstance()` method
- Implemented proper lifecycle management with a dedicated `cleanup(isHMRDispose: boolean)` method
- Added registry integration with automatic registration in `getInstance()`
- Created scene transition preservation during HMR cycles

### Implementation Specifics
```typescript
// Example of the refactored SceneManager cleanup method
public cleanup(isHMRDispose: boolean = false): void {
  // Store scene state during HMR
  if (isHMRDispose && this.currentScene) {
    SceneManager.preservedState = {
      currentSceneKey: this.currentScene.scene.key,
      pendingTransition: this.pendingSceneTransition,
      sceneData: this.currentScene.registry.getAll()
    };
  }
  
  // Clear all scene-specific event listeners
  this.eventEmitter.removeAllListeners();
  
  // Reset scene references
  if (!isHMRDispose) {
    this.currentScene = null;
    this.pendingSceneTransition = null;
  }
  
  // Unregister from registry
  GameManagerRegistry.getInstance().unregisterManager(this);
}

// Helper method for accessing game instance
private getGame(): Phaser.Game {
  // Temporary solution using window.phaserGame
  // TODO: Refactor to avoid global reference for production
  return window.phaserGame;
}
```

### HMR Improvements
- Added scene state preservation during HMR to maintain game state across reloads
- Implemented scene restoration logic in `getInstance()` when preserved state exists
- Added safeguards to prevent scene transitions during HMR cycles
- Created proper handling for pending scene transitions that were interrupted by HMR

### Registry Integration
- Added automatic registration with `GameManagerRegistry` in the `getInstance()` method
- Implemented proper unregistration in the `cleanup()` method
- Added debug logging for scene transitions when in development mode
</info added on 2025-05-02T11:30:48.868Z>

<info added on 2025-05-02T11:32:07.551Z>
## Progress Update - TimeManager Refactoring

### TimeManager Refactoring Details
- Implemented proper lifecycle management with a dedicated `cleanup(isHMRDispose: boolean)` method
- Added registry integration with automatic registration in `getInstance()`
- Created time state preservation during HMR cycles to maintain game timing
- Implemented proper event listener cleanup for all time-related events

### Implementation Specifics
```typescript
// Example of the refactored TimeManager cleanup method
public cleanup(isHMRDispose: boolean = false): void {
  // Remove all time-related event listeners
  this.eventEmitter.removeAllListeners();
  
  // Cancel all active timers and intervals
  this.activeTimers.forEach(timer => {
    if (timer.timerEvent) {
      timer.timerEvent.remove();
    }
  });
  
  // Store time state during HMR
  if (isHMRDispose) {
    TimeManager.preservedState = {
      gameTime: this.gameTime,
      timeScale: this.timeScale,
      isPaused: this.isPaused
    };
  } else {
    // Full reset for non-HMR scenarios
    this.gameTime = 0;
    this.timeScale = 1;
    this.isPaused = false;
  }
  
  // Clear all timers
  this.activeTimers = [];
  
  // Unregister from registry
  GameManagerRegistry.getInstance().unregisterManager(this);
}

// Static reset method for consistency with other managers
public static async resetInstance(): Promise<void> {
  if (TimeManager.instance) {
    await TimeManager.instance.cleanup(false);
    TimeManager.instance = null;
  }
}
```

### HMR Improvements
- Added time state preservation during HMR to maintain consistent game timing
- Implemented time restoration logic in `getInstance()` when preserved state exists
- Added safeguards to prevent timer duplication during HMR cycles
- Created proper handling for paused state preservation across HMR

### Registry Integration
- Added automatic registration with `GameManagerRegistry` in the `getInstance()` method
- Implemented proper unregistration in the `cleanup()` method
- Added debug logging for time scale changes when in development mode
</info added on 2025-05-02T11:32:07.551Z>

<info added on 2025-05-02T11:35:59.439Z>
## Final Documentation for Manager Registry and Lifecycle

### Architecture Overview
- The `GameManagerRegistry` implements a centralized manager lifecycle control system
- All managers follow a consistent pattern: `init() → update() → cleanup() → destroy()`
- HMR-aware cleanup preserves critical state while releasing resources

### Implementation Recommendations
```typescript
// BaseManager abstract class (recommended implementation)
export abstract class BaseManager {
  protected eventEmitter: Phaser.Events.EventEmitter;
  
  constructor() {
    this.eventEmitter = new Phaser.Events.EventEmitter();
  }
  
  public abstract init(): void | Promise<void>;
  public abstract update(time: number, delta: number): void;
  public abstract cleanup(isHMRDispose: boolean): void | Promise<void>;
  
  public async destroy(): Promise<void> {
    await this.cleanup(false);
  }
}
```

### Registry Initialization Order
The registry should initialize managers in dependency order:
1. TimeManager (no dependencies)
2. InputManager (no dependencies)
3. NetworkManager (depends on TimeManager for timeouts)
4. SceneManager (depends on TimeManager)
5. PhysicsManager (depends on SceneManager)
6. CameraManager (depends on SceneManager)
7. EntityManager (depends on PhysicsManager, SceneManager)

### Best Practices
- Always use `GameManagerRegistry.getInstance().registerManager(this)` in manager constructors
- Implement thorough cleanup in each manager's `cleanup()` method
- Use the `isHMRDispose` flag to determine preservation needs during hot reloads
- Track all event listeners and remove them during cleanup
- Document manager dependencies to maintain proper initialization order
- Use debug mode during development to verify proper registration/cleanup

### Common Pitfalls
- Circular dependencies between managers
- Incomplete event listener cleanup causing memory leaks
- Missing Phaser/MatterJS object cleanup
- Improper handling of async operations during cleanup
- Attempting to access destroyed resources after cleanup
</info added on 2025-05-02T11:35:59.439Z>

## 2. Design and Implement Lifecycle Interface and Hooks [done]
### Dependencies: 21.1
### Description: Create a standardized lifecycle interface with hooks for initialization, runtime, and cleanup phases that all game managers will implement, with rigorous cleanup procedures for Phaser/MatterJS objects.
### Details:
Implementation steps:
1. Define a `LifecycleAware` interface with methods:
   - `initialize()`: Setup resources and state
   - `onActive()`: Called when component becomes active
   - `onInactive()`: Called when component becomes inactive
   - `dispose()`: Cleanup resources to prevent memory leaks
2. Add Phaser/MatterJS specific cleanup methods to the interface:
   - `cleanupPhaserObjects()`: Remove sprites, game objects, input handlers
   - `cleanupMatterObjects()`: Remove bodies, constraints, collision listeners
   - `cleanupEventListeners()`: Remove all event listeners (Phaser, Matter, custom)
   - `cleanupTimers()`: Cancel all active timers and scheduled callbacks
3. Create a `LifecycleManager` class that orchestrates lifecycle events
4. Integrate the lifecycle manager with the game manager registry
5. Implement developer-friendly console logging for lifecycle events
6. Add safeguards to prevent multiple initializations
7. Ensure MatterJS world simulation is properly paused/resumed with lifecycle events

Testing approach:
- Create test components implementing the lifecycle interface
- Verify all lifecycle hooks are called in the correct order
- Test edge cases like multiple initialization attempts
- Check console output for clear lifecycle event logging
- Verify Phaser and MatterJS objects are properly cleaned up during disposal

<info added on 2025-05-02T12:33:19.838Z>
## Implementation Details for Lifecycle Interface and Hooks

### Interface Implementation Specifics
- Use TypeScript's `implements` keyword to enforce lifecycle contract: `class GameManager implements LifecycleAware`
- Make cleanup methods return `boolean` to indicate success/failure for better debugging
- Add optional `priority` property (number) to control initialization/disposal order

### Lifecycle Manager Enhancements
```typescript
// State transition validation matrix
private readonly validTransitions: Record<ApplicationLifecycleState, ApplicationLifecycleState[]> = {
  [ApplicationLifecycleState.IDLE]: [ApplicationLifecycleState.INITIALIZING],
  [ApplicationLifecycleState.INITIALIZING]: [ApplicationLifecycleState.ACTIVE, ApplicationLifecycleState.DISPOSING],
  [ApplicationLifecycleState.ACTIVE]: [ApplicationLifecycleState.INACTIVE, ApplicationLifecycleState.DISPOSING],
  [ApplicationLifecycleState.INACTIVE]: [ApplicationLifecycleState.ACTIVE, ApplicationLifecycleState.DISPOSING],
  [ApplicationLifecycleState.DISPOSING]: [ApplicationLifecycleState.IDLE]
};

// MatterJS pause/resume implementation
private handleMatterJSState(active: boolean): void {
  const physicsManager = this.registry.getManager('physics') as PhysicsManager;
  if (physicsManager?.matter) {
    if (active) {
      physicsManager.matter.world.resume();
    } else {
      physicsManager.matter.world.pause();
    }
  }
}
```

### Disposal Strategy Pattern
Implement a strategy pattern for different cleanup scenarios:
```typescript
// Define cleanup strategies
type CleanupStrategy = (manager: LifecycleAware) => void;

private cleanupStrategies: Record<string, CleanupStrategy> = {
  'phaser': (manager) => manager.cleanupPhaserObjects?.(),
  'matter': (manager) => manager.cleanupMatterObjects?.(),
  'events': (manager) => manager.cleanupEventListeners?.(),
  'timers': (manager) => manager.cleanupTimers?.()
};

// Execute all cleanup strategies
public executeCleanup(manager: LifecycleAware): void {
  Object.values(this.cleanupStrategies).forEach(strategy => {
    try {
      strategy(manager);
    } catch (error) {
      console.error(`Cleanup strategy failed:`, error);
    }
  });
}
```

### Dependency-Aware Initialization
```typescript
public initializeAll(): void {
  // Sort managers by dependencies before initialization
  const sortedManagers = this.sortManagersByDependencies(
    this.registry.getAllManagers().filter(isLifecycleAware)
  );
  
  for (const manager of sortedManagers) {
    manager.initialize();
  }
}

private sortManagersByDependencies(managers: LifecycleAware[]): LifecycleAware[] {
  // Topological sort implementation based on manager dependencies
  // This ensures dependent managers initialize after their dependencies
}
```

### Diagnostic Tools
Add diagnostic methods to help debug lifecycle issues:
```typescript
public getManagerStates(): Record<string, ApplicationLifecycleState> {
  const states: Record<string, ApplicationLifecycleState> = {};
  this.registry.getAllManagers().forEach(manager => {
    if (isLifecycleAware(manager)) {
      states[manager.constructor.name] = this.getManagerState(manager);
    }
  });
  return states;
}
```
</info added on 2025-05-02T12:33:19.838Z>

## 3. Implement HMR Detection and Cleanup Logic [in-progress]
### Dependencies: 21.2
### Description: Add logic to detect Hot Module Replacement events and properly dispose resources before the application reloads, with special focus on Phaser/MatterJS cleanup and multiplayer state resynchronization.
### Details:
Implementation steps:
1. Research and implement HMR event detection for the current framework
2. Create an `HmrHandler` class that listens for HMR events
3. Connect the HMR handler to the lifecycle manager to trigger cleanup
4. Implement a complete disposal sequence that:
   - Calls `dispose()` on all registered game managers
   - Ensures all Phaser objects are properly destroyed
   - Removes all MatterJS bodies and constraints from the physics world
   - Clears any global state or event listeners
   - Pauses MatterJS world simulation
   - Logs cleanup operations to console during development
5. Add error handling to ensure partial cleanups don't break the application
6. Implement server state resynchronization after HMR rather than client-side state preservation
7. Add hooks for multiplayer reconnection/state refresh after HMR completion

Testing approach:
- Test in development environment with HMR enabled
- Verify resources are properly cleaned up during HMR (check memory usage)
- Ensure no console errors appear during multiple HMR cycles
- Validate that global event listeners aren't duplicated after HMR
- Verify MatterJS physics objects are completely removed during cleanup
- Test multiplayer state resynchronization after HMR completes

## 4. Refactor Existing Game Managers to Support Lifecycle [pending]
### Dependencies: 21.2, 21.3
### Description: Update all existing game managers to implement the lifecycle interface and properly handle initialization and cleanup, with rigorous Phaser/MatterJS resource management.
### Details:
Implementation steps:
1. Identify all game managers that need refactoring
2. For each game manager:
   - Implement the `LifecycleAware` interface
   - Move initialization code to the `initialize()` method
   - Add proper resource cleanup in the `dispose()` method
   - Implement Phaser-specific cleanup methods
   - Implement MatterJS-specific cleanup methods
   - Ensure all event listeners are properly removed
   - Ensure all timers are cancelled
   - Ensure state is correctly preserved or reset as needed
3. Update manager constructors to avoid heavy initialization work
4. Add state tracking to prevent duplicate initialization
5. Implement proper error handling in lifecycle methods
6. For multiplayer components, add server state resynchronization after HMR

Testing approach:
- Test each refactored game manager individually
- Verify initialization and cleanup work correctly
- Test managers through multiple HMR cycles
- Check for memory leaks using browser developer tools
- Verify Phaser objects are properly destroyed
- Verify MatterJS bodies and constraints are removed from the world
- Ensure game functionality remains intact after refactoring
- Test multiplayer state consistency after HMR cycles

## 5. Implement Centralized Application Lifecycle Management [pending]
### Dependencies: 21.1, 21.2, 21.3, 21.4
### Description: Create a centralized system to manage the entire application lifecycle, integrating HMR support and documenting the new flow, with comprehensive Phaser/MatterJS cleanup procedures and multiplayer state resynchronization.
### Details:
Implementation steps:
1. Create an `ApplicationLifecycle` class that:
   - Controls the overall application startup sequence
   - Manages the transition between application states
   - Integrates with the HMR handler and lifecycle manager
   - Provides hooks for future components
   - Orchestrates Phaser/MatterJS cleanup during shutdown
   - Handles multiplayer state resynchronization after HMR
2. Refactor the main application entry point to use the new lifecycle system
3. Implement server state resynchronization between HMR reloads for multiplayer consistency
4. Create comprehensive sequence diagrams documenting the new lifecycle flow
5. Add detailed developer documentation explaining:
   - How to integrate new components with the lifecycle
   - Best practices for initialization and cleanup
   - Specific guidelines for Phaser object cleanup
   - Specific guidelines for MatterJS physics cleanup
   - How to handle event listeners properly
   - How HMR works with the application
   - Multiplayer state handling during HMR
   - Troubleshooting common issues

Testing approach:
- End-to-end testing of the complete application lifecycle
- Verify application correctly initializes on first load
- Test multiple HMR cycles to ensure stability
- Validate that all game managers properly participate in the lifecycle
- Verify Phaser and MatterJS resources are properly cleaned up
- Test multiplayer functionality through HMR cycles
- Review documentation for clarity and completeness

## 6. Investigate camera losing player target after HMR [pending]
### Dependencies: None
### Description: Verify why the camera stops following the player character after a Hot Module Replacement event occurs in the client.
### Details:


